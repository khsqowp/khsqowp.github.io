---
title: "파이썬 제어구문 및 반복문 강의 노트 3일차"
date: 2026-01-09
permalink: /posts/2026/01/09/파이썬-제어구문-및-반복문-강의-노트-3일차/
tags:
  - Python
  - SK_Rookies
---

# 📝 파이썬 제어구문 및 반복문 강의 노트 (3일차)

## 🎯 오늘의 학습 목표

오늘 강의에서는 파이썬의 핵심 문법인 **제어구문(분기문)**과 **반복문**에 대해 심도있게 배웠습니다. 지난 이틀 동안 변수의 타입(list, dict, tuple, set)을 다루면서 데이터를 다루는 기본기를 쌓았다면, 이제는 그 데이터를 가지고 **의사결정을 내리고 반복 작업을 수행**하는 단계로 나아갑니다.

오늘 학습한 주요 내용:
- **분기문(if, elif, else)**: 조건에 따라 다른 코드를 실행
- **input() 함수**: 사용자로부터 입력받기
- **반복문(for, while)**: 반복 작업 자동화
- **날짜 타입**: date, datetime 객체 다루기
- **3항 연산자**: 간결한 조건부 표현식
- **실전 예제**: 윤년 판별, 숫자 맞추기 게임, 구구단 등

> 💡 **중요!**: 제어구문과 반복문은 프로그래밍의 핵심입니다. 데이터 분석이나 인공지능 분야에서도 데이터를 필터링하고 반복 처리하는 작업이 필수적이기 때문에, 이 개념들을 완벽히 이해하는 것이 매우 중요합니다.

---

## 📚 학습 내용 복습

### 지난 강의 질문 해결: set의 순서 보장 문제

강의 시작 전, 어제 배운 단어 빈도수 계산 코드에 대해 질문이 있었습니다. 강사님께서 이 질문을 매우 중요하게 다루셨는데, 이는 **보안적 관점**에서도 예측 가능한 동작을 보장하는 것이 중요하기 때문입니다.

#### 문제가 된 기존 코드

```python
wordLst = ['dog', 'dog', 'cat', 'cat', 'word', 'dog', 'cat', 'cs', 'cat', 'cs', 'sk']
wordDict = {word: 0 for word in set(wordLst)}
for word in wordLst:
    wordDict[word] += 1
print(wordDict)

result = dict(zip(set(wordLst), [wordLst.count(data) for data in set(wordLst)]))
print(result)
```

**문제점**: `set()`을 사용하면 순서가 보장되지 않습니다. 위 코드에서 `set(wordLst)`을 두 번 호출하는데, 매번 실행할 때마다 순서가 달라질 수 있어 매핑이 잘못될 가능성이 있습니다.

> 💡 **중요!**: `set`은 수학의 집합과 같이 순서가 없는 자료구조입니다. Python 3.7 이후 딕셔너리는 삽입 순서를 보장하지만, `set`은 여전히 순서를 보장하지 않습니다.

#### 개선 코드 버전 1: sorted() 활용

```python
wordLst = ['dog', 'dog', 'cat', 'cat', 'word', 'dog', 'cat', 'cs', 'cat', 'cs', 'sk']

unique = sorted(set(wordLst))
freq = [wordLst.count(word) for word in unique]
result = dict(zip(unique, freq))
print(result)
```

#### 💻 코드 실행 상세 분석

**1단계 (고유 단어 추출 및 정렬)**:
- `set(wordLst)`: 리스트에서 중복을 제거하여 `{'dog', 'cat', 'word', 'cs', 'sk'}` 집합 생성
- `sorted(...)`: 집합을 정렬하여 `['cat', 'cs', 'dog', 'sk', 'word']` 리스트 반환
- `unique` 변수에 정렬된 고유 단어 리스트가 저장됨

**2단계 (빈도수 계산)**:
- 리스트 컴프리헨션 `[wordLst.count(word) for word in unique]` 실행
- `'cat'`: `wordLst.count('cat')` → 4번 등장
- `'cs'`: `wordLst.count('cs')` → 2번 등장
- `'dog'`: `wordLst.count('dog')` → 3번 등장
- `'sk'`: `wordLst.count('sk')` → 1번 등장
- `'word'`: `wordLst.count('word')` → 1번 등장
- `freq` 변수에 `[4, 2, 3, 1, 1]` 저장

**3단계 (딕셔너리 생성)**:
- `zip(unique, freq)`: 두 리스트를 묶어 `[('cat', 4), ('cs', 2), ('dog', 3), ('sk', 1), ('word', 1)]` 생성
- `dict(...)`: 튜플 리스트를 딕셔너리로 변환
- **최종 결과**: `{'cat': 4, 'cs': 2, 'dog': 3, 'sk': 1, 'word': 1}`

#### 개선 코드 버전 2: collections.Counter 활용

```python
from collections import Counter

wordLst = ['dog', 'dog', 'cat', 'cat', 'word', 'dog', 'cat', 'cs', 'cat', 'cs', 'sk', 'sk']
result = dict(Counter(wordLst))
print(result)
```

#### 💻 코드 실행 상세 분석

**1단계 (Counter 객체 생성)**:
- `Counter(wordLst)`: 리스트의 각 요소를 자동으로 카운팅
- 내부적으로 해시맵을 사용하여 O(n) 시간 복잡도로 효율적 처리
- `Counter({'cat': 4, 'dog': 3, 'cs': 2, 'sk': 2, 'word': 1})` 객체 생성

**2단계 (딕셔너리 변환)**:
- `dict(...)`: Counter 객체를 일반 딕셔너리로 변환
- **최종 결과**: `{'dog': 3, 'cat': 4, 'word': 1, 'cs': 2, 'sk': 2}`

> 📌 **노트**: `Counter`는 `collections` 모듈에서 제공하는 특수한 딕셔너리로, 빈도수 계산에 최적화되어 있습니다. 코드가 간결하고 가독성이 높으며 성능도 우수합니다.

#### 개선 코드 버전 3: dict.fromkeys() 활용

```python
wordLst = ['dog', 'dog', 'cat', 'cat', 'word', 'dog', 'cat', 'cs', 'cat', 'cs', 'sk', 'sk']
result = {key: wordLst.count(key) for key in dict.fromkeys(wordLst)}
print(result)
```

#### 💻 코드 실행 상세 분석

**1단계 (고유 키 추출)**:
- `dict.fromkeys(wordLst)`: 리스트의 순서를 유지하면서 중복 제거
- Python 3.7+ 에서는 딕셔너리가 삽입 순서를 유지하므로, 원본 리스트에서 처음 등장한 순서대로 키가 생성됨
- `{'dog': None, 'cat': None, 'word': None, 'cs': None, 'sk': None}` 생성

**2단계 (딕셔너리 컴프리헨션)**:
- 각 키에 대해 `wordLst.count(key)` 실행
- `'dog'`: 3, `'cat'`: 4, `'word'`: 1, `'cs'`: 2, `'sk'`: 2
- **최종 결과**: `{'dog': 3, 'cat': 4, 'word': 1, 'cs': 2, 'sk': 2}`

> 💡 **중요!**: 이 방법은 원본 리스트의 등장 순서를 유지합니다. 만약 순서가 중요한 경우에는 이 방법이 가장 적합합니다.

#### 세 가지 방법의 비교

| 방법 | 장점 | 단점 | 사용 상황 |
|------|------|------|-----------|
| sorted() + zip | 순서 보장 (알파벳순) | 코드가 길고 읽기 복잡 | 정렬된 결과가 필요할 때 |
| Counter | 코드 간결, 고성능 | 외부 모듈 import 필요 | 일반적인 빈도수 계산 |
| dict.fromkeys() | 원본 순서 유지 | count() 호출로 성능 저하 | 등장 순서가 중요할 때 |

---

## 🎮 제어구문 (Control Flow)

### 제어구문이란?

**제어구문**은 프로그램의 실행 흐름을 제어하는 구문입니다. 데이터 분석에서 특정 조건을 만족하는 데이터만 필터링하거나, 인공지능 모델 학습 시 특정 조건에 따라 다른 처리를 하는 등 실무에서 필수적으로 사용됩니다.

강사님께서 강조하신 포인트:
- 어떤 특정한 데이터가 용량이 많다면 (대량의 동일 포맷 데이터)
- 특정한 조건에 맞는 필터링이 필요하다면
- → **분기문과 반복문을 활용**해야 합니다!

### if 문의 기본 구조

```python
if True :
    print('Good')
else :
    print('Bad')
```

#### 💻 코드 실행 상세 분석

**1단계 (조건 평가)**:
- `if` 키워드 다음의 조건 `True`를 평가합니다
- 이 경우 조건이 리터럴 `True`이므로 항상 참입니다

**2단계 (블록 실행)**:
- 조건이 참이므로 `if` 블록의 코드가 실행됩니다
- `print('Good')`이 실행되어 콘솔에 "Good"이 출력됩니다
- `else` 블록은 실행되지 않습니다

**최종 결과**: `Good` 출력

> 💡 **중요!**: Python에서 블록은 `:`(콜론)으로 시작하고 **들여쓰기(indentation)**로 구분됩니다. Java나 C++의 중괄호 `{}`를 사용하지 않습니다. 이는 Python의 철학인 "가독성"을 위한 설계입니다.

### if 문에 들어갈 수 있는 것들

if 문의 조건 부분에는 다음이 들어갈 수 있습니다:

1. **논리값(Boolean)**: `True`, `False`
2. **논리식(Boolean Expression)**: 비교 연산자나 논리 연산자를 사용한 표현식
3. **Truthy/Falsy 값**: Python의 모든 객체는 boolean 컨텍스트에서 평가됩니다

#### Truthy와 Falsy 개념

Python에서는 `True`/`False`가 아니더라도 boolean 컨텍스트에서 참/거짓으로 평가됩니다:

**Falsy 값 (거짓으로 평가)**:
- `False`
- `0`, `0.0`
- 빈 시퀀스: `''`, `[]`, `()`, `{}`
- `None`

**Truthy 값 (참으로 평가)**:
- 위의 Falsy 값들을 제외한 모든 값
- 예: 0이 아닌 숫자, 비어있지 않은 시퀀스, 사용자 정의 객체 등

```python
# Falsy 예제
if [] :
    print("실행 안됨")
else :
    print("빈 리스트는 Falsy")  # 이것이 실행됨

# Truthy 예제
if [1, 2, 3] :
    print("비어있지 않은 리스트는 Truthy")  # 이것이 실행됨
```

---

## 📥 input() 함수 - 사용자 입력 받기

### input() 함수의 기본 사용법

`input()` 함수는 콘솔을 통해 사용자의 입력을 받는 함수입니다. 이 함수는 **항상 문자열(str) 타입**으로 값을 반환합니다.

```python
score = int(input('점수를 입력하세요 : '))
print('type - ', type(score))

if score >= 60 :
    print('Pass')
else :
    print('None Pass')
```

#### 💻 코드 실행 상세 분석

**1단계 (사용자 입력 대기)**:
- `input('점수를 입력하세요 : ')` 함수가 호출됩니다
- 프로그램이 일시 정지되고 사용자의 입력을 기다립니다
- 콘솔에 "점수를 입력하세요 : " 메시지가 표시됩니다

**2단계 (입력값 수신 및 변환)**:
- 사용자가 키보드로 `75`를 입력하고 Enter를 누릅니다
- `input()` 함수는 `"75"` (문자열)를 반환합니다
- `int(...)` 함수가 문자열 `"75"`를 정수 `75`로 변환합니다
- 변환된 정수가 `score` 변수에 저장됩니다

**3단계 (타입 확인)**:
- `type(score)` → `<class 'int'>`
- `print('type - ', <class 'int'>)` → "type - <class 'int'>" 출력

**4단계 (조건 평가 및 실행)**:
- `score >= 60` → `75 >= 60` → `True`
- 조건이 참이므로 `print('Pass')` 실행
- **최종 결과**: "Pass" 출력

> 🔐 **보안 노트**: `input()` 함수는 사용자 입력을 받는 함수로, **보안상 매우 주의**해야 합니다!

### 🔐 input() 함수의 보안 취약점

#### 취약점 1: 타입 변환 오류 (Type Conversion Error)

```python
# 취약한 코드
score = int(input('점수를 입력하세요 : '))
```

**문제점**:
- 사용자가 정수가 아닌 문자열 (예: "abc", "hello")을 입력하면 `ValueError` 예외가 발생합니다
- 프로그램이 비정상 종료되어 **서비스 거부(DoS)** 공격에 악용될 수 있습니다

**공격 시나리오**:
1. 악의적인 사용자가 의도적으로 잘못된 입력을 반복 전송
2. 프로그램이 계속 예외를 발생시켜 재시작
3. 시스템 리소스 낭비 및 서비스 불가 상태 유발

**개선 코드**:
```python
try:
    score = int(input('점수를 입력하세요 : '))
    if 0 <= score <= 100:
        if score >= 60:
            print('Pass')
        else:
            print('Fail')
    else:
        print('점수는 0~100 사이의 값이어야 합니다.')
except ValueError:
    print('올바른 숫자를 입력해주세요.')
```

#### 취약점 2: 입력값 범위 검증 부재

```python
# 취약한 코드
score = int(input('점수를 입력하세요 : '))
if score >= 60:
    print('Pass')
```

**문제점**:
- 음수 입력 가능: `-1000` → "Fail" (논리적으로 잘못됨)
- 과도하게 큰 값 입력 가능: `9999999` → "Pass" (논리적으로 잘못됨)
- 범위 검증이 없어 **논리적 오류**를 유발합니다

**개선 코드**:
```python
try:
    score = int(input('점수를 입력하세요 : '))
    # 입력값 범위 검증 추가
    if score < 0 or score > 100:
        print('오류: 점수는 0~100 사이의 값이어야 합니다.')
    elif score >= 60:
        print('Pass')
    else:
        print('Fail')
except ValueError:
    print('오류: 올바른 숫자를 입력해주세요.')
```

#### 취약점 3: 입력 길이 제한 부재

```python
# 취약한 코드
name = input('이름을 입력하세요 : ')
```

**문제점**:
- 사용자가 매우 긴 문자열을 입력하면 메모리 낭비
- **버퍼 오버플로우** 유사 공격 가능
- 시스템 리소스 고갈

**개선 코드**:
```python
name = input('이름을 입력하세요 : ')
MAX_LENGTH = 50

if len(name) > MAX_LENGTH:
    print(f'오류: 이름은 {MAX_LENGTH}자 이내로 입력해주세요.')
    name = name[:MAX_LENGTH]  # 잘라내기
else:
    print(f'입력된 이름: {name}')
```

> 💡 **중요!**: 실전에서는 사용자 입력을 절대 신뢰하지 않습니다. **항상 검증(Validation)**해야 합니다!

---

## 🎓 학점 계산 프로그램

### 기본 학점 계산

```python
score = int(input('점수를 입력하세요 : '))
print('type - ', type(score))

if score >= 90 :
    if score >= 95 :
        print('A+')
    else :
        print('A-')
elif score >= 80 :
    if score >= 85 :
        print('B+')
    else :
        print('B-')
elif score >= 70 :
    if score >= 75 :
        print('C+')
    else :
        print('C-')
else :
    print('F')
```

#### 💻 코드 실행 상세 분석 (점수 87 입력 시)

**1단계 (입력 및 변환)**:
- 사용자가 `87` 입력
- `int("87")` → `87` (정수)
- `score` 변수에 `87` 저장

**2단계 (첫 번째 조건 평가)**:
- `score >= 90` → `87 >= 90` → `False`
- 첫 번째 `if` 블록 건너뜀

**3단계 (두 번째 조건 평가)**:
- `elif score >= 80` → `87 >= 80` → `True`
- 해당 블록 진입

**4단계 (중첩 조건 평가)**:
- 블록 내부의 `if score >= 85` → `87 >= 85` → `True`
- `print('B+')` 실행

**최종 결과**: `B+` 출력

> 📌 **노트**: 강사님께서 "**중첩 if문을 많이 사용하거나 if문을 많이 사용하는 것을 지양한다**"고 강조하셨습니다. 이유는 다음과 같습니다:
> 1. **가독성 저하**: 중첩이 깊어질수록 코드 이해가 어려워짐
> 2. **유지보수 어려움**: 조건 변경 시 여러 곳을 수정해야 함
> 3. **버그 발생 가능성 증가**: 복잡한 로직은 실수하기 쉬움

### 개선된 학점 계산 (중첩 최소화)

```python
score = int(input('점수를 입력하세요 : '))

if score >= 95:
    print('A+')
elif score >= 90:
    print('A-')
elif score >= 85:
    print('B+')
elif score >= 80:
    print('B-')
elif score >= 75:
    print('C+')
elif score >= 70:
    print('C-')
elif score >= 60:
    print('D')
else:
    print('F')
```

이 코드가 더 나은 이유:
- 중첩 없이 순차적 검사
- 가독성 향상
- 조건 추가/수정이 용이

---

## 🔍 if ~ in 구문

### 리스트에서 멤버십 테스트

`in` 연산자는 특정 요소가 시퀀스(리스트, 튜플, 문자열 등)에 포함되어 있는지 확인합니다.

```python
areas = ['서울', '경기', '인천', '부산']
region = input('지역을 입력하세요 : ')

if region in areas :
    print('응')
else :
    print(f' {region} 지역은 대상이 아닙니다')
```

#### 💻 코드 실행 상세 분석 (사용자가 "서울" 입력 시)

**1단계 (리스트 초기화)**:
- `areas` 리스트에 `['서울', '경기', '인천', '부산']` 저장

**2단계 (사용자 입력)**:
- `input()` 함수로 사용자 입력 대기
- 사용자가 `서울` 입력
- `region` 변수에 `"서울"` 저장

**3단계 (멤버십 테스트)**:
- `region in areas` → `"서울" in ['서울', '경기', '인천', '부산']` → `True`
- Python이 리스트를 순회하며 `"서울"`과 일치하는 요소를 찾음
- 첫 번째 요소에서 일치하므로 `True` 반환

**4단계 (조건 실행)**:
- 조건이 `True`이므로 `print('응')` 실행

**최종 결과**: `응` 출력

### 딕셔너리에서 키 존재 확인

```python
dictTmp = {'melon' : 100, 'bravo' : 200, 'bibibig' : 300}
print('키의 존재 유무 판단')
target = 'banana'
if target in dictTmp :
    print(dictTmp[target])
else :
    print(f'{target}키는 대상이 아닙니다.')
```

#### 💻 코드 실행 상세 분석

**1단계 (딕셔너리 생성)**:
- `dictTmp` 딕셔너리에 3개의 키-값 쌍 저장
- 메모리에 해시 테이블 구조로 저장됨

**2단계 (타겟 설정)**:
- `target` 변수에 `'banana'` 문자열 저장

**3단계 (키 존재 확인)**:
- `target in dictTmp` → `'banana' in {'melon': 100, 'bravo': 200, 'bibibig': 300}`
- 딕셔너리는 해시 테이블을 사용하므로 O(1) 시간 복잡도로 빠르게 검색
- `'banana'` 키가 존재하지 않으므로 `False` 반환

**4단계 (조건 실행)**:
- 조건이 `False`이므로 `else` 블록 실행
- f-string을 사용하여 `target` 값을 문자열에 삽입
- `print('banana키는 대상이 아닙니다.')` 실행

**최종 결과**: `banana키는 대상이 아닙니다.` 출력

> 💡 **중요!**: 딕셔너리에서 `in` 연산자는 **키(key)**를 검색합니다. 값(value)을 검색하려면 `target in dictTmp.values()`를 사용해야 합니다.

### in 연산자의 시간 복잡도

| 자료구조 | 시간 복잡도 | 설명 |
|---------|------------|------|
| list | O(n) | 리스트를 순차적으로 탐색 |
| tuple | O(n) | 튜플을 순차적으로 탐색 |
| set | O(1) | 해시 테이블 사용 |
| dict | O(1) | 해시 테이블 사용 (키 검색) |

> 📌 **노트**: 대량의 데이터에서 멤버십 테스트를 자주 수행한다면 `set`이나 `dict`를 사용하는 것이 효율적입니다.

---

## 📐 연산자 심화

### 주요 연산자 복습

강사님께서 강조하신 주요 연산자들:

1. **나머지 연산자 (`%`)**: 나누기의 나머지를 구함
2. **비교 연산자 (`==`, `!=`)**: 값의 동등성 비교
3. **논리 연산자 (`and`, `or`)**: 논리 조건 결합

```python
# 나머지 연산자 예제
print(10 % 3)  # 1 (10을 3으로 나눈 나머지)
print(15 % 4)  # 3 (15를 4로 나눈 나머지)

# 짝수/홀수 판별
number = 7
if number % 2 == 0:
    print('짝수')
else:
    print('홀수')  # 출력됨
```

### 논리 연산자의 단락 평가 (Short-circuit Evaluation)

Python의 논리 연산자는 **단락 평가(short-circuit evaluation)**를 수행합니다.

```python
# and 연산자: 첫 번째가 False면 두 번째를 평가하지 않음
False and expensive_function()  # expensive_function()은 호출되지 않음

# or 연산자: 첫 번째가 True면 두 번째를 평가하지 않음
True or expensive_function()  # expensive_function()은 호출되지 않음
```

이는 성능 최적화와 안전한 코드 작성에 도움이 됩니다:

```python
# 안전한 리스트 접근
my_list = [1, 2, 3]
if len(my_list) > 0 and my_list[0] > 0:  # len() 검사가 먼저 수행됨
    print('양수입니다')
```

---

## 🗓️ 윤년 판별 프로그램

### 윤년의 정의

**윤년(Leap Year)**의 조건:
- 4의 배수이고 **AND**
- 100의 배수가 아니거나 **OR**
- 400의 배수일 때

수학적 표현: `(year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)`

### 윤년 판별 코드

```python
youn = int(input("연도를 입력하세요 : "))

print(f"{youn}은 {'윤년' if ((youn % 4 == 0 and youn % 100 != 0) or (youn % 400 == 0)) else '윤년이 아닙니다.'}")
```

#### 💻 코드 실행 상세 분석 (2000년 입력 시)

**1단계 (입력 수신)**:
- 사용자가 `2000` 입력
- `youn` 변수에 정수 `2000` 저장

**2단계 (조건 평가 - 좌측 부분)**:
- `youn % 4 == 0` → `2000 % 4 == 0` → `0 == 0` → `True`
- `youn % 100 != 0` → `2000 % 100 != 0` → `0 != 0` → `False`
- `True and False` → `False`

**3단계 (조건 평가 - 우측 부분)**:
- `youn % 400 == 0` → `2000 % 400 == 0` → `0 == 0` → `True`

**4단계 (최종 조건 평가)**:
- `False or True` → `True`
- 3항 연산자의 조건이 `True`이므로 `'윤년'` 선택

**5단계 (문자열 포매팅)**:
- f-string이 평가되어 `"2000은 윤년"`으로 완성
- `print()` 함수로 출력

**최종 결과**: `2000은 윤년` 출력

### 윤년 판별 예제들

```python
# 테스트 케이스
# 2000년: 400의 배수 → 윤년
# 1900년: 100의 배수지만 400의 배수 아님 → 평년
# 2004년: 4의 배수이고 100의 배수 아님 → 윤년
# 2001년: 4의 배수 아님 → 평년
```

> 🔐 **보안 노트**: 현재 코드의 보안 취약점

### 🔐 윤년 판별 프로그램의 보안 개선

**현재 코드의 문제점**:
1. **타입 검증 부재**: 문자열 입력 시 `ValueError` 발생
2. **범위 검증 부재**: 음수 입력 가능 (예: `-100년`)
3. **예외 처리 부재**: 프로그램 비정상 종료 가능

**개선된 코드**:

```python
def is_leap_year(year):
    """윤년 판별 함수"""
    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)

# 입력 및 검증
try:
    year_input = input("연도를 입력하세요 (1-9999): ")
    
    # 빈 문자열 검증
    if not year_input.strip():
        print("오류: 연도를 입력해주세요.")
        exit(1)
    
    # 길이 제한 (최대 4자리)
    if len(year_input) > 4:
        print("오류: 연도는 4자리 이하로 입력해주세요.")
        exit(1)
    
    year = int(year_input)
    
    # 범위 검증
    if year < 1 or year > 9999:
        print("오류: 연도는 1에서 9999 사이의 값이어야 합니다.")
        exit(1)
    
    # 윤년 판별
    if is_leap_year(year):
        print(f"{year}년은 윤년입니다.")
    else:
        print(f"{year}년은 평년입니다.")

except ValueError:
    print("오류: 올바른 숫자를 입력해주세요.")
    exit(1)
```

**개선 사항**:
1. ✅ 타입 변환 예외 처리
2. ✅ 입력값 범위 검증 (1-9999)
3. ✅ 빈 문자열 검증
4. ✅ 입력 길이 제한
5. ✅ 명확한 오류 메시지

---

## 📅 월별 마지막 날 계산

### 리스트를 활용한 구현

```python
year = int(input('년도를 입력하세요 : '))
month = int(input('월를 입력하세요 : '))

dayLst = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
    dayLst[1] = 29
print(f"{year}년 {month}월의 마지막 날은 {dayLst[month -1]}일 입니다")
```

#### 💻 코드 실행 상세 분석 (2024년 2월 입력 시)

**1단계 (입력 수신)**:
- 사용자가 `2024` 입력 → `year = 2024`
- 사용자가 `2` 입력 → `month = 2`

**2단계 (일수 리스트 초기화)**:
- `dayLst`에 각 월의 기본 일수 저장
- 인덱스 0 (1월): 31일
- 인덱스 1 (2월): 28일 (기본값)
- 인덱스 2 (3월): 31일
- ... 이하 동일

**3단계 (윤년 검사)**:
- `(2024 % 4 == 0 and 2024 % 100 != 0)` → `(True and True)` → `True`
- 조건이 참이므로 2월 일수 수정
- `dayLst[1] = 29` → 리스트의 1번 인덱스(2월)를 29로 변경
- 현재 `dayLst`: `[31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]`

**4단계 (결과 출력)**:
- `dayLst[month - 1]` → `dayLst[2 - 1]` → `dayLst[1]` → `29`
- f-string 포매팅: `"2024년 2월의 마지막 날은 29일 입니다"`

**최종 결과**: `2024년 2월의 마지막 날은 29일 입니다` 출력

> 📌 **노트**: 리스트 인덱스는 0부터 시작하므로 `month - 1`을 사용합니다. 1월은 인덱스 0, 2월은 인덱스 1입니다.

### calendar 모듈 사용

Python 표준 라이브러리의 `calendar` 모듈을 사용하면 더 간단하게 구현할 수 있습니다.

```python
import calendar

year = int(input('년도를 입력하세요 : '))
month = int(input('월를 입력하세요 : '))

day = calendar.monthrange(year, month)
print(f'{year}년 {month}월의 마지막 날은 {day}일')
```

#### 💻 코드 실행 상세 분석

**1단계 (모듈 import)**:
- `import calendar`: Python 표준 라이브러리의 calendar 모듈을 가져옴
- 이 모듈은 달력 관련 다양한 함수를 제공

**2단계 (monthrange 함수 호출)**:
- `calendar.monthrange(2024, 2)` 호출
- 이 함수는 튜플을 반환: `(weekday, days)`
  - `weekday`: 그 달의 첫 날이 무슨 요일인지 (0=월요일, 6=일요일)
  - `days`: 그 달의 일수
- 반환값: `(3, 29)` → 2024년 2월 1일은 목요일(3)이고, 29일까지 있음

**3단계 (결과 출력)**:
- 튜플 전체가 출력되므로 `(calendar.TUESDAY, 29)` 형태로 표시됨

**최종 결과**: `2024년 2월의 마지막 날은 (3, 29)일` 출력

**개선 버전**:
```python
import calendar

year = int(input('년도를 입력하세요 : '))
month = int(input('월를 입력하세요 : '))

weekday, last_day = calendar.monthrange(year, month)
print(f'{year}년 {month}월의 마지막 날은 {last_day}일')
```

> 💡 **중요!**: 실무에서는 직접 구현하기보다 **검증된 라이브러리를 사용**하는 것이 안전합니다. 버그가 적고 예외 상황을 잘 처리합니다.

---

## 📆 날짜 타입 다루기

### date와 datetime

Python의 `datetime` 모듈은 날짜와 시간을 다루는 클래스들을 제공합니다.

```python
from datetime import date, datetime

# date 객체 - 날짜만
today = date.today()
print(today)  # 2025-10-29
print(today.year, today.month, today.day, sep="-")  # 2025-10-29

# datetime 객체 - 날짜 + 시간
now = datetime.today()
print(now)  # 2025-10-29 10:30:45.123456
print(now.year, now.month, now.day, now.hour, now.minute, now.second)
```

#### 💻 코드 실행 상세 분석

**1단계 (date 객체 생성)**:
- `date.today()`: 시스템의 현재 날짜를 가져옴
- 반환값: `date(2025, 10, 29)` 객체
- `today` 변수에 저장

**2단계 (date 속성 접근)**:
- `today.year` → `2025` (정수)
- `today.month` → `10` (정수)
- `today.day` → `29` (정수)
- `sep="-"`: print 함수의 구분자를 하이픈으로 지정

**3단계 (datetime 객체 생성)**:
- `datetime.today()`: 현재 날짜와 시간을 가져옴
- 반환값: `datetime(2025, 10, 29, 10, 30, 45, 123456)` 객체
- 마이크로초 단위까지 정확한 시간 정보 포함

**4단계 (datetime 속성 접근)**:
- `now.year`, `now.month`, `now.day`: date와 동일
- `now.hour` → `10` (시)
- `now.minute` → `30` (분)
- `now.second` → `45` (초)

**최종 결과**:
```
2025-10-29
2025-10-29
2025-10-29 10:30:45.123456
2025 10 29 10 30 45
```

### import 구문 정리

강사님께서 강조하신 import의 여러 형태:

```python
# 1. 모듈 전체 import
import datetime
today = datetime.date.today()

# 2. 모듈에서 특정 클래스/함수만 import
from datetime import date, datetime
today = date.today()

# 3. 패키지 구조에서 import
from package.module import function, class

# 4. 패키지에서 모듈 import
from package import module
```

> 📌 **노트**: 인공지능 분야에서는 `from package.module import function` 형태를 많이 사용합니다. 예: `from tensorflow.keras.layers import Dense, Conv2D`

### dir() 함수로 객체 탐색

```python
today = date.today()
print('dir - ', dir(today))
```

`dir()` 함수는 객체가 가진 모든 속성과 메서드를 리스트로 반환합니다.

출력 예시:
```python
['__add__', '__class__', '__delattr__', '__dir__', '__doc__', '__eq__', 
 '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', 
 '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__ne__', 
 '__new__', '__radd__', '__reduce__', '__reduce_ex__', '__repr__', 
 '__rsub__', '__setattr__', '__sizeof__', '__str__', '__sub__', 
 '__subclasshook__', 'ctime', 'day', 'fromisocalendar', 'fromisoformat', 
 'fromordinal', 'fromtimestamp', 'isocalendar', 'isoformat', 'isoweekday', 
 'max', 'min', 'month', 'replace', 'resolution', 'strftime', 'timetuple', 
 'today', 'toordinal', 'weekday', 'year']
```

유용한 메서드:
- `today()`: 오늘 날짜 반환
- `strftime()`: 날짜를 문자열로 포맷팅
- `isoformat()`: ISO 8601 형식으로 반환
- `weekday()`: 요일 반환 (0=월요일)

---

## ➕ 날짜 연산

### timedelta를 사용한 일(day) 연산

```python
from datetime import date, timedelta

today = date.today()
print('today - ', today)

# 하루 추가
day = timedelta(days=1)
print(today + day)  # 내일 날짜

# 일주일 추가
week = timedelta(days=7)
print(today + week)  # 7일 후

# 한 달 전 (근사값 - 30일)
month_ago = timedelta(days=30)
print(today - month_ago)  # 30일 전
```

#### 💻 코드 실행 상세 분석 (2025-10-29 기준)

**1단계 (현재 날짜 객체 생성)**:
- `date.today()` → `date(2025, 10, 29)`
- `today` 변수에 저장

**2단계 (timedelta 객체 생성)**:
- `timedelta(days=1)` → 1일을 나타내는 시간 간격 객체 생성
- 내부적으로 `datetime.timedelta(1)` 형태로 저장
- `day` 변수에 저장

**3단계 (날짜 연산 수행)**:
- `today + day` 연산 수행
- `date` 객체의 `__add__` 메서드가 호출됨
- 2025년 10월 29일 + 1일 = 2025년 10월 30일
- 새로운 `date(2025, 10, 30)` 객체 반환

**최종 결과**: `2025-10-30` 출력

> ⚠️ **주의**: `timedelta`는 **일(days), 초(seconds), 마이크로초(microseconds)**만 지원합니다. 월(months)이나 년(years) 단위는 지원하지 않습니다!

### relativedelta를 사용한 월/년 연산

`timedelta`의 한계를 극복하기 위해 `dateutil` 패키지의 `relativedelta`를 사용합니다.

```python
from datetime import date
from dateutil.relativedelta import relativedelta

today = date.today()  # 2025-10-29

# 다양한 단위의 시간 간격 생성
day = relativedelta(days=1)
month = relativedelta(months=1)
year = relativedelta(years=1)

print(year, month, day)  # relativedelta(years=+1), relativedelta(months=+1), relativedelta(days=+1)

# 날짜 연산
today = today + year   # 2026-10-29
today = today + month  # 2026-11-29
today = today + day    # 2026-11-30

print(today)  # 2026-11-30
```

#### 💻 코드 실행 상세 분석

**1단계 (relativedelta 객체 생성)**:
- `relativedelta(days=1)`: 1일 간격 객체
- `relativedelta(months=1)`: 1개월 간격 객체
- `relativedelta(years=1)`: 1년 간격 객체

**2단계 (연도 추가)**:
- `today + year` → `date(2025, 10, 29) + relativedelta(years=+1)`
- 연도만 1 증가: `2026-10-29`
- `today` 변수 업데이트

**3단계 (월 추가)**:
- `today + month` → `date(2026, 10, 29) + relativedelta(months=+1)`
- 월만 1 증가: `2026-11-29`
- `today` 변수 업데이트

**4단계 (일 추가)**:
- `today + day` → `date(2026, 11, 29) + relativedelta(days=+1)`
- 일만 1 증가: `2026-11-30`
- `today` 변수 업데이트

**최종 결과**: `2026-11-30` 출력

> 💡 **중요!**: `relativedelta`는 **월말 처리를 자동**으로 해줍니다. 예: 1월 31일 + 1개월 = 2월 28일 (평년) 또는 2월 29일 (윤년)

### relativedelta vs timedelta 비교

| 기능 | timedelta | relativedelta |
|------|-----------|---------------|
| 일(days) | ✅ | ✅ |
| 월(months) | ❌ | ✅ |
| 년(years) | ❌ | ✅ |
| 시간 | ✅ | ✅ |
| 월말 처리 | ❌ | ✅ 자동 |
| 설치 | 표준 라이브러리 | pip install python-dateutil |

---

## 🔄 문자열 ↔ 날짜 변환

### strptime: 문자열 → 날짜

```python
from datetime import datetime

strDate = '2025-10-29'
today = datetime.strptime(strDate, '%Y-%m-%d')
print(today, type(today))  # 2025-10-29 00:00:00 <class 'datetime.datetime'>
```

#### 💻 코드 실행 상세 분석

**1단계 (문자열 준비)**:
- `strDate` 변수에 `'2025-10-29'` 문자열 저장

**2단계 (strptime 함수 호출)**:
- `datetime.strptime(strDate, '%Y-%m-%d')` 실행
- 첫 번째 인자: 파싱할 문자열
- 두 번째 인자: 날짜 형식 지정자
  - `%Y`: 4자리 연도 (2025)
  - `%m`: 2자리 월 (10)
  - `%d`: 2자리 일 (29)

**3단계 (파싱 과정)**:
1. '2025' 부분을 `%Y` 형식으로 해석 → 연도 2025
2. '10' 부분을 `%m` 형식으로 해석 → 월 10
3. '29' 부분을 `%d` 형식으로 해석 → 일 29
4. 시간 정보가 없으므로 00:00:00으로 설정
5. `datetime(2025, 10, 29, 0, 0, 0)` 객체 생성

**4단계 (결과 반환)**:
- `today` 변수에 datetime 객체 저장
- `type(today)` → `<class 'datetime.datetime'>`

**최종 결과**: `2025-10-29 00:00:00 <class 'datetime.datetime'>` 출력

### strftime: 날짜 → 문자열

```python
from datetime import datetime

today = datetime.now()  # 2025-10-29 14:30:45.123456
formatted = today.strftime('%Y-%m-%d')
print(formatted, type(formatted))  # 2025-10-29 <class 'str'>

# 다양한 포맷
print(today.strftime('%Y/%m/%d'))  # 2025/10/29
print(today.strftime('%Y년 %m월 %d일'))  # 2025년 10월 29일
print(today.strftime('%H:%M:%S'))  # 14:30:45
```

#### 💻 코드 실행 상세 분석

**1단계 (현재 시간 객체 생성)**:
- `datetime.now()` → 시스템의 현재 날짜와 시간 반환
- 예: `datetime(2025, 10, 29, 14, 30, 45, 123456)`

**2단계 (strftime 메서드 호출)**:
- `today.strftime('%Y-%m-%d')` 실행
- datetime 객체를 형식 지정자에 따라 문자열로 변환

**3단계 (포매팅 과정)**:
1. `%Y` → `today.year` → `'2025'`
2. `-` → 그대로 유지 → `'-'`
3. `%m` → `f'{today.month:02d}'` → `'10'` (2자리로 패딩)
4. `-` → 그대로 유지 → `'-'`
5. `%d` → `f'{today.day:02d}'` → `'29'` (2자리로 패딩)
6. 모두 결합: `'2025-10-29'`

**4단계 (결과 반환)**:
- 문자열 `'2025-10-29'` 반환
- `type(formatted)` → `<class 'str'>`

**최종 결과**: `2025-10-29 <class 'str'>` 출력

### 주요 날짜 형식 지정자

| 지정자 | 의미 | 예시 |
|--------|------|------|
| `%Y` | 4자리 연도 | 2025 |
| `%y` | 2자리 연도 | 25 |
| `%m` | 월 (01-12) | 10 |
| `%d` | 일 (01-31) | 29 |
| `%H` | 시 (00-23) | 14 |
| `%I` | 시 (01-12) | 02 |
| `%M` | 분 (00-59) | 30 |
| `%S` | 초 (00-59) | 45 |
| `%A` | 요일 (full) | Tuesday |
| `%a` | 요일 (short) | Tue |
| `%B` | 월 (full) | October |
| `%b` | 월 (short) | Oct |

> 📌 **노트**: 강사님께서 강조하신 점은 "**대소문자를 구분**한다"는 것입니다. `%Y`는 4자리 연도, `%y`는 2자리 연도입니다. 또한 `-` 대신 `/`를 사용하면 `2025/10/29` 형식이 됩니다.

---

## 🎯 3항 연산자 (Ternary Operator)

Python의 3항 연산자는 `if-else`를 한 줄로 표현하는 간결한 방법입니다.

### 기본 구조

```
결과1 if 조건 else 결과2
```

- 조건이 `True`면 `결과1` 반환
- 조건이 `False`면 `결과2` 반환

### 기본 예제

```python
a = 10
b = 20

maxValue = a if a > b else b
print(maxValue)  # 20
```

#### 💻 코드 실행 상세 분석

**1단계 (변수 초기화)**:
- `a = 10`, `b = 20` 값 저장

**2단계 (조건 평가)**:
- `a > b` → `10 > 20` → `False`

**3단계 (결과 선택)**:
- 조건이 `False`이므로 `else` 뒤의 값 선택
- `b` 값인 `20` 반환

**4단계 (변수 할당)**:
- `maxValue = 20`

**최종 결과**: `20` 출력

### 실전 예제: 성인/미성년자 판별

```python
age = 20
status = "성인" if age >= 18 else "미성년자"
print(status)  # 성인
```

### 리스트 컴프리헨션과 결합

```python
import random

lst = []
for _ in range(1, 10):
    nan = random.randint(1, 100)
    lst.append(nan)

print(lst)  # [42, 17, 89, 3, 56, 71, 28, 94, 65]

result = ["짝수" if data % 2 == 0 else "홀수" for data in lst]
print(result)  # ['짝수', '홀수', '홀수', '홀수', '짝수', '홀수', '짝수', '짝수', '홀수']
```

#### 💻 코드 실행 상세 분석

**1단계 (난수 리스트 생성)**:
- `range(1, 10)`: 1부터 9까지 (9개)
- 각 반복마다 `random.randint(1, 100)`: 1~100 사이의 난수 생성
- `_`: 사용하지 않는 변수를 나타내는 관례적 표현
- 예시 결과: `[42, 17, 89, 3, 56, 71, 28, 94, 65]`

**2단계 (리스트 컴프리헨션 실행)**:
- `for data in lst`: 리스트의 각 요소를 순회
- 각 요소마다 3항 연산자 평가:
  - `42 % 2 == 0` → `True` → "짝수"
  - `17 % 2 == 0` → `False` → "홀수"
  - `89 % 2 == 0` → `False` → "홀수"
  - ... (이하 동일한 방식으로 진행)

**3단계 (결과 리스트 생성)**:
- 각 평가 결과를 모아 새 리스트 생성
- `result = ['짝수', '홀수', '홀수', '홀수', '짝수', '홀수', '짝수', '짝수', '홀수']`

**최종 결과**: 짝수/홀수 판별 리스트 출력

> 💡 **중요!**: 리스트 컴프리헨션 내부에서 3항 연산자를 사용하면 복잡한 변환 로직을 한 줄로 표현할 수 있습니다. 데이터 전처리에서 매우 유용합니다!

### 중첩 3항 연산자 (비권장)

```python
pNum = input("핸드폰 번호를 입력하세요 : ")
tong = pNum[0:3]
result = "SKT" if tong == '011' else ("kt" if tong == '016' else ('LG' if tong == '019' else "Not Found"))
print(result)
```

#### 💻 코드 실행 상세 분석 (사용자가 "01012345678" 입력 시)

**1단계 (입력 수신)**:
- `pNum = "01012345678"`

**2단계 (통신사 코드 추출)**:
- `pNum[0:3]` → 문자열 슬라이싱으로 처음 3자리 추출
- `tong = "010"`

**3단계 (중첩 3항 연산자 평가)**:
1. `tong == '011'` → `"010" == "011"` → `False`
2. `else` 부분으로 이동: `("kt" if tong == '016' else (...))`
3. `tong == '016'` → `"010" == "016"` → `False`
4. `else` 부분으로 이동: `('LG' if tong == '019' else "Not Found")`
5. `tong == '019'` → `"010" == "019"` → `False`
6. 최종 `else` 부분: `"Not Found"` 반환

**4단계 (결과 출력)**:
- `result = "Not Found"`
- `print("Not Found")`

**최종 결과**: `Not Found` 출력

> ⚠️ **주의**: 중첩된 3항 연산자는 **가독성이 매우 떨어집니다**. 실무에서는 `if-elif-else` 문을 사용하거나 딕셔너리 매핑을 권장합니다.

**개선된 코드**:
```python
pNum = input("핸드폰 번호를 입력하세요 : ")
tong = pNum[0:3]

telecom_map = {
    '011': 'SKT',
    '016': 'KT',
    '019': 'LG',
    '010': 'SKT/KT/LG'  # 010은 모든 통신사 사용
}

result = telecom_map.get(tong, "Not Found")
print(result)
```

---

## 🔁 반복구문 (Loop)

### for 문 기본

`for` 문은 **열거형(iterable) 객체**를 순회하며 반복 작업을 수행합니다.

```python
for data in range(10):
    print(data)
```

출력:
```
0
1
2
3
4
5
6
7
8
9
```

#### 💻 코드 실행 상세 분석

**1단계 (range 객체 생성)**:
- `range(10)`: 0부터 9까지의 정수 시퀀스 생성
- 실제로는 메모리 효율을 위해 lazy evaluation (지연 평가) 사용
- 필요할 때마다 값을 하나씩 생성

**2단계 (반복 시작)**:
- **첫 번째 반복**: `data = 0`, `print(0)` 실행
- **두 번째 반복**: `data = 1`, `print(1)` 실행
- **세 번째 반복**: `data = 2`, `print(2)` 실행
- ... (이하 동일하게 진행)
- **열 번째 반복**: `data = 9`, `print(9)` 실행

**3단계 (반복 종료)**:
- `range(10)`의 모든 요소를 순회했으므로 반복 종료
- 프로그램은 for 문 다음 줄로 이동

**최종 결과**: 0부터 9까지 출력

### 문자열 순회

```python
msg = 'see u next time'
for char in msg:
    print(char, end='')
```

출력: `see u next time`

#### 💻 코드 실행 상세 분석

**1단계 (문자열 준비)**:
- `msg = 'see u next time'`
- 문자열은 iterable 객체이므로 for 문으로 순회 가능

**2단계 (문자별 순회)**:
- **첫 번째**: `char = 's'`, `print('s', end='')` → 's' 출력 (줄바꿈 없음)
- **두 번째**: `char = 'e'`, `print('e', end='')` → 'e' 출력
- **세 번째**: `char = 'e'`, `print('e', end='')` → 'e' 출력
- **네 번째**: `char = ' '`, `print(' ', end='')` → 공백 출력
- ... (이하 모든 문자에 대해 동일하게 진행)

**3단계 (end 파라미터)**:
- `end=''`: print 함수의 기본 종료 문자인 `\n`(줄바꿈)을 빈 문자열로 변경
- 따라서 모든 문자가 같은 줄에 연속으로 출력됨

**최종 결과**: `see u next time` (한 줄로 출력)

### 인덱스를 이용한 순회

```python
msg = 'see u next time'
for idx in range(len(msg)):
    print(msg[idx], end="")
```

#### 💻 코드 실행 상세 분석

**1단계 (문자열 길이 계산)**:
- `len(msg)` → `15` (공백 포함)
- `range(15)` 생성 → 0~14

**2단계 (인덱스 기반 순회)**:
- **idx = 0**: `msg[0]` → `'s'` 출력
- **idx = 1**: `msg[1]` → `'e'` 출력
- **idx = 2**: `msg[2]` → `'e'` 출력
- **idx = 3**: `msg[3]` → `' '` 출력 (공백)
- ... (이하 idx=14까지 진행)

**최종 결과**: `see u next time` 출력

> 📌 **노트**: 직접 문자열을 순회하는 것(`for char in msg`)이 더 pythonic하고 간결합니다. 인덱스가 필요한 경우에만 `range(len(...))`을 사용하세요.

---

## 🔢 enumerate() 함수

`enumerate()`는 인덱스와 값을 동시에 얻을 수 있는 매우 유용한 함수입니다.

```python
tupleTmp = (4, 6, 1, 3)
for idx, data in enumerate(tupleTmp):
    print('idx - ', idx, 'data - ', data)
```

출력:
```
idx -  0 data -  4
idx -  1 data -  6
idx -  2 data -  1
idx -  3 data -  3
```

#### 💻 코드 실행 상세 분석

**1단계 (튜플 준비)**:
- `tupleTmp = (4, 6, 1, 3)`

**2단계 (enumerate 객체 생성)**:
- `enumerate(tupleTmp)`: 각 요소를 `(인덱스, 값)` 튜플로 변환하는 iterator 생성
- 내부적으로: `[(0, 4), (1, 6), (2, 1), (3, 3)]`와 유사한 시퀀스 생성

**3단계 (언패킹(unpacking)과 반복)**:
- **첫 번째 반복**:
  - `(0, 4)` 튜플이 반환됨
  - `idx, data = (0, 4)` → 언패킹
  - `idx = 0`, `data = 4`
  - `print('idx - ', 0, 'data - ', 4)` 실행
  
- **두 번째 반복**:
  - `(1, 6)` 튜플이 반환됨
  - `idx = 1`, `data = 6`
  - 출력 실행
  
- **세 번째, 네 번째 반복**: 동일한 방식으로 진행

**최종 결과**: 인덱스와 값이 함께 출력됨

> 💡 **중요!**: `enumerate()`는 **언패킹(unpacking)**을 활용합니다. 튜플 `(0, 4)`를 `idx, data` 두 개의 변수로 자동 분리합니다.

### enumerate의 시작 인덱스 지정

```python
fruits = ['apple', 'banana', 'cherry']
for idx, fruit in enumerate(fruits, start=1):
    print(f'{idx}. {fruit}')
```

출력:
```
1. apple
2. banana
3. cherry
```

---

## 📊 단어 빈도수 계산 (for 문 활용)

```python
wordLst = ['dog', 'dog', 'cat', 'cat', 'word', 'dog', 'cat', 'cs', 'cat', 'cs', 'sk', 'sk']
result = {}
for data in wordLst:
    if data in result:
        result[data] += 1
    else:
        result[data] = 1
print(result)
```

출력: `{'dog': 3, 'cat': 4, 'word': 1, 'cs': 2, 'sk': 2}`

#### 💻 코드 실행 상세 분석

**1단계 (초기화)**:
- `wordLst`: 단어 리스트 준비
- `result = {}`: 빈 딕셔너리 생성 (빈도수 저장용)

**2단계 (첫 번째 반복 - 'dog')**:
- `data = 'dog'`
- `'dog' in result` → `'dog' in {}` → `False`
- `else` 블록 실행: `result['dog'] = 1`
- 현재 `result`: `{'dog': 1}`

**3단계 (두 번째 반복 - 'dog')**:
- `data = 'dog'`
- `'dog' in result` → `'dog' in {'dog': 1}` → `True`
- `if` 블록 실행: `result['dog'] += 1` → `result['dog'] = 2`
- 현재 `result`: `{'dog': 2}`

**4단계 (세 번째 반복 - 'cat')**:
- `data = 'cat'`
- `'cat' in result` → `False`
- `else` 블록 실행: `result['cat'] = 1`
- 현재 `result`: `{'dog': 2, 'cat': 1}`

**5단계 (네 번째 반복 - 'cat')**:
- `data = 'cat'`
- `'cat' in result` → `True`
- `if` 블록 실행: `result['cat'] += 1` → `result['cat'] = 2`
- 현재 `result`: `{'dog': 2, 'cat': 2}`

**... (이하 동일한 방식으로 모든 단어 처리)**

**최종 결과**: `{'dog': 3, 'cat': 4, 'word': 1, 'cs': 2, 'sk': 2}`

> 💡 **중요!**: 이 패턴은 **빈도수 계산(frequency counting)**의 전형적인 방법입니다. 딕셔너리를 활용하여 O(n) 시간 복잡도로 효율적으로 처리합니다.

---

## 🎮 숫자 맞추기 게임 (Guess Game)

### while 문 버전

```python
from random import randint

print('guess game - ')
print('1 ~100 사이의 난수를 생성하고 숫자를 맞춰보는 게임')
ranNum = randint(1, 100)
inputNum = 0
count = 1
while ranNum != inputNum and count < 10:
    inputNum = int(input(f"숫자를 맞춰주세요({count}번째 시도): "))
    if inputNum > ranNum:
        print("다운")
        count += 1
    elif inputNum < ranNum:
        print("업")
        count += 1
    else:
        print(f"{count}번만에 정답! ranNum은 {ranNum} 이었어요")

    if count == 10:
        print("10회 동안 못 맞췄어요..")
        break
print(f"정답{ranNum}" if ranNum == inputNum else f"실패! 정답은 {ranNum}")
```

#### 💻 코드 실행 상세 분석 (정답이 57이고, 사용자가 50, 70, 60, 55, 57 순으로 입력)

**1단계 (초기화)**:
- `randint(1, 100)`: 1~100 사이의 난수 생성 → 예: `57`
- `ranNum = 57`
- `inputNum = 0` (초기값)
- `count = 1` (시도 횟수)

**2단계 (첫 번째 시도 - 50 입력)**:
- **while 조건 검사**: `57 != 0 and 1 < 10` → `True`
- 사용자 입력: `50`
- `inputNum = 50`
- **비교**: `50 > 57` → `False`
- **elif 검사**: `50 < 57` → `True`
- "업" 출력
- `count += 1` → `count = 2`

**3단계 (두 번째 시도 - 70 입력)**:
- **while 조건**: `57 != 50 and 2 < 10` → `True`
- 사용자 입력: `70`
- `inputNum = 70`
- **비교**: `70 > 57` → `True`
- "다운" 출력
- `count = 3`

**4단계 (세 번째 시도 - 60 입력)**:
- **while 조건**: `57 != 70 and 3 < 10` → `True`
- 사용자 입력: `60`
- `inputNum = 60`
- **비교**: `60 > 57` → `True`
- "다운" 출력
- `count = 4`

**5단계 (네 번째 시도 - 55 입력)**:
- **while 조건**: `57 != 60 and 4 < 10` → `True`
- 사용자 입력: `55`
- `inputNum = 55`
- **비교**: `55 < 57` → `True`
- "업" 출력
- `count = 5`

**6단계 (다섯 번째 시도 - 57 입력)**:
- **while 조건**: `57 != 55 and 5 < 10` → `True`
- 사용자 입력: `57`
- `inputNum = 57`
- **비교**: `57 > 57` → `False`
- **elif 검사**: `57 < 57` → `False`
- **else 블록**: "5번만에 정답! ranNum은 57 이었어요" 출력
- `count = 5` (증가하지 않음)

**7단계 (반복 종료)**:
- **while 조건**: `57 != 57 and 5 < 10` → `False and True` → `False`
- 반복 종료

**8단계 (최종 출력)**:
- `ranNum == inputNum` → `57 == 57` → `True`
- "정답57" 출력

**최종 결과**: 5번 만에 정답을 맞춤

> 📌 **노트**: 강사님께서 강조하신 점은 "**for와 while의 사용 구분**"입니다. while은 주어진 횟수가 정해지지 않은 상황에서, for는 특정한 횟수가 제공될 때 사용합니다.

### for 문 버전 (for ~ else 활용)

```python
from random import randint

print('guess game - ')
print('1 ~100 사이의 난수를 생성하고 숫자를 맞춰보는 게임')
ranNum = randint(1, 100)
inputNum = 0
count = 1
print(ranNum)
for i in range(10):
    inputNum = int(input(f"숫자를 맞춰주세요{count}번째 시도: "))
    if inputNum > ranNum:
        print("다운")
        count += 1
    elif inputNum < ranNum:
        print("업")
        count += 1
    else:
        print(f"{count}번만에 정답! ranNum은 {ranNum} 이었어요")
        break
else:
    print(f'정답 {ranNum}, 제공되는 기회를 전부 사용하였습니다.')
```

#### 💻 코드 실행 상세 분석

**핵심 차이점: for ~ else 구문**

`for ~ else`의 동작 방식:
- `for` 문이 **정상적으로 완료**되면 (break 없이) `else` 블록 실행
- `break`로 **중간에 종료**되면 `else` 블록 실행 안됨

**시나리오 1: 10번 안에 맞추지 못함**
- `for` 문이 10번 모두 실행됨
- `break` 발생 안함
- → `else` 블록 실행: "정답 57, 제공되는 기회를 전부 사용하였습니다." 출력

**시나리오 2: 5번 만에 맞춤**
- 5번째 시도에서 정답
- `else` 블록에서 "5번만에 정답!" 출력
- `break` 실행으로 반복 종료
- → `for ~ else`의 `else` 블록 **실행 안됨**

> 💡 **중요!**: `for ~ else` 구문은 Python의 독특한 기능입니다. C++, Java 등 다른 언어에는 없는 문법으로, "정상 완료 여부"를 감지하는 데 매우 유용합니다.

---

## 🔐 숫자 맞추기 게임의 보안 개선

### 🔐 보안 취약점 분석

**취약점 1: 입력 검증 부재**
```python
inputNum = int(input(...))  # 문자열 입력 시 예외 발생
```

**취약점 2: 범위 검증 부재**
```python
# 사용자가 -1000 또는 1000000 입력 가능
# 논리적으로 불가능한 입력을 받아들임
```

**취약점 3: 무한 반복 가능 (while 버전)**
```python
# count < 10 조건이 있지만, count가 증가하지 않는 코드 경로 존재 가능
```

### 🔐 개선된 보안 코드

```python
from random import randint

def get_valid_input(prompt, min_val, max_val):
    """유효한 정수 입력을 받는 함수"""
    while True:
        try:
            user_input = input(prompt)
            
            # 길이 제한
            if len(user_input) > 10:
                print("오류: 입력이 너무 깁니다.")
                continue
            
            # 정수 변환
            value = int(user_input)
            
            # 범위 검증
            if min_val <= value <= max_val:
                return value
            else:
                print(f"오류: {min_val}~{max_val} 사이의 숫자를 입력하세요.")
        
        except ValueError:
            print("오류: 올바른 숫자를 입력하세요.")
        except KeyboardInterrupt:
            print("\n게임을 종료합니다.")
            exit(0)

# 메인 게임 로직
print('=== 숫자 맞추기 게임 ===')
print('1~100 사이의 숫자를 맞춰보세요!')

answer = randint(1, 100)
MAX_TRIES = 10

for attempt in range(1, MAX_TRIES + 1):
    print(f'\n[{attempt}/{MAX_TRIES}] 시도')
    guess = get_valid_input("숫자를 입력하세요: ", 1, 100)
    
    if guess == answer:
        print(f'🎉 정답! {attempt}번 만에 맞추셨습니다!')
        break
    elif guess < answer:
        print('📈 Up! 더 큰 숫자입니다.')
    else:
        print('📉 Down! 더 작은 숫자입니다.')
else:
    print(f'\n😢 실패! 정답은 {answer}였습니다.')
```

**개선 사항**:
1. ✅ 입력 검증 함수 분리
2. ✅ 예외 처리 강화
3. ✅ 입력 길이 제한
4. ✅ 범위 검증
5. ✅ Ctrl+C 처리
6. ✅ 사용자 친화적 메시지

---

## 🏅 올림픽 연도 출력

### 요구사항

4년에 한 번씩 열리는 올림픽 (2024년 시작)  
향후 50년 동안 열리는 올림픽 연도 출력  
한 줄에 5개씩만 출력

```python
cnt = 0
for year in range(2024, 2074, 4):
    cnt += 1
    if cnt % 5 == 0:
        print(year, end='\n')
    else:
        print(year, end='\t')
```

출력:
```
2024	2028	2032	2036	2040
2044	2048	2052	2056	2060
2064	2068	2072
```

#### 💻 코드 실행 상세 분석

**1단계 (range 생성)**:
- `range(2024, 2074, 4)`: 2024부터 2070까지 4씩 증가
- 생성되는 값: 2024, 2028, 2032, ..., 2072 (총 13개)

**2단계 (반복 및 카운팅)**:
- **year=2024, cnt=1**:
  - `1 % 5 == 0` → `False`
  - `print(2024, end='\t')` → "2024	" 출력

- **year=2028, cnt=2**:
  - `2 % 5 == 0` → `False`
  - `print(2028, end='\t')` → "2028	" 출력

- **year=2032, cnt=3**:
  - `3 % 5 == 0` → `False`
  - `print(2032, end='\t')` → "2032	" 출력

- **year=2036, cnt=4**:
  - `4 % 5 == 0` → `False`
  - `print(2036, end='\t')` → "2036	" 출력

- **year=2040, cnt=5**:
  - `5 % 5 == 0` → `True`
  - `print(2040, end='\n')` → "2040\n" 출력 (줄바꿈)

- **year=2044, cnt=6**:
  - `6 % 5 == 0` → `False`
  - 새 줄에 "2044	" 출력

**... (이하 동일한 패턴 반복)**

**최종 결과**: 5개씩 묶여서 3줄로 출력

> 💡 **중요!**: `cnt % 5 == 0`을 사용하여 5의 배수마다 줄바꿈을 수행합니다. 이는 **모듈로 연산을 활용한 그룹핑**의 전형적인 예입니다.

---

## 📊 구구단 출력

### 단일 단 출력

```python
dan = int(input("단을 입력하세요 : "))
for gu in range(1, 10):
    print(f'{dan} * {gu} = {dan*gu}')
```

출력 (9단 입력 시):
```
9 * 1 = 9
9 * 2 = 18
9 * 3 = 27
9 * 4 = 36
9 * 5 = 45
9 * 6 = 54
9 * 7 = 63
9 * 8 = 72
9 * 9 = 81
```

### 전체 구구단 출력 (중첩 반복문)

```python
print('구구단 - ')

for row in range(2, 10):
    for col in range(1, 10):
        print(f'{row} * {col} = {row*col}', end="\t")
    print()
```

출력:
```
구구단 - 
2 * 1 = 2	2 * 2 = 4	2 * 3 = 6	2 * 4 = 8	2 * 5 = 10	2 * 6 = 12	2 * 7 = 14	2 * 8 = 16	2 * 9 = 18	
3 * 1 = 3	3 * 2 = 6	3 * 3 = 9	3 * 4 = 12	3 * 5 = 15	3 * 6 = 18	3 * 7 = 21	3 * 8 = 24	3 * 9 = 27	
4 * 1 = 4	4 * 2 = 8	4 * 3 = 12	4 * 4 = 16	4 * 5 = 20	4 * 6 = 24	4 * 7 = 28	4 * 8 = 32	4 * 9 = 36	
...
```

#### 💻 코드 실행 상세 분석

**1단계 (외부 반복 시작 - row=2)**:
- `row = 2` (2단)
- 내부 반복문 진입

**2단계 (내부 반복 - col 1~9)**:
- **col=1**: `print('2 * 1 = 2', end="\t")` → "2 * 1 = 2	" 출력
- **col=2**: `print('2 * 2 = 4', end="\t")` → "2 * 2 = 4	" 출력
- **col=3**: `print('2 * 3 = 6', end="\t")` → "2 * 3 = 6	" 출력
- ... (col=9까지 반복)
- 내부 반복 완료 후 `print()` → 줄바꿈

**3단계 (외부 반복 계속 - row=3)**:
- `row = 3` (3단)
- 다시 내부 반복문 진입
- 3단 전체 출력 후 줄바꿈

**... (row=9까지 반복)**

**최종 결과**: 2단부터 9단까지 전체 구구단 출력

> 📌 **노트**: 중첩 반복문에서 외부 반복문이 1회 실행될 때마다 내부 반복문은 전체가 실행됩니다. 따라서 총 실행 횟수는 `8(외부) × 9(내부) = 72번`입니다.

### continue와 break 활용

```python
print('구구단 - ')

for row in range(2, 10):
    if row == 5:
        continue  # 5단 건너뛰기
    
    for col in range(1, 10):
        print(f'{row} * {col} = {row*col}', end="\t")
    print()
    
    if row == 3:
        break  # 3단까지만 출력
```

#### continue vs break

| 키워드 | 동작 | 사용 상황 |
|--------|------|-----------|
| `continue` | 현재 반복만 건너뛰고 다음 반복 진행 | 특정 조건의 데이터 무시 |
| `break` | 반복문 전체를 즉시 종료 | 원하는 값을 찾았거나 오류 발생 시 |

---

## 🎯 오늘 배운 핵심 정리

### 1. 제어구문 (분기문)

- `if`, `elif`, `else`: 조건에 따른 코드 실행
- Truthy/Falsy 개념
- `in` 연산자로 멤버십 테스트
- 중첩 if문 지양 (가독성, 유지보수)

### 2. 입력과 보안

- `input()`: 항상 문자열 반환
- 타입 변환 필수: `int()`, `float()`
- **보안 필수 요소**:
  - 예외 처리 (`try-except`)
  - 입력 범위 검증
  - 입력 길이 제한

### 3. 날짜 처리

- `date`: 날짜만
- `datetime`: 날짜 + 시간
- `timedelta`: 일 단위 연산
- `relativedelta`: 월/년 단위 연산
- `strptime()`: 문자열 → 날짜
- `strftime()`: 날짜 → 문자열

### 4. 3항 연산자

```python
결과1 if 조건 else 결과2
```
- 간결한 조건부 표현
- 중첩은 비권장

### 5. 반복구문

**for 문**:
- 횟수가 정해진 반복
- 열거형 객체 순회
- `enumerate()`: 인덱스+값

**while 문**:
- 횟수가 불확정한 반복
- 조건이 True인 동안 계속

**for ~ else / while ~ else**:
- 정상 완료 시 `else` 블록 실행
- `break`로 종료 시 실행 안됨

---

## 💡 실전 팁과 베스트 프랙티스

### 1. 가독성 우선

```python
# ❌ 나쁜 예
if a>0:if b>0:print("positive")

# ✅ 좋은 예
if a > 0:
    if b > 0:
        print("positive")
```

### 2. 복잡한 조건은 변수로 분리

```python
# ❌ 나쁜 예
if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
    print("윤년")

# ✅ 좋은 예
is_divisible_by_4 = year % 4 == 0
is_not_century = year % 100 != 0
is_divisible_by_400 = year % 400 == 0
is_leap_year = (is_divisible_by_4 and is_not_century) or is_divisible_by_400

if is_leap_year:
    print("윤년")
```

### 3. 조기 반환 (Early Return)

```python
# ❌ 나쁜 예
def check_score(score):
    if score >= 0 and score <= 100:
        if score >= 60:
            return "Pass"
        else:
            return "Fail"
    else:
        return "Invalid"

# ✅ 좋은 예
def check_score(score):
    if score < 0 or score > 100:
        return "Invalid"
    
    if score >= 60:
        return "Pass"
    
    return "Fail"
```

### 4. 리스트 컴프리헨션 활용

```python
# ❌ 나쁜 예
result = []
for i in range(10):
    if i % 2 == 0:
        result.append(i * 2)

# ✅ 좋은 예
result = [i * 2 for i in range(10) if i % 2 == 0]
```

### 5. 매직 넘버 제거

```python
# ❌ 나쁜 예
if score >= 60:
    print("Pass")

# ✅ 좋은 예
PASSING_SCORE = 60
if score >= PASSING_SCORE:
    print("Pass")
```

---

## 🔮 다음 강의 예고

강사님께서 말씀하신 내용:
> "지금까지는 저희가 이렇게 늘어진 코드들을 작성했잖아요. 이런 느렸어 있는 코드들을 이제 어떻게 해야 돼요? **재활용할 수 있어야겠죠?** 그러기 위해서는 뭘 배우셔야겠다 이제 이런 기능들을 **함수에 넣는 작업**이 필요해지게 되는 거죠."

**4일차 예정 내용**:
- **함수(Function)** 정의와 호출
- 매개변수와 반환값
- 함수의 재사용성
- 퀴즈 풀이

---

## 📝 학습 정리 및 회고

### 오늘 배운 내용의 중요성

오늘 배운 제어구문과 반복문은 **프로그래밍의 핵심**입니다. 강사님께서 강조하셨듯이:

1. **데이터 분석**: 대량의 데이터에서 조건에 맞는 것만 필터링
2. **인공지능**: 모델 학습 시 반복적인 연산 수행
3. **웹 개발**: 사용자 입력 검증과 처리
4. **보안**: 입력값 검증과 예외 처리

### 실습 과제 (강사님 권장사항)

1. **윤년 판별기 개선**: 예외 처리와 입력 검증 추가
2. **숫자 맞추기 게임 확장**: 난이도 선택 기능 추가
3. **달력 출력 프로그램**: 특정 년월의 달력을 콘솔에 예쁘게 출력
4. **로또 번호 생성기**: 1~45 중 중복 없이 6개 추출

### 보안적 관점에서 기억할 점

> 🔐 **핵심 원칙**: "**사용자 입력을 절대 신뢰하지 마라**"

모든 입력에 대해:
1. ✅ 타입 검증
2. ✅ 범위 검증
3. ✅ 길이 제한
4. ✅ 예외 처리
5. ✅ 명확한 오류 메시지

---

## 🎓 마무리

강사님의 마지막 말씀:
> "오늘도 여러분들 본인이 계신 자리에서 열심히 본인을 위해서 열심히 전진하셨을까요? 한 발짝 더 나아가셨을까요? 혹시 무서워서 이렇게 뒤로 후퇴하신 분들 계십니까? 네, **우직하게 한 발 내딛어 보시기 바랍니다.** 그러면 어느 순간인가 발전되어 있는 군인의 모습을 군인이 느끼지 않으실까라는 그런 긍정의 해로 돌려보면서"

3일차 강의를 마치며, 제어구문과 반복문이라는 강력한 도구를 손에 넣었습니다. 이제 데이터를 조건에 따라 처리하고, 반복 작업을 자동화할 수 있게 되었습니다. 

내일은 이 코드들을 **재사용 가능한 함수**로 만드는 방법을 배우게 됩니다. 함수를 배우면 코드의 재사용성과 유지보수성이 크게 향상됩니다!

**수고하셨습니다! 👏**

---

## 📎 참고 자료

### 공식 문서

- [Python 공식 문서 - Control Flow](https://docs.python.org/3/tutorial/controlflow.html)
- [Python 공식 문서 - datetime](https://docs.python.org/3/library/datetime.html)
- [Python 공식 문서 - collections](https://docs.python.org/3/library/collections.html)

### 추천 학습 자료

- "파이썬 코딩 도장" - 제어문과 반복문 챕터
- "점프 투 파이썬" - 03장 프로그램의 구조
- Real Python - "Python '!=' Is Not 'is not'"

### 보안 관련 자료

- OWASP Top 10 - Input Validation
- CWE-20: Improper Input Validation
- Python Security Best Practices

---

**강의 노트 작성 완료: 2025년 10월 29일**  
**다음 강의: 4일차 - 함수(Function)**  
**작성자: 파이썬 보안 교육과정 수강생**
